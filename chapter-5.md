---
title: Итерация
isFree: true
---

# 5. Итерация 

Компьютерлер қайталанатын тапсырмаларды автоматтандыру үшін  жиі қолданылады. Бірдей немесе ұқсас тапсырмаларды ұзақ әрі қатесіз қайталау - компьютерлер жақсы, ал адамдар нашар орындайтын нәрсе.

Операциялар жиынын қайталап орындау итерация деп аталады. Итерация өте кең таралғандықтан, Python оны жеңілдету үшін бірнеше бағдарламалау мүмкіндіктерін ұсынады. Біз 3-ші тарауда ```for``` амалын көрдік. Бұл сіз жиі қолданатын итерация түрі. Бірақ бұл тарауда біз ```while``` операторын қарастырамыз — бағдарламаңыздың итерациясын жасаудың тағы бір жолы, ол кейбір өзгеше жағдайларда пайдалы.

Бірақ оған кіріспес бұрын, бірнеше идеяны қарастырайық ...

## 5.1. Тағайындау 

Алдыңғы тарауларда айтқанымыздай, бір айнымалыға бірнеше тағайындаулар жасау заңды. Жаңа тағайындау сол сәтке дейін бар болған айнымалыны жаңа мәнге сілтеме жасайды (және ескі мәнге сілтеме жасауын тоқтатады).

```python
eseptegi_tenge = 15
print(eseptegi_tenge)
eseptegi_tenge = 7
print(eseptegi_tenge)
```

Бұл бағдарламаның нәтижесі:

```python
15
7
```

өйткені бірінші рет ```eseptegi_tenge``` мәні басып шығарылғанда, алғашында 15, ал екінші рет оның мәні 7.

Әсіресе тағайындау амалы мен теңдікті тексеретін логикалық өрнекті ажырату өте маңызды. Python _тағайындау_ үшін тең таңбалауышты ( = ) пайдаланатындықтан, a = b сияқты амалды Boolean test (логикалық сынақ) ретінде қабылдап қалуымыз мүмкін. Бірақ ол олай емес, мұнда заңдылық математикадан өзгеше! Теңдік операторы үшін Python-ның таңбалауышы белгілеушісі **==** (екі теңдік) екенін есте сақтаңыз.

Теңдік сынағы симметриялы, бірақ тағайындау олай емес екенін ескеріңіз. Мысалы, егер a == 7 болса, онда 7 == a . Бірақ Python-да a = 7 амалы заңды және 7 = a заңды емес.

Python-да тағайындау амалы екі айнымалы мәнді теңестіре алады, бірақ келесі тағайындаулар олардың кез келгенін өзгерте алатындықтан, олардың осылай тұрақты тең болып қалуы міндетті емес:

```python
a = 5
b = a    # Осы жолды орындағаннан кейін a және b енді тең 
a = 3    # Осы жолды орындағаннан кейін a және b енді тең болмайды
```

Үшінші жол ```a``` мәнін өзгертеді, бірақ ```b``` мәнін өзгертпейді, сондықтан олар енді тең емес. 

> Кейбір бағдарламалау тілдерінде шатастыруды болдырмау үшін тағайындау үшін басқа таңба пайдаланылады, мысалы, ```<-``` немесе ```:=```. Кейбір адамдар _variable_ сөзін таңдау қате болды деп есептейді, оның орнына біз _assignables_ сөзін таңдаумыз қажет еді деп есептейді. C, C++, Java және C# сияқты тілдерде де кездесетін жалпы терминологияны және token-дерді Python тілі де қолдануды таңдаған, сондықтан біз тағайындау үшін = таңбалауыштарын, теңдік үшін == таңбаларын қолданамыз және _variable_ туралы айтамыз .

## 5.2. Айнымалы мәндерін жаңарту 

Тағайындау амалы орындалғанда, алдымен оң жақ өрнек (яғни, тағайындау белгісінен кейін келетін өрнек) бағаланады. Бұл мән шығарады. Содан кейін сол жақтағы айнымалы жаңа мәнге сілтеме жасайтындай етіп тағайындау жасалады.

Тағайындаудың ең кең тараған түрлерінің бірі - айнымалының жаңа мәні оның ескі мәніне байланысты болатын _жаңарту_. Мына мысалды промптта енгізіп қарап көріңіз.

```python
n = 5
n = 3 * n + 1
```

2-ші жол ```n```-нің ағымдағы мәнін алуды, оны үшке көбейтуді және бірді қосуды және жауапты ```n```-ге тағайындауды білдіреді, осылайша ```n``` жаңа мәнге сілтеме жасайды. Сонымен, жоғарыдағы екі жолды орындағаннан кейін ```n``` 16 бүтін санын көрсетеді/сілтейді.

Ешқашан тағайындалмаған айнымалының мәнін алуға әрекеттенсеңіз, қате пайда болады:

```python
>>> w = x + 1
Traceback (most recent call last):
  File "<interactive input>", line 1, in
NameError: name 'x' is not defined
```

Айнымалы мәнін жаңартпастан бұрын, оны әдетте қарапайым тағайындау арқылы бастапқы мәнге инициализациялау керек (**initialize**):

```python
goals_scored = 0
...
goals_scored = goals_scored + 1
```

⚽

3-ші жол — айнымалыны оған 1 қосу арқылы жаңарту — өте кең таралған. Ол айнымалының өсімі деп аталады ; 1-ді азайту кему деп аталады. Кейде бағдарламашылар айнымалыны соғу туралы да айтады, бұл оны 1-ге арттырумен бірдей.

Line 3 — updating a variable by adding 1 to it — is very common. It is called an **increment** of the variable; subtracting 1 is called a **decrement**. Sometimes programmers also talk about _bumping_ a variable, which means the same as incrementing it by 1.

## 5.3. for циклін қайта қарастыру

Еске сала кетейік, ```for``` циклі тізімдегі әрбір элементті өңдейді. Әрбір элемент өз кезегінде (қайта) цикл айнымалысына тағайындалады және цикл денесі орындалады. Біз бұл мысалды алдыңғы тарауда көрдік:

```python
for f in ["Joe", "Zoe", "Brad", "Angelina", "Zuki", "Thandi", "Paris"]:
    invitation = "Hi " + f + ".  Please come to my party on Saturday!"
    print(invitation)
```

Тізімдегі барлық элементтерді аралау тізімді **айналып өту** (traversing) немесе **өту**(traversal) деп аталады .

Енді сандар тізіміндегі барлық элементтердің қосындысын шығаратын функция жазайық. Мұны алдымен қолмен жасаңыз және нақты қандай қадамдар жасайтыныңызды бөлек-бөлек жазуға тырысыңыз. Сіз қағаз парағында, ойша немесе калькуляторда "сол сәттегі қосынды мәнін" сақтау қажет екенін көресіз. Нәрселерді бір қадамнан келесіге дейін есте сақтау - бұл бағдарламада айнымалылардың болуының себебі: сондықтан "сол сәттегі қосынды мәнін" есте сақтау үшін бізге кейбір айнымалы қажет болады. Ол нөл мәнімен инициализацияланады, содан кейін тізімдегі әрбір элементті айналып өту керек. "Сол сәттегі қосынды мәнге" әрбір элементті қосу арқылы оны жаңартып отырамыз.

```python
def mysum(xs):
    """ Sum all the numbers in the list xs, and return the total. 
        xs тізіміндегі барлық сандардың қосындысын қайтару
    """
    running_total = 0
    for x in xs:
        running_total = running_total + x
    return running_total
    
firstList = [6, 4, 10]
print(mysum(firstList))

print(mysum([1, 2, 3, 4]))
print(mysum([1.25, 2.5, 1.75]))
print(mysum([1, -2, 3]))
print(mysum([ ]))
print(mysum(range(11)))  # 11 is not included in the list.
```

## 5.4. while амалы

```while``` амалының синтаксисі:

```python
while <CONDITION>:
    <STATEMENT>
```

Төменде, ```while``` операторының қолданылуын көрсететін код фрагменті:

```python
n = 6

current_sum = 0
i = 0
while i <= n:
    current_sum += i
    i += 1
print(current_sum)
```

Сіз ```while``` амалын кәдімгі адам тапсырма беріп тұрғандай оқи аласыз (тапсырма ағылшын тілінде берілуде). Қараңыз, ```i``` мәні ```n```-нен кіші немесе тең болғанда, цикл денесін орындауды жалғастыра бер дегенді білдіреді. Дененің ішінде, әр айналымда, ```i``` мәнін өсір. ```i``` ```n```-нен асып өткенде, жинақталған соманы қайтарыңыз. Басқаша айтқанда: \<CONDITION\> ```True``` болғанда, \<STATEMENT\> орындалады. Әрине, бұл мысалды ```sum(range(n + 1))``` ретінде қысқарақ жазуға болады, себебі ```sum``` функциясы бұрыннан бар.

Төменде ```while``` амалының нақты орындалу ағыны үшін анықтама берілген:

- 5-ші жолдағы (```while i <= n:```) шартты бағалаңыз, ол ```False``` немесе ```True``` мәнін береді. 
- Мән ```False``` болса, ```while``` операторынан шығып, келесі операторда орындауды жалғастырыңыз (бұл жағдайда 8-ші жол). ```print```
- Мән ```True``` болса, денедегі әрбір операторды орындаңыз (6-шы және 7-ші жолдар), содан кейін 5-ші жолдағы while операторына оралыңыз.

Дене бөлігі болып ```while``` кілт сөзінің астында шегініс берілген барлық амалдар саналады.

Назар аударыңыз, егер циклды бірінші рет алғанымызда цикл шарты ```False``` болса, циклдің денесіндегі операторлар ешқашан орындалмайды.

Циклдің денесі бір немесе бірнеше айнымалының мәнін өзгертуі керек, осылайша ақыр соңында шарт жалған болып, цикл аяқталады. Әйтпесе, цикл мәңгілік қайталанады, ол шексіз цикл деп аталады (**infinite loop**). 

> Компьютер ғалымдары үшін шексіз көңіл көтеру көзі - сусабындағы (shampoo) «көпірту, шаю, қайталау» жарнамасының шексіз цикл екенін байқау. 😄

Мұндағы жағдайда біз циклдің аяқталатынын дәлелдей аламыз, өйткені ```n``` мәні шекті екенін білеміз, және біз ```i``` мәні цикл арқылы әр жолы өсетінін көреміз, сондықтан ақыр соңында ол ```n```-нен асуы керек. 
  
Кейбір жағдайларда, циклдің аяқталатынын айту оңай емес, тіпті кейбір жағдайларда мүмкін емес.

Бұл жерде сіз байқайтын нәрсе, ```while``` циклі ```for``` цикліне қарағанда бағдарламашы үшін көбірек жұмыс болады. ```while``` циклін пайдаланған кезде циклдың айнымалы мәндерін өзіңіз басқаруыңыз керек: оған бастапқы мән беру, аяқталуын тексеру, содан кейін цикл аяқталуы үшін денеде бір нәрсенің өзгеретіндігіне көз жеткізу. Салыстыру үшін, тура жоғарыдағы қадамды ```for``` циклімен қайталайтын функция:

```python
n = 6

current_sum = 0
for i in range(n+1):
    current_sum += i
print(current_sum)
```

```range``` функциясын шақырудағы аздаған ерекшелікке назар аударыңыз — біз ```n + 1``` деп жазуға тура келді, өйткені ```range``` өзінің тізімін сіз берген соңғы мәнді қоспай жасайды. Бағдарламалау қатесін жасау және оны байқамай қалу әбден мүмкін еді, бірақ сіз осы уақытқа дейін алған білім мұндай жағдайларды ескеруге үйреткен болу керек.

```for``` нұсқасы жазуға оңайырақ болса, неліктен циклдің екі түрі бар? Төмендегі мысал бізге ```while``` циклі беретін артықшылықты көрсетеді.

## 5.5. Collatz 3n + 1 тізбегі 

Көптеген жылдар бойы математиктерді қызықтырған және таңдандырған қарапайым тізбекті қарастырайық. Математиктер әлі де бұл туралы өте қарапайым сұрақтарға жауап таба алмай келеді.

Осы ғажап сандар тізбегін құруға арналған «есептеу ережесі» мынандай: қандай да бір берілген n/саннан бастап, n жұп сан болған кезде n-ді екіге бөлу, тақ болған жағдайда оны үшке көбейтіп содан соң 1 ді қосу арқылы тізбектің келесі санын алу. n саны 1-ге жеткенде санақ аяқталады.

Мына Python функциясы осы алгоритмді жазады:

```python
def seq3np1(n):
    """ n-нен 3n+1 тізбегін басып шығарыңыз, ол 1-ге 
        жеткенде аяқталады.
    """
    while n != 1:
        print(n, end=", ")
        if n % 2 == 0:        # n жұп сан
            n = n // 2
        else:                 # n тақ сан
            n = n * 3 + 1
    print(n, end=".\n")
```

Алдымен 6-шы жолдағы басып шығару функциясында ```end=", "``` қосымша аргументі бар екеніне назар аударыңыз. Бұл басып шығару функциясына жолды аяқтаудың орнына бағдарламашы таңдаған кез келген нәрсені (бұл жағдайда үтір және одан кейін бос орын) басып шығарылатын жолдың соңына жазу керектігін айтады. Осылайша, циклде бір нәрсе басып шығарылған сайын, сандар үтірмен бөлінген бір шығыс жолында басып шығарылады. Цикл аяқталғаннан кейін 11-ші жолдағы ```(n, end=".\n")``` басып шығаруға шақыру n -нің соңғы мәнін, одан кейін нүкте мен жаңа жол таңбасын басып шығарады. (Алдағы тараулардың бірінде жаңа жол таңбасын ```\n``` қарастырамыз).

Бұл циклдің жалғасу шарты ```n != 1```, сондықтан цикл өзінің аяқталу шартына жеткенше жұмысын жалғастырады, яғни ```n == 1```.

Әрбір цикл өткен сайын бағдарлама ```n``` мәнін шығарады, содан кейін оның жұп немесе тақ екенін тексереді. Егер ол жұп болса, ```n``` мәні бүтін бөлу арқылы 2-ге бөлінеді. Егер ол тақ болса, мән ```n * 3 + 1``` мәніне ауыстырылады. Міне, кейбір мысалдар:

```python
>>> seq3np1(3)
3, 10, 5, 16, 8, 4, 2, 1.
>>> seq3np1(19)
19, 58, 29, 88, 44, 22, 11, 34, 17, 52, 26, 13,
                    40, 20, 10, 5, 16, 8, 4, 2, 1.
>>> seq3np1(21)
21, 64, 32, 16, 8, 4, 2, 1.
>>> seq3np1(16)
16, 8, 4, 2, 1.
>>>
```

```n``` кейде артып, кейде азаятындықтан, ```n``` 1-ге қашан жететінін немесе бағдарламаның нақты қашан аяқталатынана айқын дәлел жоқ. ```n```-нің кейбір нақты мәндері үшін біз аяқталуды дәлелдей аламыз. Мысалы, егер бастапқы мән екінің дәрежесі болса, онда ```n``` мәні цикл арқылы 1-ге жеткенше әр уақытта жұп болады. 16-дан басталатын жоғарыдағы соңғы мысал осындай реттілікпен аяқталады.

Аяқталмас бұрын жүзден астам қадамды қажет ететін шағын бастапқы санды таба аласыз ба?

Ерекше мәндерді былай қойғанда, қызықты сұрақты алғаш рет неміс математигі Лотар Коллатц қойды: Collatz болжамы (сонымен қатар _3n + 1 болжамы_ ретінде белгілі ), бұл реттілік n-нің _барлық_ оң мәндері үшін аяқталады. Әзірге оны ешкім не дәлелдеп,не жоққа шығара алған жоқ! (Болжам/conjecture - бұл шындық болуы мүмкін мәлімдеме, бірақ ешкім нақты білмейді.)

"Барлық оң бүтін сандар Collatz ережелерін қолдана отырып, ақырында 1-ге жиналады" деген болжамды дәлелдеу немесе жоққа шығару үшін не қажет болатынын мұқият ойластырыңыз. Жылдам компьютерлердің көмегімен біз әрбір бүтін санды өте үлкен мәндерге дейін сынай алдық және осы уақытқа дейін олардың барлығы ақырында 1-ге жетті. Бірақ кім біледі? Мүмкін әлі тексерілмеген сан бар шығар және ол 1-ге дейін төмендемейтін болса ше?.

Сіз 1-ге жеткенде тоқтамасаңыз, реттілік өзінің циклдік айналымына енетінін байқайсыз: 1, 4, 2, 1, 4, 2, 1, 4 ... Сонымен, бір мүмкіндік - біз әлі таппаған басқа циклдар болуы мүмкін.

Википедияда [Collatz болжамы](https://en.wikipedia.org/wiki/Collatz_conjecture) туралы танымдық мақала бар. Бұл реттілік басқа атаулармен де белгілі (Hailstone тізбегі, Ғажайып сандар және т.б), сондай-ақ заманауи суперкомпьютерлердің көмегімен қаншалықты үлкен сандар тексерілгені жазылған.

```for``` **мен** ```while``` **арасында таңдау**

Егер сіз циклды бастамас бұрын денені орындау қажет болатын ең көп рет санын білсеңіз, ```for``` циклін пайдаланыңыз. Мысалы, элементтер _тізімін_ аралап жатсаңыз, сізге қажет болуы мүмкін цикл итерацияларының ең көп саны «тізімдегі барлық элементтер» екенін білесіз. Немесе 12 еселік кестені басып шығару қажет болса, біз цикл қанша рет орындалуы керек екенін бірден білеміз.

Сондықтан «осы ауа райы үлгісін 1000 цикл үшін қайталау» немесе «осы сөздер тізімін іздеу», «10000-ға дейінгі барлық жай сандарды табу» сияқты кез келген мәселеге ```for``` циклінің жақсы екенін көрсетеді.

Керісінше, қандай да бір шарт орындалғанша кейбір есептеулерді қайталау талап етілсе және бұл 3n + 1 мәселесінде жасағанымыздай, бұл қашан (егер) бітетінін алдын ала есептей алмасаңыз, сізге ```while``` циклі қажет болады.

Біз бірінші жағдайды белгілі итерация деп атаймыз — біз қажет нәрсенің белгілі бір шекараларын алдын ала білеміз. Соңғы жағдай белгісіз итерация деп аталады - бізге қанша итерация қажет болатынын білмейміз - біз тіпті жоғарғы шекті белгілей алмаймыз!

## 5.6. Бағдарламаны қадағалау 

Тиімді компьютерлік бағдарламаларды жазу және бағдарлама орындылуының жақсы концептуалды моделін құру үшін бағдарламашы компьютерлік бағдарламаның орындалуын бақылау қабілетін дамытуы керек. Бақылау - компьютер сияқты ойлауды және үлгілік бағдарламаны іске қосу арқылы орындалу ағынын қадағалауды, барлық айнымалылардың күйін және әрбір нұсқауды орындағаннан кейін бағдарлама жасайтын кез келген нәтижені жазуды қамтиды.

Бұл процесті түсіну үшін алдыңғы бөлімдегі ```seq3np1(3)``` шақыруын бақылап көрейік. Жолдың басында бізде бастапқы мәні 3 болатын ```n``` (параметр) айнымалысы бар. 3 саны 1-ге тең болмағандықтан, ```while``` циклінің денесі орындалады. 3 басып шығарылады және 3 % 2 == 0 бағаланады. Ол ```False``` мәніне бағаланатындықтан, ```else``` тармағы орындалады және 3 * 3 + 1 бағаланады және n мәніне тағайындалады.

Бағдарлама орындалу барысында пайда болатын айнымалы мәніне бір бағана, цикл аяқталғанда шығатын нәтижеге бір бағана жазып, қағазға нәтижелерін түсіріп отырыңыз. Осы уақытқа дейінгі біздің жазба келесідей болады:

```python
n               осы сәтке дейін басып шығарылған мән
--              ------------------------------------
3               3,
10
```

```10 != 1``` мәні ```True``` мәніне бағаланатындықтан, цикл денесі қайтадан орындалады және 10 басып шығарылады. 10 % 2 == 0 ақиқат, сондықтан ```if``` тармағы орындалып, ```n``` 5 болады. Жолдың соңында бізде жазба мынандай болады:

```python
n               осы сәтке дейін басып шығарылған мән
--              ------------------------------------
3               3,
10              3, 10,
5               3, 10, 5,
16              3, 10, 5, 16,
8               3, 10, 5, 16, 8,
4               3, 10, 5, 16, 8, 4,
2               3, 10, 5, 16, 8, 4, 2,
1               3, 10, 5, 16, 8, 4, 2, 1.
```

Бақылау біршама жалықтырғыш және қателіктер болуы мүмкін (сондықтан да біз бұл жұмысты орындауға компьютерлерді бірінші кезекте қолданамыз!), бірақ бұл бағдарламашы үшін маңызды дағды. Бұл ізден біз кодымыздың жұмыс істеу тәсілі туралы көп нәрсені біле аламыз. Мысалы, біз ```n``` саны 2-нің дәрежесіне айналғанда, бағдарлама аяқталуы үшін цикл денесінің ```log2(n)``` орындалуын талап ететінін байқауға болады. Сондай-ақ біз соңғы 1 саны циклдің негізгі бөлігінде шығыс ретінде басып шығарылмайтынын көреміз, сондықтан біз арнайы басып шығару функциясын соңына қоямыз.

Бағдарламаны қадағалау, әрине, код арқылы бір қадаммен өтуге және айнымалы мәндерін тексеру процессіне қатысы бар. Компьютерді **бір қадам** процесстерге пайдалану сіз үшін қателіктерсіз және ыңғайлырақ. Сондай-ақ, сіздің бағдарламаларыңыз күрделене түскен сайын, олар сізді шынымен қызықтыратын кодқа жеткенше миллиондаған қадамдарды орындауы мүмкін, сондықтан қолмен қадағалау мүмкін болмайды. Сізге қажет жерде тоқтау нүктесін орнату мүмкіндігі әлдеқайда күшті. Сондықтан біз сізге бағдарламалау ортасын (бұл жағдайда PyScripter) пайдалануды үйренуге уақыт бөлуге шақырамыз.

Сондай-ақ Python кодының шағын фрагменттерін қадағалауға және түсінуге көмектесетін тамаша визуализация құралдары қолжетімді болады. Google-дан іздестіріп көріңіз.

Біз Chatterbox функцияларын ескерттік, бірақ оларды осы жерде қолдандық. Python тілін көбірек үйренген сайын, оларды басып шығаратын функция орнына, ретті сақтайтын мәндер тізімін жасау жолын көрсетеміз. Бұлай жасау логиканың ортасында осы жағымсыз барлық басып шығару функцияларының болу қажеттілігін жояды және функцияны пайдалырақ етеді.

## 5.7. Сандарды санау 

Келесі код үзіндісі оң бүтін сандағы ондық цифрлардың санын санайды:

```python
n = 3029
count = 0

while n != 0:
    count = count + 1
    n = n // 10
print(count)
```

```print(count)``` шақыру 4 басып шығарады. Бұл функция шақыруының орындалуын бақылап көріңіз (мүмкін PyScripter бағдарламасындағы бір қадамдық функцияны немесе Python визуализаторын немесе кейбір қағазды пайдалану арқылы), оның жұмыс істейтініне сенімді болыңыз.

Бұл функция **counter**(есептегіш) деп аталатын маңызды есептеу үлгісін көрсетеді. ```count``` айнымалысы 0-ге инициализацияланады, содан кейін цикл денесі орындалған сайын көбейтіледі. Цикл біткен кезде, ```count``` цикл денесі неше рет орындалғанын көрсетеді.

Егер біз үлкен санның ішіндегі тек 0 немесе 5 болатын цифраларды ғана санағымыз келсе, санағышты ұлғайтпастан бұрын, шартты мәнді кодтың ішіне жазып алу бізге керек нәтижені береді:

```python
n = 2574301453
count = 0

while n > 0:
    digit = n % 10
    if digit == 0 or digit == 5:
        count = count + 1
    n = n // 10
print(count)
```

Дегенмен, ```n = 0``` жауап ретінде 1-ді басып шығармайды. Себебін түсіндіріңіз. Сіздің ойыңызша, бұл кодтағы қате немесе техникалық сипаттамалардағы қате немесе біздің күтуіміз немесе сынақтар ма?

## 5.8. Қысқартылған тағайындау

Айнымалыны өсіру өте жиі қолданылғандықтан, Python оған қысқартылған синтаксис береді:

```python
>>> count = 0
>>> count += 1
>>> count
1
>>> count += 1
>>> count
2
```

```count += 1``` мынының ```count = count + 1``` аббревиатурасы . Біз бұл ```+=``` операторды «plus-equals» деп айтамыз. Қосымша мән 1 болуы міндетті емес:

```python
>>> n  =  2 
>>> n  +=  5 
>>> n 
7
```

\-= , \*= , \/= , \//= және %= үшін ұқсас аббревиатуралар бар:

```python
>>> n = 2
>>> n *= 5
>>> n
10
>>> n -= 4
>>> n
6
>>> n //= 2
>>> n
3
>>> n %= 2
>>> n
1
```

## 5.9. Анықтама және мета-анотация 

Python оның барлық кірістірілген функциялары мен кітапханалары үшін кең құжаттамамен келеді. Әртүрлі жүйелерде бұл анықтамаға қол жеткізудің әртүрлі жолдары бар. PyScripter бағдарламасында Help мәзірінің элементін басып, Python Manuals (нұсқаулықтары) тармағын таңдаңыз. Содан кейін кірістірілген функция (Built-in Types) ```range``` анықтаманы іздеңіз. Сіз келесідей нәрсені аласыз:

![Manuals](https://user-images.githubusercontent.com/84173441/173568307-4563330b-a999-471c-bc7c-1e090251e4aa.JPG)

Сондай-ақ веб-парақшада құжаттаманы көрсеңіз болады [docs.python.org/range](https://docs.python.org/3/library/stdtypes.html#typesseq-range)

Аргументтерді сипаттаудағы төртбұрышты жақшаларға назар аударыңыз. Бұл Python синтаксисін сипаттайтын, бірақ оның бөлігі емес, **мета-нотацияның** мысалдары. Бұл құжаттамадағы төртбұрышты жақшалар аргументтің міндетті емес екенін білдіреді — бағдарламашы оны өткізіп жіберуі мүмкін. Бұл анықтаманың бірінші жолы бізге айтатын нәрсе: ```range```-де әрқашан stop аргументі болуы керек, бірақ оның қосымша start(бастау) аргументі болуы мүмкін (ол бар болса, үтірден кейін қойылуы керек) және оның қосымша step(қадам) аргументі де болуы мүмкін, бар болса, алдына үтір қойылады.

Анықтамадағы мысалдар ```range```-де 1, 2 немесе 3 аргумент болуы мүмкін екенін көрсетеді. Тізім кез келген бастапқы мәннен басталып, 1-ден басқа өсіру қадамымен жоғары немесе төмен жүруі мүмкін. Мұндағы құжаттама сонымен қатар аргументтер бүтін сандар болуы керек екенін айтады.

Сіз жиі кездесетін басқа мета-нотациялар bold (қалың) және italics (курсивтерді) пайдалану болып табылады. Қалың бұл Python кодыңызға дәл сол күйінде терілген таңбалауыштар — кілт сөздер немесе таңбалар, ал курсив жағдайында «осы типті нәрсе» дегенді білдіреді. Мына синтаксистік сипаттама:

**for** _variable_ **in** _list_:

Python кодын жазған кезде кез келген заңды айнымалыны және кез келген заңды тізімді алмастыра алатыныңызды білдіреді.

Мына төмендегі басып шығару функциясының (жеңілдетілген) сипаттамасы мета-анотацияның тағы бір мысалын көрсетеді, онда эллипстер ( ... ) ```print``` функциясында үтірмен бөлінген (тіпті нөл) кез келген обьект саны заңды болатындығын білдіреді:

**print**(**\[** object, ... **]**)

Мета-нотация бізге қандай да бір синтаксистің немесе фитчаның үлгісін сипаттаудың қысқа және түсінікті әдісін береді.

## 5.10. Кестелер 

Циклдердің тағы бір жақсы қолданыс табатын қасиеті - кестелерді жасау. Компьютерлер оңай қол жетімді болғанға дейін адамдар логарифмдерді, синустар мен косинустарды және басқа да математикалық функцияларды қолмен есептеуге мәжбүр болды. Мұны жеңілдету үшін математика кітаптарында осы функциялардың мәндері тізімделген ұзын кестелер жазылатын. Кестелерді жасау баяу және қызықсыз болды және олар қателерге толы болды.

Сахнада компьютерлер пайда болған кезде, алғашқы реакциялардың бірі: «Бұл керемет! Біз кестелерді жасау үшін компьютерлерді пайдалана аламыз, сондықтан қателер болмайды». Бұл шындық болды және тіпті алғашқы болжамнан да асып түсті. Көп ұзамай компьютерлер мен калькуляторлардың кең таралғаны сонша, кестелер керек болмай қалды. Деп айтсақ болады. 

Кейбір операциялар үшін компьютерлер біз берген кестеден жуықталған мәнді алады, содан кейін жуықтауды барынша жақсарту үшін есептеулерді орындайды. Кейбір жағдайларда негізгі кестелерде қателер болды, соның ішіндегі [ең танымал](https://en-m-wikipedia-org.translate.goog/wiki/Pentium_FDIV_bug?_x_tr_sl=en&_x_tr_tl=kk&_x_tr_hl=en&_x_tr_pto=wapp) [қате кесте](https://en.wikipedia.org/wiki/Pentium_FDIV_bug) Intel Pentium процессорының чипі өзгермелі нүктелерді бөлуді орындау үшін пайдаланғаны.

Log-жазу кестесі бұрынғыдай пайдалы болмаса да, ол әлі де итерацияны көрсетуге жақсы мысал. Келесі мысал 0-ден 12-ге дейін сандарды бір бағанада жазады және жанына сол сан 2-нің дәрежесі ретінде қандай екенін көрсететі:

```python
for x in range(13):   # Generate numbers 0 to 12
    print(x, "\t", 2**x)
```

```"\t"``` жолы **tab** таңбасын білдіреді . ```"\t"``` ішіндегі кері қиғаш сызық таңба ```\``` **escape sequence** бастамасын көрсетеді. Escape sequence - tab және жаңа жолдар сияқты көрінбейтін таңбаларды көрсету үшін пайдаланылады. ```\n``` тізбегі **жаңа жол**-ды білдіреді .

Escape sequence (шығу реті) тіркестің кез келген жерінде пайда болуы мүмкін; бұл мысалда tab шығу реті тіркестегі жалғыз нәрсе. Тіркестегі кері қиғаш сызықты қалай бейнелейсіз деп ойлайсыз?

Таңбалар мен жолдар экранда көрсетілген кезде **курсор (cursor)** деп аталатын көрінбейтін маркер келесі таңбаның қайда баратынын қадағалап отырады. Басып шығару функциясынан кейін курсор әдетте келесі жолдың басына өтеді.

tab таңбасы курсорды tab тоқтатқыштың біріне жеткенше оңға жылжытады. Tab алдыңғы бағдарламаның шығысындағыдай мәтіннің бағандарын ретке келтіру үшін пайдалы:

```python
0       1
1       2
2       4
3       8
4       16
5       32
6       64
7       128
8       256
9       512
10      1024
11      2048
12      4096
```

Бағандар арасында tab таңбасы болғандықтан, екінші бағанның орналасуы бірінші бағандағы цифрлар санына байланысты емес.

## 5.11. Екі өлшемді кестелер 

Екі өлшемді кесте – жол мен бағанның қиылысындағы мәнді оқитын кесте. Көбейту кестесі жақсы мысал болып табылады. 1-ден 6-ға дейінгі мәндер үшін көбейту кестесін басып шығарғыңыз келеді делік.

Бұл үшін жақсы бастама - i-дың 2-ге көбейтіндісін бір жолда басып шығаратын циклды жазу:

```python
for i in range(1, 7):
    print(2 * i, end="   ")
print()
```

Мұнда біз ```range``` функциясын қолдандық, бірақ оның реттілігін 1-ден бастадық. Цикл орындалып жатқанда, i мәні 1-ден 6-ға дейін өзгереді. Осы аралықтың барлық элементтері i-ге тағайындайындалып болғанда, цикл аяқталады. Циклдің әрбір айналымында ол 2 * i мәнін, одан кейін үш бос орынды шығарады.

Тағы да, ```print``` функциясындағы қосымша ```end="    "``` аргументі жаңа жолды болдырмайды және оның орнына үш бос орынды пайдаланады. Цикл аяқталғаннан кейін   3-ші жолдағы ```print```-ке шақыру ағымдағы жолды аяқтайды және жаңа жолды бастайды.

Бағдарламаның нәтижесі:

```python
2       4       6      8      10       12
```

Әзірше бәрі жақсы. Келесі қадам - инкапсуляциялау және жалпылау (**encapsulation and generalization**). Біз оны келесі тарауда жалғастырамыз.

## 5.12 break амалы

**break** амалы ол қолданылған цикл денесінен _бірден шығу_ үшін жасалады. Одан кейін орындалатын амал цикл денесінен кейін орналасқан амал:

```python
for i in [12, 16, 17, 24, 29]:
    if i % 2 == 1: # егер сан тақ болса 
        break # ... цикл денесінен бірден шық
    print(i)
print("done")
```

Шығарылатын нәтиже:

```python
12
16
done
```

**pre-test цикл — стандартты цикл әрекеті**

```for``` және ```while```, цикл денесіндегі амалдардың ешқайсысын орындамас бұрын шартты тестілеп алады. Сондықтан олар **pre-test** циклдері деп аталады, себебі тест дене амалдарына дейін (pre) жасалады. ```break``` және ```return``` осы стандартты әрекетті өзгертуге мүмкіндік беретін құралдар. 

![breakReturn](https://user-images.githubusercontent.com/84173441/173805864-6c16707e-5f40-43ca-aaac-ab2146241c1c.JPG)

## 5.16 Циклдің басқа да түрлері

Кейде біз бастапқыда немесе соңында емес, дененің ортасында шығу сынағы бар **middle-test** циклін жасағымыз келеді. Немесе шығу сынағын денедегі соңғы нәрсе ретінде қоятын **post-test** циклін. Басқа тілдерде осы әртүрлі циклдерге арналған әртүрлі синтаксис пен кілт сөздер бар, бірақ Python жұмысты орындау үшін ```while``` және ```if``` ```<CONDITION>:``` ```break``` синтаксисын пайдаланады.

Бір мысал - пайдаланушы сандарды енгізіп тұрады және компьютер оларды қосып отырады. Басқа енгізілетін мән жоқ екенін көрсету үшін пайдаланушы арнайы мәнді, көбінесе -1 мәнін немесе бос жолды енгізеді. Бұл ортадан шығу (middle-exit) циклінің үлгісін қажет етеді: келесі нөмірді енгізіңіз, содан кейін шығу керек пе, жоқ па, әлде нөмірді өңдеңіз:

**middle-test** циклінің блок-схемасы:

![middleTest](https://user-images.githubusercontent.com/84173441/173808059-b1d0d65b-5418-4e44-886c-e0e2416b3c9b.JPG)

```python
total = 0
while True:
    response = input("Келесі санды енгізіңіз. (Аяқтау үшін бос орын, -1 не q)")
    if response == "" or response == "-1" or response == "q":
        break
    total += int(response)
    print(total)
print("Сіз енгізген сандардың қосындысы ", total)
```

Бұл ортадан шығу (middle-exit) циклінің блок-схемасына сәйкес келетініне көз жеткізіңіз: 3-ші жол кейбір пайдалы есептеулер жасайды, 4-ші және 5-ші жолдар циклден шыға алады, ал егер 4-і,5-і жолда циклден шығып кетпесек 6-шы жол келесі итерация басталғанға дейін тіпті пайдалы жұмыс істейді/есептеулер жасайды.

```while bool-exprpression:``` қайта итерациялау керектігін анықтау үшін логикалық өрнекті пайдаланады. ```True``` - бұл тривиальды логикалық өрнек, сондықтан ```while True```: _цикл денесін әрқашан қайта жасау_ дегенді білдіреді. Бұл тілдік _идиома_ — көптеген бағдарламашылар бірден танитын конвенция. 2-ші жолдағы өрнек ешқашан циклды тоқтатпайтындықтан (бұл ылғи ```True``` болатын жалған сынақ) бағдарламашы цикл денесін басқа жерде, басқа жолмен (яғни осы үлгідегі 4 және 5-жолдарда) үзуді (немесе қайтаруды) ұйымдастыруы керек. Ақылды компилятор немесе интерпретатор 2-ші жолдың жалған сынақ екенін түсінеді, ол әрқашан сәтті болуы керек, сондықтан ол тіпті сынақ жасамайды және біздің блок-схема ешқашан циклдің жоғарғы жағына гауһар пішінді манекен сынақ қорапшасын қоймайды! (PyScripter-де)

Сол сияқты, ```if condition:  break```-ті цикл денесінің соңына жай ғана жылжыту арқылы: біз сынақтан кейінгі цикл (post-test loop) үшін үлгі жасаймыз. Post-test циклдер цикл денесі әрқашан кем дегенде бір рет орындалатынына сенімді болғыңыз келгенде қолданылады (өйткені бірінші сынақ тек бірінші цикл денесінің орындалуының соңында болады). Бұл пайдалы, мысалы, егер біз пайдаланушыға қарсы интерактивті ойын ойнағымыз келсе — біз әрқашан кем дегенде бір ойын ойнағымыз келеді:

```python
while True:
    play_the_game_once()
    response = input("Play again? (yes or no)")
    if response != "yes":
        break
print("Goodbye!")
```

---

Кеңес: **Шығу тестінің қайда болғанын қалайтыныңызды ойлаңыз**

Бір нәрсені қайталау үшін цикл қажет екенін түсінгеннен кейін, оның аяқталу шарты туралы ойланыңыз — мен итерацияны қашан тоқтатқым келеді? Содан кейін бірінші (және әрбір басқа) итерацияны бастамас бұрын немесе бірінші (және әрбір басқа) итерацияның соңында немесе әрбір итерацияның ортасында сынақты орындау қажет пе екенін анықтаңыз. Пайдаланушыдан енгізуді немесе файлдардан оқуды қажет ететін интерактивті бағдарламалар өңдеуге қосымша деректер жоқ екені анық болғанда немесе пайдаланушы оны қаламайтыны белгілі болғанда, итерацияның ортасында немесе соңында циклдерден шығуы керек. енді біздің ойынды ойна.

---

## 5.17 Мысал 

Келесі бағдарлама қарапайым болжау ойынын жүзеге асырады:

```python
import random                   # We cover random numbers in the
rng = random.Random()           #  modules chapter, so peek ahead.
number = rng.randrange(1, 1000) # Get random number between [1 and 1000).

guesses = 0
msg = ""

while True:
    guess = int(input(msg + "\nGuess my number between 1 and 1000: "))
    guesses += 1
    if guess > number:
        msg += str(guess) + " is too high.\n"
    elif guess < number:
        msg += str(guess) + " is too low.\n"
    else:
        break

input("\n\nGreat, you got it in {0} guesses!\n\n".format(guesses))
```

Бұл бағдарлама [трихотомияның](https://en-m-wikipedia-org.translate.goog/wiki/Law_of_trichotomy?_x_tr_sl=en&_x_tr_tl=kk&_x_tr_hl=en&_x_tr_pto=wapp) математикалық заңын пайдаланады (а және b нақты сандар берілген болса, осы үшеуінің дәл біреуі дұрыс болуы керек: a > b, a < b немесе a == b).

18-ші жолда ```input``` енгізу функциясына шақыру бар, бірақ біз нәтижемен ештеңе жасамаймыз, тіпті оны айнымалыға тағайындамаймыз. Бұл Python тілінде заңды. Мұнда ол енгізу диалогтық терезесін ашу және бағдарлама аяқталмай тұрып пайдаланушының жауап беруін күту жұмысын жасайды. Бағдарламашылар терезені ашық ұстау үшін скрипттің соңында кейбір қосымша енгізу функциясын жиі пайдаланады.

Сондай-ақ 6, 12 және 14-ші жолдарда ```message``` айнымалысының, бастапқыда бос тіркестің пайдаланылуына назар аударыңыз. Әрбір цикл арқылы біз көрсетілетін хабарды кеңейтеміз: бұл бағдарламаның кері байланысын дәл сол келесі болжамды сұрайтын жерде көрсетуге мүмкіндік береді.


 ## 5.18 continue амалы
 
```continue``` - ағымдағы итерация үшін цикл денесінің қалған бөлігін өңдеуді дереу өткізіп жіберуге әкелетін басқару ағынының амалы. Бірақ цикл өзінің қалған итерациялары үшін жұмысты жалғастырады:

```python
for i in [12, 16, 17, 24, 29, 30]:
    if i % 2 == 1:      # Егер сан тақ болса
       continue         # ... оны өңдеме
    print(i)
print("done")
```

Бұл басып шығарады:

```python
12
16
24
30
done
```

## 5.19 Жұпталған деректер 

Біз Python-да есімдер тізімі мен сандар тізімін көрдік. Ал қазір алдағы тақырыптардың үзіндісін ерте қараймыз және деректерімізді ұсынудың жетілдірілген әдісін көрсетеміз. Python-да жұп заттарды жасау үшін оларды жақшаға ала салсақ болғаны, мысалы:

```python
year_born = ("Paris Hilton", 1981)
```

Біз бірнеше жұптарды _жұптар тізіміне_ енгізе аламыз:

```python
celebs = [("Brad Pitt", 1963), ("Jack Nicholson", 1937),
                                ("Justin Bieber", 1994)]
```

Міне, осындай құрылымдық деректермен жасауға болатын нәрселердің жылдам үлгісі. Алдымен, барлық атақтыларды басып шығарыңыз:

```python
print(celebs)
print(len(celebs))
```

```python
[("Brad Pitt", 1963), ("Jack Nicholson", 1937), ("Justin Bieber", 1994)]
3
```

```celebs``` (атақтылар) тізімінде барлығы 3 элемент бар екенін ескеріңіз, олардың әрқайсысы жұп.

Енді біз 1980 жылға дейін туған атақты адамдардың есімдерін басып шығарамыз:

```python
for (name, year) in celebs:
   if year < 1980:
        print(name)
```

```python
Brad Pitt
Jack Nicholson
```

Бұл, біз әлі ```for``` циклінде көрмеген нәрсені көрсетеді: бір циклды басқару айнымалы мәнін пайдаланудың орнына, айнымалы атауларының жұбын қолдандық  (```name```, ```year```). Цикл үш рет орындалады — тізімдегі әрбір жұп үшін бір реттен және әр итерацияда екі айнымалыға өңделетін деректер жұбынан мәндер тағайындалады.

## 5.22. Кірістірілген деректерге арналған кірістірілген циклдар 

Енді біз құрылымдық деректердің одан да қызықты тізімін ойлап табамыз. Бұл жағдайда бізде студенттердің тізімі бар. Әрбір студенттің аты-жөні бар, ол олар жазылған пәндердің басқа тізімімен жұптастырылған:

```python
students = [
    ("John", ["CompSci", "Physics"]),
    ("Vusi", ["Maths", "CompSci", "Stats"]),
    ("Jess", ["CompSci", "Accounting", "Economics", "Management"]),
    ("Sarah", ["InfSys", "Accounting", "Economics", "CommLaw"]),
    ("Zuki", ["Sociology", "Economics", "Law", "Stats", "Music"])]
```

Мұнда біз ```students``` айнымалысына бес элементтің тізімін тағайындадық. Әрбір студенттің аты-жөнін және олар жазылған пәндер санын басып шығарайық:

```python
# Барлық студенттерді курстарының санымен басып шығарыңыз.
for (name, subjects) in students:
    print(name, len(subjects), "курсқа қатысады")
```

Python келесі нәтижемен жақсы жауап береді:

```python
John 2 курсқа қатысады
Vusi 3 курсқа қатысады
Jess 4 курсқа қатысады
Sarah 4 курсқа қатысады
Zuki 5 курсқа қатысады
```

Енді біз қанша студент CompSci курсына қатысып жатқанын сұрағымыз келеді. Бұл жерде ```counter``` қажет және әрбір студент үшін әрбір пәнді кезекпен тексеретін екінші цикл қажет:

```python
# қанша студент CompSci курсына қатысып жатқанын санау
counter = 0
for (name, subjects) in students:
    for s in subjects:                 # Кірістірілген цикл!
        if s == "CompSci":
           counter += 1

print("ComSci-ді алатын студенттердің саны", counter)
```

```python
ComSci-ді алатын студенттердің саны 3
```

Сіз өзіңізді қызықтыратын деректеріңіздің тізімін жазып көруіңіз керек — әрқайсысында ән атауларының тізімі бар CD дискілеріңіздің тізімі немесе фильм атауларының тізімі, олардың әрқайсысында фильмде рөльді сомдаған кино жұлдыздарының тізімі болуы мүмкін. Содан кейін сіз «Анджелина Джоли қандай фильмдерде басты рөлді сомдаған?» сияқты сұрақтар қоя аласыз.

## 5.23. Квадрат түбірді табудың Ньютон әдісі

Сандарды есептеуде жуықталған жауаптан бастап, ары қарай қайта-қайта есептеу арқылы жауапты жақсартатын бағдарламаларда циклдер жиі қолданылады.

Мысалы, бізде калькуляторлар немесе компьютерлер болғанға дейін адамдар квадрат түбірлерді қолмен есептеу керек болды. Ньютон әсіресе жақсы әдісті пайдаланды (бұл әдіс көп жылдар бұрын белгілі болғаны туралы кейбір дәлелдер бар). ```n``` санының квадрат түбірін білгіңіз келеді делік. Кез келген жуықтаудан бастасаңыз, келесі формуламен жақсырақ жуықтауды (нақты жауапқа жақынырақ) есептей аласыз:

```python
better = (approximation + n/approximation) / 2
```

Калькуляторды пайдаланып бұл есептеуді бірнеше рет қайталаңыз. Әрбір итерация сіздің бағалауыңызды неге жақындататынын көре аласыз ба? Осы көрсетілген алгоритмнің таңғажайып қасиеттерінің бірі - оның дәл жауапқа қаншалықты тез жақындауы - бұл қолмен орындағанда үлкен артықшылық.

Циклды пайдаланып және біздің нәтиже алдыңғы "жақсырақ" нәтижеге барынша жақын болғанша қайталау арқылы квадрат түбірді есептеу функциясын жаза аламыз. (Шын мәнінде, калькулятор квадрат түбірлерді осылай табады — оның формуласы мен әдісі сәл басқаша болуы мүмкін, бірақ ол өз болжамдарын қайта-қайта жақсартуға негізделген.)

Бұл _indefinite_ (белгісіз) итерация мәселесінің мысалы: біз болжамымызды қанша рет жақсартқымыз келетінін алдын ала болжай алмаймыз — біз жай ғана дұрыс жауапқа жақындай түсуді қалаймыз. Біздің циклды тоқтату шарты біздің ескі болжамымыз бен жақсартылған болжамымыз бір-біріне «жеткілікті жақын» болғанда орын алады.

Ең дұрысы, біз тоқтаған кезде ескі және жаңа болжамның бір-біріне дәл сәйкес келуін қалаймыз. Бірақ дәл теңдік - нақты сандар қатысқан кезде компьютерлік арифметикадағы қиын түсінік. Нақты сандар абсолютті дәл берілмейтіндіктен (ақырында, pi немесе екінің квадрат түбірі сияқты санның ондық таңбаларының шексіз саны бар, себебі ол иррационалды), біз циклды тоқтату сынамасын "_бұл а b-ге жеткілікті жақын ба?_" дейміз. Бұл тоқтату шартын келесідей кодтауға болады:

```python
if abs(a-b) < 0.001:  # Одан да дәлірек болу үшін санды кішірейте түсеміз
      break
```

Назар аударыңыз, біз ```a``` және ```b``` арасындағы айырмашылықтың абсолютті мәнін аламыз!

Бұл мәселе сонымен қатар ортаңғы шығу циклі (middle-exit) орынды болған кез үшін жақсы мысал болып табылады:

```python
n = 8
threshold = 0.001
approximation = n/2 # Start with some or other guess at the answer

    while True:
        better = (approximation + n/approximation) / 2
        if abs(approximation - better) < threshold:
            print(better)
            break
        approximation = better
```

Циклді тоқтату шартын өзгерту арқылы жуықтау шамасын жақсарта аласыз ба, байқап көріңіз. Жиырма бес санының түбірін табу (sqrt(25)) қанша итерация қажет еткенін (0.001 дәлдік үшін) қолмен жазып, калькуляторды пайдаланып есептеңіз.

## 5.24 Алгоритмдер 

Ньютон әдісі **алгоритмнің** мысалы болып табылады: бұл есептер категориясын шешуге арналған механикалық процесс (бұл жағдайда квадрат түбірлерді есептеу).

Кейбір білім түрлері алгоритмдік емес. Мысалы, тарихи күндерді немесе көбейту кестесін жаттап алу сияқты нақты шешімдер есте сақтауды қамтиды.

Бірақ сіз тасымалдау арқылы қосу, қарыз алу арқылы азайту және ұзақ бөлу үшін үйренген әдістердің барлығы алгоритмдер. Немесе сіз судоку басқатырғыштарын шешуге құмар болсаңыз, сізде әрқашан орындайтын белгілі бір қадамдар жиынтығы болуы мүмкін.

Алгоритмдердің ерекшеліктерінің бірі - оларды орындау үшін ешқандай интеллект қажет емес. Олар қарапайым ережелер жиынтығына сәйкес әрбір қадам соңғысын жалғастыратын механикалық процестер. Және олар бір ғана мәселені емес, жалпы класты немесе есептер санатын шешуге арналған.

Күрделі есептерді қадамдық алгоритмдік процестер арқылы шешуге болатынын түсіну (және біз үшін осы алгоритмдерді орындау технологиясының болуы) орасан зор пайда әкелген басты жетістіктердің бірі болып табылады. Алгоритмді орындау қызықсыз және интеллектті қажет етпесе де, алгоритмдік немесе есептеуіш ойлау, яғни алгоритмдер мен автоматтандыруды мәселелерді шешудің негізі ретінде пайдалану — біздің қоғамды жылдам өзгертеді. Кейбіреулер алгоритмдік ойлау мен процестерге қарай бұл ауысу біздің қоғамға баспа станогының өнертабысынан гөрі көбірек әсер етеді деп мәлімдейді. Алгоритмдерді жобалау процесі қызықты, интеллектуалды күрделі және біз бағдарламалау деп атайтын нәрсенің орталық бөлігі болып табылады.

Адамдардың табиғи түрде, қиындықсыз немесе саналы ойланбастан жасайтын кейбір нәрселерін алгоритмдік түрде көрсету ең қиын. Табиғи тілді түсіну жақсы мысал. Біз мұны бәріміз жасаймыз, бірақ әзірге ешкім мұны қалай жасайтынымызды түсіндіре алмады, кем дегенде қадамдық механикалық алгоритм түрінде емес.

# Кейбір кеңестер, айла-амалдар және жиі кездесетін қателер

Бұл Python бағдарламасының бастаушыларына пайдалы болуы мүмкін идеялардың, кеңестердің және жиі кездесетін қателердің шағын жиынтықтары.

## 5.2.1 Логика және басқару ағыны проблемалары

Біз жиі тізімдегі кез келген элемент үшін қандай да бір шарт орындалатынын білгіміз келеді, мысалы: «Тізімде тақ сандар бар ма?» Бұл жиі кездесетін қате:

```python
numbers = [10, 5, 24, 8, 6]

# Қате бар нұсқа
for number in numbers:
    if number % 2 == 1:
        print(True)
        break
    else:
        print(False)
        break    
```

Сіз осы жердегі қатені көріп тұрсыз ба? ```break``` амалы орындалған сәтте біз циклден шығып кетеміз. Бұл жерде "мен тақ санды тапсам" ```True``` "мәнін қайтарамын" логикасы дұрыс. Алайда, біз бір ғана элементті қарап ```False``` деп қайтара алмаймыз - біз барлық элементті қарап шықсақ және оның ешбірі тақ болмаса ```False``` деп қайтара аламыз. Сондықтан 10-шы жол (break жазылған) мұнда болмауы керек, ал 8-ші және 9-ші жолдар циклдің сыртында болуы керек. Міне дұрыс нұсқасы:

```python
numbers = [10, 5, 24, 8, 9]
for number in numbers:
    if number % 2 == 1:
        print(True)
        break
else:
    print(False)
```

```break``` амалын қолданып "қысқа тұйықталу" стильіндегі циклден шығып кету тәслін алдағы бөлімдерде қарастырамыз. 

---

**Жоғарыдағы мысалда for ... else конструкциясы қолданылғанына назар аударыңыз**

```else``` амалы цикльде ешқандай ```break``` үзу амалы болмай өткен жағдайда орындалады. Ол жоғарыдағы мысал үшін өте қолайлы. Және тағы бір назар аударатын нәрсе, бұл мысалда ```else``` амалы цикл ішінде орындалатын ```for``` амалына қатысты емес. 

---

Жоғарыдағы мысал мына төмендегі мысалдан қарағанда тиімдірек. 

```python
numbers = [10, 5, 24, 8, 6]
count = 0
for number in numbers:
    if number % 2 == 1:
        count += 1     # Тақ сандарды сана
    if count > 0:
        print(True)
    else:
        print(False)
```

Бұл мысал да дұрыс жұмыс жасағанмен оның өнімділігінің кемшілігі - ол нәтижені ерте білсе де, бүкіл тізімді айналып өтеді.

---

Кеңес: Циклдің қайтару шарттары туралы ойланыңыз

Маған барлық жағдайда барлық элементтерді қарау керек пе? Мен төте жолды таңдап, ертерек шығуға болады ма? Қандай жағдайларда? Тізімдегі барлық элементтерді қашан тексеруім керек?

---

6-шы және 9-шы жолдағы код та аздап туралана алады. ```count > 0``` өрнегінің өзі Boolean мән болып табылады, ```True``` немесе ```False``` (оның мәні ```True``` немесе ```False``` болып бағаланады деп айта аламыз). Осы ```True/False``` мәні тікелей ```print``` амалында қолданыла алады. Сондықтан жоғарыдағы кодты былай жаза аламыз: 

```python
numbers = [10, 5, 24, 8, 6]
count = 0
for number in numbers: 
    if number % 2 == 1:
        count += 1          # тақ сандарды сана
print(count > 0)            # Аха! Boolean өрнектері тек қана if амалында қолданылмайтынын 
                            # білетін программист
```

Бұл код қатаңырақ болса да, ол бірінші тақ сан табыла салысымен қысқа тұйықталуды қайтарған код сияқты жақсы емес.

Тіпті қысқарақ:

```python
numbers = [10, 5, 24, 8, 6]
count = 0
for number in numbers: 
    count += number % 2 == 1
print(count > 0)            # Аха! Boolean өрнектері тек қана if амалында қолданылмайтынын 
                            # білетін программист
```

---

Кеңес: Логикалық мәндерді пайдалануды жалпылаңыз (Tip: Generalize your use of Booleans)

Бағдарламашылар ```if is_prime(n) == True:``` деп жазбайды, оның орнына былай жазады ```if is_prime(n):```. Boolean мәндер туралы жалпылама ойлап үйреніңіз, тек ```if``` және ```while``` амалдарына байланыстырып емес. Арифметикалық өрнектер сияқты олардың да өзіндік операторлары (```and```, ```or```, ```not```) мен мәндері (```True```, ```False```) бар. Boolean қолдануды жетілдіру үшін тамаша ресурс [wikibooks/Python_Tutorial](https://en.wikibooks.org/wiki/Non-Programmer%27s_Tutorial_for_Python_3/Boolean_Expressions)

---

Жаттығу уақыты: 

- Жоғарыдағы мысалда _барлық_ сандар тақ болса, кодты ```True``` басылып шығатындай өзгерте аласыз ба? "Қысқа тұйықталу" әдісін әлі де қолдану мүмкін бе?
- Кем дегенде тізімдегі үш сан тақ болғанда ```True``` басып шығаратындай өзгерте аласыз ба? Үшінші тақ сан табылған сәтте "қысқа тұйықталу" жасау керек - қажет болмаған жағдайда барлық тізімді айналып шығудың қажеті жоқ

## 5.2.2 Цикл және тізімдер 

Компьютерлер пайдалы, өйткені олар есептеулерді дәл және жылдам қайталай алады. Осылайша, циклдар сіз кезіккен барлық дерлік бағдарламалардың негізгі мүмкіндігі болады.

---

Кеңес: қажетсіз тізімдерді жасамаңыз
Деректерді кейінірек есептеу үшін сақтау қажет болса, тізімдер пайдалы. Бірақ егер сізге тізімдер қажет болмаса, оларды жасамағаныңыз жөн.

---

Міне, екеуі де он миллионға дейінгі кездейсоқ сандарды жасайтын және сандардың қосындысын қайтаратын екі функция. Екеуі жұмыс істейді.

```python
import random
joe = random.Random()

# 1-ші нұсқа
# Кездейсоқ сандардың тізімін жаса, содан соң олардың қосындысын шығар
numbers = []
for _ in range(10000000):
    num = joe.randrange(1000)       # Кездейсоқ бір санды жаса
    numbers.append(num)                 # Оны біздің тізімге сақта, келесі кітап бөлімінде қарастыр

tot = sum(numbers)
print(tot)

# 2-ші нұсқа
# Кездейсоқ сандардың қосындысын оларды жасау барысында шығар
tot = 0
for _ in range(10000000):
    num = joe.randrange(1000)
    tot += num
print(tot)
```

2-ші код нұсқасын таңдау неліктен дұрыс шешім деп ойлайсыз? (Hint: Performance Monitor сияқты компьютердегі ресурстың қолдану пайызын көрсететін қосымша жүктеп, жедел жадтың қолданылуын қараңыз. Күрт жедел жад қатесі шыққанша тізімді қанша үлкейте аласыз?)

Сол сияқты, файлдармен жұмыс істегенде, бізде жиі файл мазмұнын бір жол тіркесі ретінде оқу мүмкіндігі бар немесе біз бір жолды бір уақытта оқып, әрбір жолды оқу барысында өңдей аламыз. Бір уақытта бір жолды оқу – бұл дәстүрлі және қауіпсіз әдіс – файл қаншалықты үлкен болса да, ыңғайлы жұмыс істей аласыз. (Және, әрине, файлдарды өңдеудің бұл режимі ескі күндерде компьютер жадылары әлдеқайда аз болған кезде өте маңызды болды.) Бірақ сіз бір уақытта бүкіл файлды кейде ыңғайлырақ деп таба аласыз!

## 5.25. Глоссарий

**алгоритм**
Есептер жиынтығын, проблемалар категориясын шешудің қадамдық процесі.

**body /дене**
Цикл ішіндегі амалдар.
  
**тоқтау нүктесі / breakpoint**
Бағдарламаның айнымалыларының күйін тексеруге мүмкіндік беретін бағдарламаның орындалуы кідіртілетін (немесе үзілетін) бағдарлама кодындағы орын немесе амалдарды бір қадамдап жеке орындау.

**соққы / bump**
Бағдарламашы сленгі. Өсіру сөзінің синонимі.

**continue амалы**
Циклдің ағымдағы итерациясының қалған бөлігін өткізіп жіберуге әкелетін амал. Орындау ағыны циклдің жоғарғы жағына қайтады, шартты бағалайды және бұл дұрыс болса, циклдің келесі итерациясы басталады.

**counter / есептегіш**
Бір нәрсені санау үшін қолданылатын айнымалы, әдетте нөлге инициализацияланады және циклдің негізгі бөлігінде өсіріледі.

**курсор / cursor**
Келесі таңбаның қай жерде басылатынын қадағалайтын көрінбейтін маркер.

**кеміту / decrement**
1-ге кеміту.

**шекті итерация**
Дененің орындалу санының жоғарғы шегі бар цикл. Белгілі итерация әдетте for циклі ретінде жақсы кодталады.

**development plan**
Бағдарламаны әзірлеу процесі.

**инкапсуляциялау / encapsulate**
Үлкен күрделі бағдарламаны құрамдас бөліктерге бөлу (мысалы, функциялар) және құрамдастарды бір-бірінен оқшаулау (мысалы, жергілікті айнымалы мәндерді пайдалану арқылы).

**escape sequence / құтылу реті**
Басып шығарылмайтын таңбаны белгілеу үшін пайдаланылатын таңба \\.

**generalize /жалпылау**
Қажетсіз ерекше нәрсені (тұрақты мән сияқты) сәйкес жалпы нәрсемен (айнымалы немесе параметр сияқты) ауыстыру. Жалпылау кодты әмбебап етеді, қайта пайдалану мүмкіндігін жоғарылатады және кейде жазуды жеңілдетеді.

**increment / арттыру**
Зат есім ретінде де, етістік ретінде де өсім 1-ге көбейтуді білдіреді.

**шексіз цикл / infinite loop**
Аяқтау шарты ешқашан орындалмайтын цикл.

**белгісіз итерация / indefinite iteration**
Біз қандай да бір шарт орындалғанша жалғастыруымыз керек цикл. Бұл жағдайда while операторы қолданылады.

**инициализация (айнымалының) / initialization (of a variable)**
Айнымалыны инициализациялау – оған бастапқы мән беру. Python-да айнымалылар мәндер тағайындалмайынша жоқ болғандықтан, олар жасалған кезде инициализацияланады. Басқа бағдарламалау тілдерінде бұлай емес және айнымалы мәндерді инициализациясыз жасауға болады, бұл жағдайда олардың default (әдепкі) немесе _garbage_ (_қоқыс_) мәндері болады.

**итерация / iteration**
Бағдарламалау амалдарының жиынын қайталап орындау.

**цикл / loop**
Аяқтау шарты орындалғанға дейін амалды немесе амалдар тобын қайталап орындауға мүмкіндік беретін құрылым.

**цикл айнымалысы / loop variable**
Циклдің аяқталу шартының бөлігі ретінде пайдаланылатын айнымалы.

**мета -анотация / meta-notation**
Басқа белгілерді сипаттауға көмектесетін қосымша символдар немесе белгілер. Мұнда біз Python синтаксисінің қосымша, қайталанатын, алмастырылатын және бекітілген бөліктерін сипаттауға көмектесу үшін төртбұрышты жақшаларды, эллипстерді, курсивтерді және қалың әріптерді мета-анотация ретінде енгіздік.

**ортаңғы-сынақ циклі / middle-test loop**
Дененің бір бөлігін орындайтын, одан кейін шығу жағдайын сынайтын, содан кейін дененің біразын орындауы мүмкін цикл. Бізде бұл жағдай үшін арнайы Python конструкциясы жоқ, бірақ while және break-ті бірге пайдалана аламыз.

**кірістірілген цикл / nested loop**
Басқа циклдің денесінің ішіндегі цикл.

**жаңа жол / newline**
Курсорды келесі жолдың басына жылжытатын арнайы таңба.

**кейінгі-тест циклі / post-test loop**
Денені орындайтын, содан кейін шығу шартын тексеретін цикл. Бізде бұл үшін арнайы Python конструкциясы жоқ, бірақ while және break-ті бірге пайдалана аламыз.

**алдын ала сынақ циклі / pre-test loop**
Өз денесін орындайтынын-орындамайтынын шешпес бұрын тексеретін цикл. for және while екеуі де сынаққа дейінгі циклдар болып табылады.

**бір сатылы / single-step**
Интерпретаторды орындау режимі, онда сіз бағдарламаңызды бір уақытта бір қадам орындай аласыз және сол қадамның салдарын тексере аласыз. Не болып жатқанының ойша моделін түзету және құру үшін пайдалы.

**tab**
Курсорды ағымдағы жолдағы келесі tab-stop-қа (аялдамасына) жылжытатын арнайы таңба.

**trichotomy**
Кез келген нақты сандар берілген a және b , келесі қатынастардың дәл біреуі орындалады: a < b , a > b , немесе a == b . Осылайша, сіз екі қатынастың жалған екенін анықтай алатын болсаңыз, қалғанын дұрыс деп есептей аласыз.

**trace / із**                                                                                                                                                        
Бағдарламаның орындалу ағынын қолмен бақылау, айнымалылар күйінің өзгеруін және өндірілген кез келген нәтижені жазу.

## 5.26. Жаттығулар 

Бұл тарау бізге элементтердің тізімін қалай қосу керектігін және элементтерді қалай санау керектігін көрсетті. Санау мысалында кейбір таңдалған элементтерді ғана санауға мүмкіндік беретін ```if``` операторы бар. Циклден шығу үшін бізде ```break``` бар және циклды аяқтамай, циклдің ағымдағы итерациясынан бас тартуды ```continue``` арқылы жасай аламыз.

Тізімді өту, қосынды шығару, санау, сынақтан өткізу шарттары және ертерек шығу композициясы - осының барлығы сәл өзгеше болатын көптеген функцияларды жасау үшін қуатты тәсілдермен біріктіруге болатын құрылыс блоктарының бай жинағы.

Алғашқы алты сұрақ тек осы құрылыс блоктарын пайдаланып жаза алатын типтік функциялар болып табылады.

1. Тізімде қанша тақ сан бар екенін санайтын функцияны жазыңыз.

2. Тізімдегі барлық жұп сандарды қорытындылаңыз.

3. Тізімдегі барлық теріс сандарды қорытындылаңыз.

4. Тізімдегі қанша сөздің ұзындығы 5 болатынын санаңыз.

5. Тізімдегі бірінші жұп санға дейінгі барлық элементтердің қосындысын шығарыңыз, жұп санның өзін қоспаңыз. (Жұп сан болмаса ше?)

6. «sam» сөзінің бірінші рет кездесетінін қосқанда тізімде қанша сөз саны кездесетінін санаңыз. («sam» сөзі пайда болмаса ше?)

7. Ньютонның ```sqrt``` функциясына есептелген сайын ```better``` мәнін басып шығаратын ```print``` функциясын қосыңыз. Өзгертілген функцияңызды аргумент ретінде 25 арқылы шақырыңыз және нәтижелерді жазыңыз.

8. Алғашқы n [үшбұрышты сандарды](https://en.wikipedia.org/wiki/Triangular_number) басып шығаратын программа жазыңыз. n = 5 деп шақыру келесі нәтижені береді:

```python
1       1
2       3
3       6
4       10
5       15
```

( кеңес: ```үшбұрышты санның``` не екенін білу үшін интернеттен іздеуді пайдаланыңыз. Wiki: [Үшбұрышты сан](https://en-m-wikipedia-org.translate.goog/wiki/Triangular_number?_x_tr_sl=auto&_x_tr_tl=kk&_x_tr_hl=en&_x_tr_pto=wapp))

9. Жалғыз бүтін аргументті қабылдайтын және аргумент [жай сан](https://kk.wikipedia.org/wiki/%D0%96%D0%B0%D0%B9_%D1%81%D0%B0%D0%BD) болғанда ```True``` мәнін, ал кері жағдайда ```False``` мәнін қайтаратын ```is_prime``` функциясын жазыңыз.

10. 3-тараудағы жаттығулардағы мас қарақшы мәселесін қайта қарап шығыңыз. Бұл жолы мас қарақшы бұрылыс жасайды, содан кейін алға бірнеше қадам жасап, мұны қайталайды. Біздің әлеуметтік ғылымдар бойынша студент қазір жұп деректерді жазады: әр бұрылыстың бұрышы және бұрылыстан кейін жасалған қадамдар саны. Оның эксперименттік деректері \[(160, 20), (-43, 10), (270, 8), (-43, 12)]. Біздің мас досымыздың жолын салу үшін тасбақаны пайдаланыңыз.

11. Тасбақа көптеген қызықты фигураларды біз жоғарыда көрсеткендей жұптардың тізімін беру арқылы салуы мүмкін, мұнда жұптың бірінші тармағы - бұрылу бұрышы, ал екінші элемент - алға жылжу қашықтығы. Тасбақа, мұнда көрсетілген ортасында крест бар үйді сызатындай жұптар тізімін орнатыңыз. Бұл сызықтарды/жиектерді бір реттен артық өтпей және қаламды көтермей-ақ жасау керек.

![Shape](https://user-images.githubusercontent.com/84173441/174039754-041cd6ef-14d7-4550-8543-231cc548f717.JPG)

12. Жоғарыдағы сияқты барлық пішіндерді қаламды көтермей немесе салынып қойған сызықтың үстінен бірнеше рет өтпей салу мүмкін емес. Олардың қайсысын салуға болады?

![Shapes](https://user-images.githubusercontent.com/84173441/174039909-d6097276-4503-425d-bf3f-cc7003eaa8cf.JPG)

13. Цифрлар санын санау бағдарламасын есіңізге түсіріңіз. ```n = 0``` жағдайында не басып шығарады? Осы жағдай үшін ```1```-ді басып шығатындай етіп кодты өзгертіңіз. Бағдарламаны ```n = -24``` мәнімен шақырғанда неге шексіз цикл пайда болады? (_hint: -1//10 мәне -1 ге тең_). ```num_digits```-ті кез-келген бүтін санмен дұрыс жұмыс жасайтындай етіп өзгертіңіз

14. ```n```-дегі жұп цифрлардың санын санайтын бағдарлама жазыңыз

15. ```numbers``` тізіміндегі сандардың квадраттарының қосындысын есептейтін программа жазыңыз. Мысалы мынандай шаыру, ```numbers = [2, 3, 4]``` 4+9+16 деп басып шығару керек, ал оның нәтижесі 29.
