---
title: Кластар мен объектілер. көбірек OOP
isFree: True
---

# Кластар мен объектілер. тағы да OOP жайында

## 19.1 MyTime

Бағдарламашы анықтайтын дерек типінің тағы бір мысалы ретінде біз тәулік уақытын жазатын ```MyTime``` деп аталатын классты жазайық. Әрбір дананың сәйкес атрибуттар және инициализациямен жасалғанын қамтамасыз ету үшін ```__init__``` әдісін береміз. Класс анықтамасы келесідей:

```python
class MyTime:

    def __init__(self, hrs=0, mins=0, secs=0):
    """ Create a MyTime object initialized to hrs, mins, secs 
        hrs, mins, secs-қа инициализацияланған MyTime объектісін жасау
    """
    self.hours = hrs
    self.minutes = mins
    self.seconds = secs
```

Біз жаңа MyTime объектісін жасай аламыз:

```python
tim1 = MyTime(11, 59, 30)
```

Объектінің күй диаграммасы келесідей болады:

![tim1](https://user-images.githubusercontent.com/84173441/177099196-48c4fb5c-b882-4b74-abea-700b0077eab4.JPG)

```MyTime``` объектілері өздерін дұрыс басып шығара алуы үшін ```__str__``` әдісін жазуды оқырмандарға жаттығу ретінде береміз.

(жызып [салыстыр](https://ituniverbook.org/books/python-qazaq-til/%D0%BA%D0%BB%D0%B0%D1%81%D1%82%D0%B0%D1%80-%D0%BC%D0%B5%D0%BD-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D1%96%D0%BB%D0%B5%D1%80-%D0%BA%D3%A9%D0%B1%D1%96%D1%80%D0%B5%D0%BA-oop#19-12-))

## 19.2 Таза функциялар / Pure functions

Келесі бірнеше бөлімде екі ```MyTime``` объектісінің қосындысын есептейтін ```add_time``` деп аталатын функцияның екі нұсқасын жазамыз. Олар функциялардың екі түрін көрсетеді: таза функциялар және модификаторлар. Төменде ```add_time``` функциясының өрескел нұсқасы берілген:

```python
def add_time(t1, t2):
    h = t1.hours + t2.hours
    m = t1.minutes + t2.minutes
    s = t1.seconds + t2.seconds
    sum_t = MyTime(h, m, s)
    return sum_t
```

Функция жаңа ```MyTime``` объектісін жасайды және жаңа объектіге сілтемені қайтарады. Бұл **pure function** (таза функция) деп аталады, себебі ол оған параметр ретінде берілген объектінің ешқайсысын өзгертпейді және оның global айнымалыларды жаңарту, мәнді көрсету немесе пайдаланушы енгізуін алу сияқты жанама әсерлері жоқ (no side effects).

Бұл функцияны пайдаланудың мысалы төменде келтірілген. Біз екі ```MyTime``` объектісін жасаймыз: ағымдағы уақытты қамтитын ```current_time```; және наубайшыға нан пісіруге кететін уақыт мөлшерін қамтитын ```bread_time```. Содан кейін нанның қашан дайын болатынын анықтау үшін ```add_time``` функциясын қолданамыз.

```python
>>> current_time = MyTime(9, 14, 30)
>>> bread_time = MyTime(3, 35, 0)
>>> done_time = add_time(current_time, bread_time)
>>> print(done_time)
12:49:30
```

Бұл бағдарламаның шығысы 12:49:30, бұл дұрыс. Екінші жағынан, нәтиже дұрыс болмайтын жағдайлар бар. Сіз бір-екі мысалын ойлай аласыз ба?

Мәселе мынада, бұл функция секундтар немесе минуттар қосындысы нәтижесі алпыстан асып кететін жағдайларды қарастырмайды. Асып кету жағдайы орын алғанда, қосымша секундтарды минуттар бағанына немесе қосымша минуттарды сағаттар бағанына тасымалдауымыз керек.

Олай болса, функцияның жақсырақ нұсқасы:

```python
def add_time(t1, t2):

    h = t1.hours + t2.hours
    m = t1.minutes + t2.minutes
    s = t1.seconds + t2.seconds
    
    if s >= 60
        s -= 60
        m += 1
    if m >= 60:
        m -= 60
        h += 1
        
    sum_t = MyTime(h, m, s)
    return sum_t
```

Бұл функция үлкейе бастады және әлі де барлық ықтимал жағдайларда жұмыс істемейді. Кейінірек біз жақсырақ код беретін балама тәсілді ұсынатын боламыз.

## 19.3 Модификаторлар

Функцияға параметр ретінде берілген бір немесе бірнеше объектілерді өзгерту пайдалы болатын кездер болады. Әдетте, шақырушы өзі беретін объектілерге сілтеме сақтайды, сондықтан функция жасаған кез келген өзгерістер шалушыға көрінеді. Осылай жұмыс істейтін функциялар **modifiers** (модификаторлар) деп аталады.

```MyTime``` объектісіне берілген секундтар санын қосатын ```increment``` әдетте модификатор ретінде жазылатыны сөзсіз. Функцияның дөрекі жобасы келесідей:

```python
def increment(t, secs):
    t.seconds += secs

    if t.seconds >= 60:
        t.seconds -= 60
        t.minutes += 1
        
    if t.minutes >= 60:
        t.minutes -= 60
        t.hours += 1
```

Бірінші жол негізгі операцияны орындайды; қалғандары біз жоғарыда көрген ерекше жағдайларға қатысты.

Бұл функция дұрыс па? Параметр ```seconds``` алпыстан әлдеқайда көп болса не болады? Бұл жағдайда әрекетті бір рет жасау жеткіліксіз; секунд алпыстан аз болғанша мұны істей беруіміз керек. Шешімдердің бірі ```if``` операторларын ```while``` операторларымен ауыстыру:

```python
def increment(t, seconds):
    t.seconds += seconds
    
    while t.seconds >= 60:
        t.seconds -= 60
        t.minutes += 1
        
    while t.minutes >= 60:
        t.minutes -= 60
        t.hours += 1
```

Бұл функция секундтар теріс болмаса және сағат 23-тен аспаса дұрыс болады, бірақ бұл әлу де өте жақсы шешім емес.

## 19.4 increment-ті әдіске түрлендіру

Тағы да, OOP бағдарламашылары ```MyTime``` объектілерімен жұмыс істейтін функцияларды ```MyTime``` класына қоюды жөн көреді, сондықтан ```increment```-ті (өсуді) әдіске түрлендірейік.! Кеңістікті үнемдеу үшін біз бұрын анықталған әдістерді жазбаймыз, бірақ сіз өз нұсқаңызда оларды сақтауыңыз керек:

```python
class MyTime:
    # Previous method definitions here...
    # А лдыңғы әдіс анықтамалары осында жазылады ...
    
    def increment(self, seconds):
        self.seconds += seconds
        
        while self.seconds >= 60:
            self.seconds -= 60
            self.minutes += 1
        
        while self.minutes >= 60:
            self.minutes -= 60
            self.hours += 1
```

Трансформация таза механикалық болып табылады — біз анықтаманы класс анықтамасына жылжытамыз және (қаласаңыз) Python стилінің конвенцияларына сәйкес келетіндей етіп бірінші параметрдің атын ```self``` деп өзгертеміз.

Енді біз әдісті шақыру синтаксисін пайдаланып ```increment```-ті шақыра аламыз.

```python
current_time.increment(500)
```

Тағы да, әдіс шақырылатын объект бірінші параметр ```self```-ке тағайындалады. Екінші параметр, ```seconds``` 500 мәнін алады.


## 19.5 «Аха!» түсінік

Көбінесе мәселені жоғары деңгейде түсіну бағдарламалауды айтарлықтай жеңілдетеді.

Бұл жағдайда ```MyTime``` объекті шын мәнінде 60 негізіндегі (base) үш таңбалы сан деп түсіну керек! ```second``` компоненті бірлер бағаны, ```minute``` компоненті алпыстар бағаны, ```hour``` компоненті 3600 бағаны.

Біз ```add_time``` және ```increment``` жазған кезде, біз 60-базада қосуды тиімді орындадық, сондықтан бір бағаннан келесіге өтуге тура келді.

Бұл бақылау бүкіл мәселеге басқа шешім тәсілін ұсынады — біз ```MyTime``` объектісін бір санға түрлендіре аламыз және компьютердің сандармен арифметика жасауды білу артықшылығын пайдалана аламыз. Кез келген инстанцияны сәйкес секунд санына түрлендіру үшін ```MyTime``` классына келесі әдіс қосылады:

```python
class MyTime:
    # ...
    
    def to_seconds(self):
        """ Return the number of seconds represented by this instance
            Осы инстанциямен көрсетілген секундтар санын қайтар
        """
        return self.hours * 3600 + self.minutes * 60 + self.seconds
```

Енді бізге тек бүтін саннан ```MyTime``` объектісіне түрлендірудің жолы ғана қажет. Бізде ```tsecs``` секундтар бар делік, кейбір бүтін сандарды бөлу және модуль операторлары мұны біз үшін жасай алады:

```python
hrs = tsecs // 3600
leftoversecs = tsecs % 3600
mins = leftoversecs // 60
secs = leftoversecs % 60
```

Бір негізден екіншісіне түрлендірудің бұл әдісі дұрыс екеніне өзіңізді сендіру үшін біраз ойлануыңыз керек болуы мүмкін.

Object-Oriented-Programming-те біз деректер мен оған қолданылатын операцияларды біріктіруге тырысамыз. Сондықтан біз ```MyTime``` классында осы логикаға ие болғымыз келеді. Жақсы шешім - **қалыпты** мәндерден тыс секундтардың немесе минуттардың бастапқы мәндерін шеше алатындай класс инициализаторын қайта жазу. (**Қалыпты** уақыт 3 сағат 12 минут 20 секунд сияқты болады. Сол уақыт, бірақ қалыптастырылмаған 2 сағат 70 минут 140 секунд болуы мүмкін.) **қалыпты - normalized**

```MyTime``` үшін неғұрлым қуатты инициализаторды қайта жазайық:

```python
class MyTime:
   # ...
   
   def __init__(self, hrs=0, mins=0, secs=0):
       """ Create a new MyTime object initialized to hrs, mins, secs.
           The values of mins and secs may be outside the range 0-59,
           but the resulting MyTime object will be normalized.
       """
       """
          hrs, mins, sec-қа инициализацияланған жаңа MyTime нысанын жасаңыз.
          mins және secs мәндері 0-59 ауқымынан тыс болуы мүмкін, 
          бірақ нәтижесінде MyTime объекті қалыпқа келтіріледі.
       """
       
       # Calculate total seconds to represent
       # Көрсетілетін жалпы секундтарды есептеңіз
       totalsecs = hrs*3600 + mins*60 + secs
       self.hours = totalsecs // 3600 # Split in h, m, s
       leftoversecs = totalsecs % 3600
       self.minutes = leftoversecs // 60
       self.seconds = leftoversecs % 60
```

Енді ```add_time```-ды келесідей қайта жаза аламыз:

```python
def add_time(t1, t2):
    secs = t1.to_seconds() + t2.to_seconds()
    return MyTime(0, 0, secs)
```

Бұл нұсқа түпнұсқадан әлдеқайда қысқа және оның дұрыс екенін көрсету немесе дәлелдеу оңайырақ.

## 19.6 Жалпылау / Generalization

Бір жағынан, 60-тық неігзден 10-дың негізге және кері түрлендіру қиынырақ. Негізді түрлендіру көбірек абстракты; тек уақытпен жұмыс істеу интуициясы жақсырақ.

Бірақ егер бізде уақытты 60 негізіндегі сандар ретінде қарастырып, түрлендірулерді жазуға ынта-жігер болса, біздің бағдарламамыз қысқарақ, оқу мен жөндеуге оңай және сенімдірек болады.

Мүмкіндіктерді (feature) кейінірек қосу да оңайырақ. Мысалы, олардың арасындағы уақыт ұзақтығын табу үшін екі ```MyTime``` объектісін бір-бірінен алуды елестетіңіз. Қарыз алу арқылы шегеруді жүзеге асыру дұрыс тәсіл болмас еді. Түрлендіру функцияларын пайдалану оңайырақ және дұрысырақ болар еді.

Бір қызығы, кейде мәселені қиындату (немесе жалпылау) бағдарламалауды жеңілдетеді, өйткені ерекше жағдайлар аз және қателік мүмкіндіктері аз.

---

Арнайы vs жалпылау / Specialization versus Generalization

Компьютерлік ғалымдар әдетте өз түрлерін арнайы етіду ұнатады, ал математиктер көбінесе керісінше көзқарасты ұстанады және бәрін жалпылайды.

Мұнымен не айтқымыз келеді?

Егер біз математиктен жұмыс күндеріне, ғасыр күндеріне, карта ойнауға, уақытқа немесе доминоға қатысты есепті шешуді сұрасақ, олардың ең ықтимал жауабы осы объектілердің барлығын бүтін сандармен көрсетуге болатынын байқау болып табылады. Ойын карталарын, мысалы, 0-ден 51-ге дейін нөмірлеуге болады. Ғасыр ішіндегі күндерді нөмірлеуге болады. Математиктер былай айтар еді: _«Бұлар санауға болатын нәрселер — элементтерді уникалды нөмірлеуге болады (және біз бастапқы тұжырымдамаға оралу үшін бұл нөмірлеуді өзгерте аламыз). Ендеше оларды нөмірлеп, ойымызды бүтін сандармен шектейік. Бақытымызға орай, бізде күшті әдістер бар және бүтін сандарды жақсы түсінеміз, сондықтан біздің абстракцияларымыз - бұл мәселелерді шешу және жеңілдету тәсілі - оларды бүтін сандарға қатысты мәселелерге азайтуға тырысу»._

Компьютер ғалымдары керісінше жасайды. Біз домино тастары үшін немесе ғасыр күндері үшін мағынасыз, керек емес көптеген бүтін сандар есептеуі бар деп ойлаймыз. Сондықтан біз жиі ```MyTime``` сияқты жаңа арнайы түрлерді анықтайтын боламыз, соның арқасында біз мүмкін болатын операцияларды шектей аламыз, басқарамыз және арнайы етеміз. Объектіге бағытталған бағдарламалау әсіресе танымал, себебі ол бізге әдістер мен арнайы деректерді жаңа түрге біріктірудің жақсы жолын береді.

Екі тәсіл де проблеманы шешудің күшті әдістері болып табылады. Көбінесе проблеманы екі тұрғыдан да ойлау көмектесуі мүмкін: _«Егер мен бәрін өте аз қарапайым түрлерге түсіруге тырыссам не болар еді?»_ және _«Егер бұл заттың өзінің арнайы түрі болса не болар еді?»_

---

## 19.7 Тағы бір мысал

```after``` (кейін) функциясы екі уақытты салыстыру керек және бірінші уақыт екіншісінен кейін екенін айту керек, мысалы.

```python
>>> t1 = MyTime(10, 55, 12)
>>> t2 = MyTime(10, 48, 22)
>>> after(t1, t2) # Is t1 after t2?
True
```

Бұл сәл күрделірек, себебі ол бір ғана емес, екі ```MyTime``` объектісінде жұмыс істейді. Бірақ біз оны бәрібір әдіс ретінде жазғанды жөн көреміз - бұл жағдайда бірінші аргументтегі әдіс:

```python
class MyTime:
    # Previous method definitions here...
    
    def after(self, time2):
        """ Return True if I am strictly greater than time2 """
        if self.hours > time2.hours:
            return True
        if self.hours < time2.hours:
            return False
        
        if self.minutes > time2.minutes:
            return True
        if self.minutes < time2.minutes:
            return False
        if self.seconds > time2.seconds:
            return True
        
        return False
```

Біз бұл әдісті бір объектіде шақырамыз, ал екіншісін аргумент ретінде береміз:

```python
if current_time.after(done_time):
    print("The bread will be done before it starts!")
```

Біз шақыруды ағылшын тілі сияқты дерлік оқи аламыз: Егер ағымдағы уақыт (current_time) орындалған уақыттан (done_time) кейін болса, онда. . .

Бұл жерде ```if``` операторларының логикасына ерекше назар аудару керек. 11-18 жолдарға екі сағаттық өрістер бірдей болған жағдайда ғана жетеді. Сол сияқты, 16-жолдағы сынақ екі уақытта да бірдей сағаттар мен минуттар болған жағдайда ғана орындалады.

Біз мұны «Аха!» және бұрынғы білімді пайдаланып, екі уақытты да бүтін санға қысқартып, жеңілдете аламыз ба? Иә, керемет нәтижелермен!

```python
class MyTime:
    # Previous method definitions here...
    # Алдыңғы әдіс анықтамалары осында жазылады ...
    
    def after(self, time2):
        """ Return True if I am strictly greater than time2 
            Егер мен time2-ден нақыт үлген болсам True деп қайтар
        """
        return self.to_seconds() > time2.to_seconds()
```

Бұл кодтаудың тамаша тәсілі: егер бірінші уақыт екіншіден кейін екенін білгіміз келсе, екеуін де бүтін сандарға айналдырып, бүтін сандарды салыстырыңыз.

## 19.8 Operator overloading

Кейбір тілдер, соның ішінде Python, әртүрлі түрлерге қолданған кезде бір оператор басқа мағынаға ие болуға мүмкіндік береді. Мысалы, Python тілінде **+** бүтін сандар мен тіркестер үшін мүлдем басқа мағынаны білдіреді. Бұл мүмкіндік **operator overloading** (оператордың шамадан тыс жүктелуі) деп аталады.

Бұл әсіресе бағдарламашылар өздерінің анықтаған түрлері үшін operator overloading-ті қолданғанда пайдалы.

Мысалы, + қосу операторын қайта анықтау үшін ```__add__``` деп аталатын әдісті қамтамасыз ете аламыз:

```python
class MyTime:
    # Previously defined methods here...
    
    def __add__(self, other):
        return MyTime(0, 0, self.to_seconds() + other.to_seconds())
```

Әдеттегідей, бірінші параметр әдіс шақырылатын объект болып табылады. Екінші параметр оны ```self```-тен ажырату үшін ыңғайлы түрде ```other``` (басқа) деп аталады. Екі ```MyTime``` объектісін қосу үшін біз олардың қосындысын қамтитын жаңа ```MyTime``` объектісін жасаймыз және қайтарамыз.

Енді ```MyTime``` объектілеріне + операторын қолданғанда, Python біз жазған ```__add__``` әдісін шақырады:

```python
>>> t1 = MyTime(1, 15, 42)
>>> t2 = MyTime(3, 50, 30)
>>> t3 = t1 + t2
>>> print(t3)
05:06:12
```

```t1 + t2``` өрнегі ```t1.__add__(t2)``` өрнегімен бірдей, бірақ бірінші нұсқа элегантты екені түсінікті. Жаттығу ретінде азайту операторын шамадан тыс жүктейтін ```__sub__(self, other)``` әдісін жазыңыз және оны қолданып көріңіз.

Келесі жаттығулар үшін біз объектілер туралы бірінші тарауда анықталған ```Point``` класына қайта ораламыз және оның кейбір операторларын шамадан тыс жүктейміз. Біріншіден, екі нүктені қосу олардың сәйкес (x, y) координаттарын қосады:

```python
class Point:
    # Previously defined methods here...
    # Алдыңғы әдіс анықтамалары осында жазылады ...
    
    def __add__(self, other):
        return Point(self.x + other.x, self.y + other.y)
```

Көбейту операторының әрекетін қайта анықтаудың бірнеше жолы бар: ```__mul__``` немесе ```__rmul__``` немесе екеуі де аталған әдісті анықтау арқылы.

Егер * параметрінің сол жақ операнды ```Point``` болса, Python ```__mul__``` шақырады, ол басқа операнды да ```Point``` деп есептейді. Ол сызықтық алгебра ережелеріне сәйкес анықталған екі нүктенің нүктелік көбейтіндісін есептейді:

```python
def __mul__(self, other):
    return self.x * other.x + self.y * other.y
```

Егер * параметрінің сол жақ операнды бүтін сан тип болса және оң операнды ```Point``` болса, Python скалярлық көбейтуді орындайтын ```__rmul__``` шақырады:

```python
def __rmul__(self, other):
    return Point(other * self.x, other * self.y)
```

Нәтиже координаталары бастапқы координаттардың еселігі болатын жаңа ```Point``` болып табылады. Егер ```other``` ```float``` санға көбейтілмейтін түр болса, ```__rmul__``` қате береді.

Бұл мысал көбейтудің екі түрін де көрсетеді:

```python
>>> p1 = Point(3, 4)
>>> p2 = Point(5, 7)
>>> print(p1 * p2)
43
>>> print(2 * p2)
(10, 14)
```

Егер біз ```p2 * 2``` бағалауға тырыссақ не болады? Бірінші параметр нүкте болғандықтан, Python екінші аргумент ретінде 2-мен ```__mul__``` шақырады. ```__mul__``` ішінде бағдарлама ```other``` ```x``` координатасына қол жеткізуге тырысады, ол бүтін санның атрибуттары болмағандықтан орындалмайды:

```python
>>> print(p2 * 2)
AttributeError: 'int' object has no attribute 'x'
```

Өкінішке орай, қате туралы хабар аздап бұлыңғыр. Бұл мысал объектілі-бағытталған бағдарламалаудың кейбір қиындықтарын көрсетеді. Кейде қандай код жұмыс істеп тұрғанын анықтау қиын.


## 19.9 Полиморфизм

Біз жазған әдістердің көпшілігі тек белгілі бір түр үшін жұмыс істейді. Жаңа объектіні жасағанда, біз осы типте жұмыс істейтін әдістерді жазамыз.

Бірақ біз көптеген түрлерге қолданғымыз келетін белгілі бір операциялар бар, мысалы, алдыңғы бөлімдердегі арифметикалық амалдар. Егер көптеген түрлер бірдей операциялар жинағын қолдаса, біз сол түрлердің кез келгенінде жұмыс істейтін функцияларды жаза аламыз.

Мысалы, ```multadd``` операциясы (сызықтық алгебрада жиі кездеседі) үш параметрді қабылдайды; ол алғашқы екеуін көбейтеді, содан кейін үшіншісін қосады. Біз оны Python тілінде келесідей жаза аламыз:

```python
def multadd (x, y, z):
    return x * y + z
```

Бұл функция көбейтуге болатын кез келген ```x``` және ```y``` мәндері үшін және осының нәтижесіне қосуға болатын кез келген ```z``` мәні үшін жұмыс істейді.

Біз оны сандық мәндермен шақыра аламыз:

```python
>>> multadd (3, 2, 1)
7
```

Немесе ```Point```-тармен:

```python
>>> p1 = Point(3, 4)
>>> p2 = Point(5, 7)
>>> print(multadd (2, p1, p2))
(11, 15)
>>> print(multadd (p1, p2, 1))
44
```

Бірінші жағдайда ```Point``` скалярлық көбейтіледі, содан кейін басқа ```Point```-қа қосылады. Екінші жағдайда нүкте туындысы сандық мән береді, сондықтан үшінші параметр де сандық мән болуы керек.

Түрлі аргументтерді қабылдай алатын осындай функция **polymorphic** (полиморфты) деп аталады.

Басқа мысал ретінде тізімді алға және артқа екі рет басып шығаратын ```front_and_back``` функциясын қарастырыңыз:

```python
def front_and_back(front):
    import copy
    back = copy.copy(front)
    back.reverse()
    print(str(front) + str(back))
```

Кері жазу әдісі ```reverse``` модификатор болғандықтан, біз керісінше жазбас бұрын тізімнің көшірмесін жасаймыз. Осылайша, бұл функция параметр ретінде алатын тізімді өзгертпейді.

Тізімге ```front_and_back``` қолданылатын мысал:

```python
>>> my_list = [1, 2, 3, 4]
>>> front_and_back(my_list)
[1, 2, 3, 4][4, 3, 2, 1]
```

Әрине, біз бұл функцияны тізімдерге қолдануды көздедік, сондықтан оның жұмыс істеуі таңқаларлық емес. Егер біз оны ```Point```-қа қолдансақ, таңқаларлық жағдай сонда болады.

Функцияны жаңа түрге қолдануға болатынын анықтау үшін біз Python-ның **үйрек теру ережесі** (duck typing rule) деп аталатын негізгі полиморфизм ережесін қолданамыз: _Функция ішіндегі барлық операцияларды түрге қолдануға болатын болса, функцияны түрге қолдануға болады_. front_and_back функциясындағы опрациялар ```copy, reverse``` және ```print```-ті қамтиды.

Барлық бағдарламалау тілдері полиморфизмді осылай анықтай бермейді. _Үйрек теру_ әдісін іздеңіз және оның неліктен бұл атауға ие екенін анықтаңыз.

```copy``` кез келген объектіде жұмыс істейді және біз ```Point``` объектісі үшін ```__str__``` әдісін жазғанбыз, сондықтан бізге тек ```Point``` классында ```reverse``` әдісі керек:

```python
def reverse(self):
    (self.x , self.y) = (self.y, self.x)
```

Содан кейін біз ```Point```-ты ```front_and_back```-қа бере аламыз:

```python
>>> p = Point(3, 4)
>>> front_and_back(p)
(3, 4)(4, 3)
```

Ең қызықты полиморфизм - бұл әдейі емес түр, мұнда біз бұрыннан жазған функцияны біз ешқашан жоспарламаған түрге қолдануға болатынын анықтаймыз.

## 19.10 Глоссарий

**нүктелік өнім** / **dot product**
Екі ```Point```-ты көбейтетін және сандық мән беретін сызықтық алгебрада анықталған операция.

**функционалдық бағдарламалау стилі** / **functional programming style**
Функциялардың көпшілігі таза болатын бағдарлама дизайнының стилі.

**модификатор** / **modifier**
Параметрлер ретінде қабылдайтын бір немесе бірнеше объектілерді өзгертетін функция немесе әдіс. Модификатор функцияларының көпшілігі жарамсыз (мәнді қайтармайды).

**нормаланған** / **normalized**
Деректер кейбір қысқартылған диапазонға немесе ережелер жинағына сәйкес келсе, нормаланған деп аталады. Біз әдетте \[0..360) диапазондағы мәндерге бұрыштарымызды қалыпқа келтіреміз. Біз \[0..60) диапазондағы мәндер болу үшін минуттар мен секундтарды қалыпқа келтіреміз. Жергілікті дүкен өзінің салқын сусындарын «Бір доллар, екі жүз елу цент» деп жарнамаласа, таң қалар едік.

**оператордың шамадан тыс жүктелуі** / **operator overloading**
Кірістірілген операторларды (+, -, \*, >, <, т.б.) аргументтердің әртүрлі түрлері үшін әртүрлі әрекеттерді жасайтындай кеңейту. Біз кітаптың басында сандар мен тіркестер үшін + қалай шамадан тыс жүктелетінін көрдік, міне, осында пайдаланушы анықтаған түрлер үшін оны одан әрі шамадан тыс жүктеу жолы көрсетілген.

**полиморфты** / **polymorphic**
Бірнеше түрмен жұмыс істей алатын функция. Аздаған айырмашылыққа назар аударыңыз: шамадан тыс жүктеу (overloading) әртүрлі түрлер үшін әртүрлі функцияларға ие (барлығы бірдей атпен), ал полиморфты функция түрлердің бірнешеуі үшін жұмыс істей алатын жалғыз функция.

**таза функция** / **pure function**
Параметр ретінде қабылдайтын объектілердің ешқайсысын өзгертпейтін функция. Көптеген таза функциялар бос емес, нәтижелі.
A function that does not modify any of the objects it receives as parameters. Most pure functions are fruitful rather than void.

**скалярлық көбейту** / **scalar multiplication**
```Point``` координаталарының әрқайсысын сандық мәнге көбейтетін сызықтық алгебрада анықталған операция.


## 19.11 Жаттығулар

1. Аргумент ретінде екі ```MyTime``` объектісін, ```t1``` және ```t2``` қабылдайтын және шақырылатын объект екі уақыт арасына түссе, ```True``` мәнін қайтаратын логикалық функцияны жазыңыз. ```t1 <= t2``` деп қабылдап, сынақты төменгі шекарада жабық және жоғарғы шекарада ашық етіп жасаңыз, яғни ```t1 <= obj < t2``` болса, ```True``` мәнін қайтарыңыз.

2. Жоғарыдағы функцияны ```MyTime``` классындағы әдіске айналдырыңыз.

3. Былай жазудың орнына

```python
if t1.after(t2): ...
```

ыңғайлырақ пайдалана алатындай етіп қажетті оператор(лар)ды шамадан тыс жүктеңіз

```python
if t1 > t2: ...
```

4. «Аха» инсайтымызды пайдаланатын әдіс ретінде ```increment```-ті қайта жазыңыз.

5. ```increment``` әдісі үшін кейбір сынақ жағдайларын жасаңыз. Уақытқа қосылатын секунд саны теріс болатын жағдайды арнайы қарастырыңыз. Бұл жағдайды өңдейтіндей етіп ```increment```-ті түзетіңіз, егер ол мұны істемесе. (Уақыт объектісіндегі секундтан артық секундты ешқашан алып тастамайсыз деп болжауға болады.)

6. Физикалық уақыт теріс болуы мүмкін бе, әлде уақыт әрқашан алға бағытта жүруі керек пе? Кейбір құрметті физиктер бұл соншалықты ақымақ сұрақ емес деп ойлайды. Бұл туралы Интернетте не табуға болатынын қараңыз.


## 19.12 Қосымша

```python
class MyTime:

    def __init__(self, hrs = 0, mins = 0, secs = 0):
        self.hrs = hrs
        self.mins = mins
        self.secs = secs

    
    def __str__(self):
        return '{0}:{1}:{2}'.format(self.hrs, self.mins, self.secs)
    


tim1 = MyTime(14, 51, 39)

print(tim1)
```

