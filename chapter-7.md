---
title: Нәтижелі функциялар 
isFree: true
---

# 7. Нәтижелі функциялар / Fruitful functions

## 7.1. Қайтаратын мәндер 

Біз пайдаланған ```abs, pow, int, max``` және ```range``` сияқты кірістірілген функциялар нәтиже берді. Осы функциялардың әрқайсысын шақыру мән береді, және біз оны әдетте айнымалыға тағайындаймыз немесе өрнек бөлігі ретінде қолданамыз.

```python
biggest = max(3, 7, 2, 5)
x = abs(3 - 11) + 10
```

Біз сондай-ақ күрделі пайызды есептеу үшін соңғы соманы қайтару функциямызды жаздық.

Бұл тарауда біз басқа атауды қажет етпеу үшін нәтижелі функциялар деп аталатын мәндерді қайтаратын көбірек функцияларды жазамыз. Бірінші мысал - берілген радиусына байланысты шеңбердің ауданын қайтаратын ```area```:

```python
def area(radius):
    b = 3.14159 * radius**2
    return b
```

Біз қайтару ```return``` амалын бұрын көрдік , бірақ нәтижелі функцияның ```return``` операторында _қайтару мәні_ - ```return value``` бар . Бұл амал мынаны білдіреді: қайтару өрнегін бағалаңыз, содан кейін оны осы функцияның нәтижесі (жемісі) ретінде дереу қайтарыңыз. Жоғарыдағы өрнек аздап күрделі болуы мүмкін, сондықтан біз бұл функцияны келесідей жаза аламыз:

```python
def area(radius):
    return 3.14159 * radius * radius
```

Екінші жағынан, жоғарыдағы ```b``` сияқты уақытша айнымалылар debugging процессін жеңілдетеді.

Кейде шарттың әрбір тармағында бір-бірден қайтару ```return``` амалы болуы пайдалы. Біз кірістірілген ```abs```-ді көрдік, енді өзіміз қалай жазу керектігін көреміз:

```python
def absolute_value(x):
    if x < 0:
        return -x
    else:
        return x
```

Жоғарыдағы функцияны жазудың тағы бір жолы ```else``` функциясын жазбай алып тастап, ```if``` шартынан кейін екінші ```return``` операторы арқылы жазу.

```python
def absolute_value(x):
    if x < 0:
        return -x
    return x
```

Бұл нұсқа туралы ойланыңыз және оның бірінші нұсқасы сияқты жұмыс істейтініне сенімді болыңыз.

Қайтару ```return``` амалынан кейін немесе орындау ағыны ешқашан жете алмайтын кез келген басқа жерде пайда болатын код жансыз код (**dead code**) немесе қол жетімсіз код (**unreachable code**) деп аталады.

Нәтижелі функцияда бағдарлама арқылы мүмкін болатын барлық жағдайды қайтару амалымен қамтамасыз ету жақсы идея. ```absolute_value``` функциясының келесі нұсқасы мұны орындай алмайды:

```python
def bad_absolute_value(x):
    if x < 0:
        return -x
    elif x > 0:
        return x
```

Бұл нұсқа дұрыс емес, себебі егер ```x``` 0 болса, ешбір шарт ақиқат емес және функция қайтару операторын орындамай аяқталады. Бұл жағдайда қайтарылатын мән ```None``` деп аталатын арнайы мән болып табылады:

```python
>>> print(bad_absolute_value(0))
None
```

Барлық Python функциялары басқа мәнді қайтармаған кезде ```None``` қайтарады.

Сондай-ақ, қайтару операторын ```for``` циклінің ортасында қолдануға болады, бұл жағдайда басқару элементі функциядан бірден қайтарылады. Бізге сөйлемдегі сөздер тізімін қарап шығатын функция қажет деп есептейік. Ол бірінші 3 әріпті сөзді қайтаруы керек. Егер ондай сөз болмаса, ол бос жолды қайтаруы керек:

```python
def find_first_3_letter_word(xs):
    for word in xs:
        if len(word) == 3:
           return word
    return " "
```

![image](https://user-images.githubusercontent.com/84173441/172532480-5d394abe-2c49-4074-ba1f-3579a6c41e70.png)

Осы кодтың әр қадамын қарайтын болсақ функция тізімдегі үшінші элементті ("мен" сөзін) өңдеу кезінде қайтарылатынына көз жеткізіңіз: функция бүкіл тізімді айналмай бірден тоқтайды.

## 7.2 Бағдарламаны жазу

Осы бөлімге жеткенде сіз жазылып біткен функцияларды қарап, олардың не істейтінін айта алуыңыз керек. Сондай-ақ, жаттығуларды орындаған болсаңыз, сіз кейбір шағын функцияларды жаздыңыз. Үлкенірек функцияларды жазғанда, әсіресе орындалу уақыты қателері мен семантикалық қателерге байланысты қиындықтар туындауы мүмкін.

Барған сайын күрделене түсетін бағдарламалармен күресу үшін біз **сатылы даму / incremental development** деп аталатын әдісті ұсынбақпыз. Сатылы дамудың мақсаты бір уақытта кодтың аз ғана мөлшерін қосу және сынау арқылы ұзақ жөндеу (debugging) сеанстарын болдырмау болып табылады.

Мысал ретінде, (x```1```, y```1``` ) және (x```2```, y```2```) координаталары арқылы берілген [екі нүкте арасындағы қашықтықты](https://www.wikihow.com/Find-the-Distance-Between-Two-Points) тапқымыз келеді делік. Пифагор теоремасы бойынша қашықтық:

![Distance](https://user-images.githubusercontent.com/84173441/172536340-0e08b18a-e98f-4491-927b-19720bf25ce7.JPG)

Бірінші қадам - Python-да ```distance``` функциясының қандай болуы керектігін ойластыру. Басқаша айтқанда, енгізілетін мәндер (параметрлер) қандай және шығыс (қайтарылатын мән / return value) қандай?

Бұл жағдайда екі нүкте енгізілетін мән болып табылады, біз оларды төрт параметр арқылы көрсете аламыз. Қайтару мәні өзгермелі нүкте мәні болып табылатын қашықтық болып табылады.

Біз қазірдің өзінде біздің ойымызды көрсететін функцияның құрылымын жаза аламыз:

```python
def distance(x1, y1, x2, y2):
    return 0.0
```

Функцияның бұл нұсқасы қашықтықтарды есептемейтіні анық; ол әрқашан нөлді қайтарады. Бірақ бұл синтаксистік тұрғыдан дұрыс және ол іске қосылады, яғни біз оны күрделірек етпес бұрын тексере аламыз.

Жаңа функцияны тексеру үшін оны тестілік мәндермен шақырамыз:

```python
>>> distance(3, 2, 7, 8)
0.0
```

![xy](https://user-images.githubusercontent.com/84173441/180715906-bbbb279d-4a1c-4e5a-9d3e-18b15969be2e.JPG)

Біз бұл мәндерде горизонтальды (көлденең) қашықтық 4-ке, ал вертикальды (тік) қашықтық 6-ға тең болатындай етіп таңдадық; осылайша, нәтиже 7.21 болады (4-6-7.21 үшбұрышының гипотенузасы). Ол [WikiHow](https://www.wikihow.com/Find-the-Distance-Between-Two-Points) сайтындағы есептеуде солай берілген. Функцияны тестілеу кезінде алдын ала дұрыс жауапты білу пайдалы.

Осы сәтті біз функцияның синтаксистік тұрғыдан дұрыс екенін растадық және код жолдарын қосуды бастай аламыз. Әрбір қосымша өзгертуден кейін біз функцияны қайтадан тексереміз. Кез келген нүктеде қателік орын алса, біз оның қай жерде болуы мүмкін екенін білеміз — біз қосқан соңғы жолда.

Есептеудің логикалық бірінші қадамы x```2``` - x```1``` және y```2``` - y```1``` айырмашылықтарын табу болып табылады . Біз бұл мәндерге ```dx``` және ```dy``` деп аталатын уақытша айнымалыларды қолданатын боламыз .

```python
def distance(x1, y1, x2, y2):
    dx = x2 - x1
    dy = y2 - y1
    return 0.0
```

Егер функцияны жоғарыда көрсетілген аргументтермен шақырсақ, орындау ағыны return операторына жеткенде, ```dx``` 4 және ```dy``` 6 болуы керек. Қайтару операторына курсорды қою және курсорға жеткенше орындау (Run to cursor F4) пернесін басу арқылы PyScripter-де бұл жағдайды тексере аламыз. Содан кейін функцияның дұрыс параметрлерді алуын және бірінші есептеуді дұрыс орындауын растау үшін тінтуірді олардың үстіне апару арқылы ```dx``` және ```dy``` айнымалыларын тексереміз. Нәтиже дұрыс болмаса, тексеру қажет бірнеше жол ғана.

![dxDy](https://user-images.githubusercontent.com/84173441/172539667-a4c176ec-a4c5-4300-9bdf-141dbc18046f.JPG)

Содан кейін ```dx``` және ```dy``` квадраттарының қосындысын есептейміз:

```python
def distance(x1, y1, x2, y2):
    dx = x2 - x1
    dy = y2 - y1
    dsquared = dx*dx + dy*dy
    return 0.0
```

Тағы да, біз осы кезеңде бағдарламаны іске қосып, ```dsquared``` мәнін тексере аламыз (ол 52 болуы керек).

Соңында, квадрат түбірді табу үшін 0,5 бөлшек көрсеткішін пайдаланып, есептеп, нәтижені қайтарамыз:

```python
def distance(x1, y1, x2, y2):
    dx = x2 - x1
    dy = y2 - y1
    dsquared = dx*dx + dy*dy
    result = dsquared**0.5
    return result

print(distance(3, 2, 7, 8))
```

Егер бұл дұрыс жұмыс істесе, сіз аяқтадыңыз. Әйтпесе, қайтару амалының алдындағы ```result``` мәнін тексергіңіз дұрыс.

Сіз бағдарламалауды үйреніп бастағанда 1-2 ғана код жолын қосып отыруыңыз мүмкін. Көбірек тәжірибе жинақтаған сайын, сіз өзіңіздің үлкен концептуалды бөліктерді жазу және жөндеуді жасап жатқаныңызды байқайсыз. Қалай болғанда да, кодты бір-бір жолдан өту және әрбір қадамның сіз күткендей нәтиже беретінін біліп отыру алдағы уақытта кодтан қате іздеу кезінде көп уақытыңызды үнемдейді. Бағдарламалау дағдыларын жетілдірген сайын сіз үлкен код бөліктерін қадағалай аласыз: бұл әріптерді, буындарды, сөздерді, сөз тіркестерін, сөйлемдерді, абзацтарды және т.б. оқуды үйренгенімізге немесе музыканы бөлшектеуді  — жеке ноталардан аккордтарға, жолақтарға, сөз тіркестеріне және т.б. үйрену тәсіліне өте ұқсас.

Процестің негізгі аспектілері:

1. Жұмыстың қаңқа бағдарламасынан бастаңыз және шағын қадамдық өзгерістер енгізіңіз. Кез келген сәтте, егер қате болса, оның қай жерде екенін нақты білесіз.

2. Уақытша айнымалыларды аралық мәндерге сілтеме жасау үшін пайдаланыңыз, осылайша оларды оңай бақылап, тексере аласыз.

3. Бағдарлама жұмыс істеп тұрғаннан кейін демалыңыз, артқа отырыңыз және әртүрлі опциялармен тексеріп ойнап көріңіз. («Ойыншылдықты» жақсырақ түсінуге, жақсырақ оқуға, көбірек ләззат алуға және қол жеткізе алатын нәрсеге қатысты позитивті ойлауға байланыстыратын қызықты зерттеулер бар — сондықтан біраз уақытты қызықты еткізіп ойнауға жұмсаңыз!). Бірнеше амалды бір үлкен құрамға біріктіргіңіз келуі мүмкін немесе пайдаланған айнымалылардың атын өзгертіңіз немесе функцияны қысқарта алатыныңызды көріңіз. Жақсы нұсқау - кодты басқалар оқуы үшін мүмкіндігінше жеңілдетуді мақсат ету.

Төменде функцияның басқа нұсқасы. Ол математикалық ```math``` модульдегі квадрат түбір функциясын пайдаланады (модульдер туралы жақын арада білетін боламыз). Сізге қайсысы ұнайды? Біз бастаған Пифагор формуласына қайсысы жақынырақ көрінеді?

```python
import math

def distance(x1, y1, x2, y2):
    return math.sqrt( (x2-x1)**2 + (y2-y1)**2 )
```

```python
>>> distance(3, 2, 7, 8)
7.21
```

## 7.3 print арқылы қателерді табу / Debugging with print

Түзетудің тағы бір жақсы әдісі (бағдарламаның айнымалы мәндерін және "бір-қадам" тексеруге балама) мұқият таңдап код ішіне қосымша басып шығару функцияларын (print) кірістіру болып табылады. Содан кейін бағдарламаның нәтижесін тексеру арқылы алгоритм сіз күткен нәрсені істеп жатқанын тексеруге болады. Дегенмен, мыналарды есте сақтаңыз:

- Сізде алға қойылған мақсаттың нақты шешімі болуы керек және бағдарламаны жөндеуден бұрын не болатынын білуіңіз керек. Кодты жазумен айналыспас бұрын, мәселені қағаз парағында шешу бойынша жұмыс жасаңыз (мүмкін сіз жасаған қадамдарды жазу үшін блок-схеманы қолданып көресіз). Бағдарлама жазу мәселені шешпейді — ол жай ғана қолмен жасайтын қадамдарды автоматтандырады. Сондықтан алдымен жұмыс істейтін қалам-қағаз қолдың шешімі бар екеніне көз жеткізіңіз. Бағдарламалау бұл қолмен орындалатын қадамдарды автоматты түрде жасау болып табылады.

- _Chatterbox_ функцияларын жазбаңыз. Chatterbox - негізгі міндетіне қоса, пайдаланушыдан енгізуді сұрайтын немесе нәтижені басып шығаратын нәтижелі функция, оның орнына нәтижелі функция жай ғана үнсіз, жұмысын тыныш орындаса пайдалырақ болар еді.

Мысалы, біз ```range```, ```max``` және ```abs``` сияқты кіріктірілген функцияларды көрдік. Бұлардың ешқайсысы, егер олар пайдаланушыны енгізуге шақырса немесе тапсырмаларды орындаған кезде нәтижелерін басып шығарса, басқа бағдарламалар үшін пайдалы құрылыс блоктары болмайды.

Функцияңыздың _негізгі мақсаты енгізу және шығаруды орындау болмаса_, жемісті функциялар ішінде басып шығару және енгізу функцияларын шақырмау жақсы кеңес болып табылады. ```print``` функциясын кодтың ішінде қолдануға болатын ерекше жағдайлар debugging және кодты түсіну мақсатында болады, бірақ ол кодты production, жұмысқа қосу кезеңінде алынып тасталуы керек.

## 7.4 Композиция / Composition

Осы кезге дейін біз білуіміз керек нәрсе, бір функцияның ішінен екінші функцияны шақыра алатынымыз. Бұл қабілет **композиция** деп аталады. 

Мысал ретінде біз екі нүктені - шеңбердің центрі мен периметрдегі нүктені алатын және шеңбердің ауданын есептейтін функцияны жазамыз.

Орталық нүкте ```xc``` және ```yc``` айнымалыларында, ал периметрлік нүкте ```xp``` және ```yp```-де сақталады деп есептейік . Бірінші қадам - шеңбердің радиусын табу, бұл екі нүктенің арасындағы қашықтық. Бақытымызға орай, біз дәл осылай жасайтын қашықтық функциясын жаздық, сондықтан енді оны пайдалануымыз керек:

```python
radius = distance(xc, yc, xp, yp)
```

Екінші қадам - сол радиусы бар шеңбердің ауданын табу және оны қайтару. Тағы да біз бұрынғы функцияларымыздың бірін қолданамыз:

```python
result = area(radius)
return result
```

Оны функцияға кірістіріп, біз мынаны аламыз:

```python
def area2(xc, yc, xp, yp):
    radius = distance(xc, yc, xp, yp)
    result = area(radius)
    return result
```

Біз бұл функцияны бұрын анықталған ```area``` функциясынан ажырату үшін ```area2``` деп атадық .

Уақытша айнымалылар ```radius``` және ```result``` код жазуға, жөндеуге және код арқылы бір қадамдап өтіп не болып жатқанын тексеру үшін пайдалы, бірақ бағдарлама жұмыс істеп тұрғанда, функция шақыруларын құрастыру арқылы оларды қысқартуға болады:

```python
def area2(xc, yc, xp, yp):
    return area(distance(xc, yc, xp, yp))
```

## 7.5 Логикалық функциялар / Boolean functions

Функциялар логикалық мәндерді қайтара алады, бұл көп жағдайда күрделі сынақтарды функция ішіндe жасыру үшін ыңғайлы. Мысалға:

```python
def is_divisible(x, y):
    """ Test if x is exactly divisible by y """
    if x % y == 0:
        return True
    else:
        return False
```

Логикалық функцияларға иә/жоқ сұрақтарына ұқсайтын атауларды беру стандартты жағдай. ```is_divisible``` ```x``` мәні ```y``` мәніне бөлінетінін немесе бөлінбейтінін көрсету үшін ```True``` немесе ```False``` мәнін қайтарады.

```if``` шартты операторының өзі логикалық өрнек екенін пайдаланып, функцияны ықшамдай аламыз. Біз if операторын мүлдем жазбай ақ, кодты тікелей қайтара аламыз:

```python
def is_divisible(x, y):
    return x % y == 0
```

Бұл сеанс жаңа функцияныны қолданыста көрсетеді:

```python
>>> is_divisible(6, 4)
False
>>> is_divisible(6, 3)
True
```

Логикалық функциялар шартты амалдарда жиі қолданылады:

```python
if is_divisible(x, y):
    ... # Do something ...
else:
    ... # Do something else ...
```

Мынадай нәрсені жазу қызықты болуы мүмкін:

```python
if is_divisible(x, y) == True:
```

бірақ қосымша салыстыру қажет емес.

## 7.6 Стильді бағдарламалау

Бағдарлама кодының оқуға жеңіл болуы өте маңызды, өйткені іс жүзінде бағдарламалар жазылғаннан әлдеқайда жиі оқылады және өзгертіледі. Бірақ, көптеген ережелер сияқты, біз оларды кейде бұзамыз. Бұл кітаптағы код мысалдарының көпшілігі Python қауымдастығы әзірлеген стиль Python Enhancement Proposal 8 ([PEP 8](https://peps.python.org/pep-0008/)) нұсқаулығына сәйкес болады.

Стиль туралы көбірек айтатын боламыз, өйткені бағдарламаларымыз күрделене түседі, бірақ бірнеше бағыт-бағдар қазірдің өзінде пайдалы болады:

- шегініс үшін 4 бос орынды (space) пайдаланыңыз. (tab-емес)
- жол ұзындығын 78 таңбаға дейін шектеңіз
- идентификаторларды атаған кезде класстар үшін ```CamelCase``` (класстарды кейін оқимыз) және функциялар мен айнымалылар үшін ```кіші_әріппен_астын_сызу``` пайдаланыңыз
- импорттауды файлдың жоғарғы жағына қойыңыз
- функция анықтамаларын import-тан кейін бірінің астына бірін жазыңыз
- функцияларды құжаттау үшін құжат жолдарын пайдаланыңыз. docstrings
- функция анықтамаларын бір-бірінен ара-қашықтық үшін екі бос жолды пайдаланыңыз
- жоғарғы деңгейдегі амалдарды, соның ішінде функция шақыруларын бағдарламаның төменгі жағында бірге жазыңыз

## 7.7 Unit testing / Бірлік сынағы

(бұл кітапта көп қарастырылмайды. Оқу міндетті емес)

Unit testing - бастапқы кодты автоматты түрде тестілеуді қосу бағдарламалық жасақтаманы әзірлеудегі ең жақсы тәжірибелердің бірі болып табылады. Бірлікті тестілеу кодтың жеке бөліктерінің (мысалы, функциялардың) дұрыс жұмыс істеп тұрғанын автоматты түрде тексеру жолын қамтамасыз етеді. Бұл функцияның орындалуын кейінірек өзгертуге және оның әлі де орындауға арналған нәрсені жасайтынын жылдам тексеруге мүмкіндік береді.

Бірнеше жыл бұрын ұйымдар өздерінің құнды активі бағдарламалық код пен құжаттама деген көзқараста болды. Ұйымдар енді бағдарламалық қамтамасыз ету бюджеттерінің үлкен бөлігін сынақтарды жасап жетілдіргуге (және сақтауға) жұмсайды.

Бірлікті тестілеу сонымен қатар бағдарламашыны функция өңдеуі қажет әртүрлі жағдайлар туралы ойлауға мәжбүр етеді. Сондай-ақ, кодты әзірлеу кезінде бірдей сынақ деректерін қайта-қайта енгізудің орнына сынақтарды script-іде бір рет жазасыз.

Debugging-ті немесе тестілеуді жеңілдететін бағдарламаңыздағы қосымша код **scaffolding** (тіреуіш код) деп аталады.

Кейбір кодқа арналған сынақтар жинағы оның **сынақ жинағы** (test suite) деп аталады .

Python-да бірлік тестілеуді орындаудың бірнеше түрлі жолдары бар — бірақ бұл кезеңде біз Python қауымдастығы әдетте не істейтінін елемейміз және біз өзіміз жазатын екі функциядан бастаймыз. Біз оларды бірлік сынақтарын жазу үшін қолданамыз.

Алдында осы тарауда жазған абсолютті_мән ```absolute_value``` функциясынан бастайық. Еске салайық, біз бірнеше түрлі нұсқаларды жазған болатынбыз, олардың соңғысы дұрыс емес, қатесі бар. Тесттер бұл қатені анықтайды ма?

Алдымен біз сынақтарымызды жоспарлаймыз. Біз функцияның аргументі теріс болғанда немесе оның аргументі оң болғанда немесе оның аргументі нөлге тең болғанда функция дұрыс мәнді қайтаратынын білгіміз келеді. Тесттерді жоспарлағанда, сіз әрқашан «шекаралас» жағдайлар туралы мұқият ойланғыңыз келеді — мұнда 0 аргументі ```absolute_value``` функциясының әрекеті өзгеретін жердің шекарасында орналасқан және біз тараудың басында көргеніміздей, бұл бағдарламашы үшін қателесу оңай орын! Сондықтан біздің сынақ жинағымызға қосып қоятын жақсы бір мысал.

Біз бір сынақтың нәтижелерін тексеру үшін көмекші функцияны жазамыз. Ол логикалық аргументті қабылдайды және сынақтан өткені туралы хабарды басып шығарады немесе ол сынақтың сәтсіздігі туралы хабарлау үшін хабарды басып шығарады. Дененің бірінші жолы (функцияның docstring жолынан кейін) script-тегі шақыру жасалған жол нөмірін сиқырлы түрде анықтайды. Бұл кодтың қандай сынақтардан өткенін немесе өтпегенін анықтауға көмектесетін сынақтың жол нөмірін басып шығаруға мүмкіндік береді.

```python
import sys

def test(did_pass):
    """   Сынақ нәтижесін басып шығару.  """
    linenum = sys._getframe(1).f_lineno   # Шақырушы кодтың жол нөмірі.
    if did_pass:
        msg = "Test at line {0} ok.".format(linenum)
    else:
        msg = ("Test at line {0} FAILED.".format(linenum))
    print(msg)
```

Сондай-ақ, ```format``` әдісін қолданатын аздап күрделі жолды пішімдеу бар, біз оны қазір шолу жасап, болашақ тарауда егжей-тегжейлі қарастырамыз. Бұл функцияны жазып алған соң, біз сынақ жинағымызды құруды жалғастыра аламыз:

```python
def test_suite():
    """  Осы модульдегі (осы файл) кодқа арналған сынақтар жинағын іске қосыңыз.
    """
    test(absolute_value(17) == 17)
    test(absolute_value(-17) == 17)
    test(absolute_value(0) == 0)
    test(absolute_value(3.14) == 3.14)
    test(absolute_value(-3.14) == 3.14)

test_suite()        # Міне, сынақтарды орындауға шақыру
```

Мұнда сіз біздің сынақ жинағымызда бес сынақ құрастырғанымызды көресіз. Біз мұны ```absolute_value```-дің бірінші немесе екінші нұсқаларына (дұрыс нұсқалары) қарсы іске қоса аламыз және келесіге ұқсас нәтиже аламыз:

```python
Test at line 25 ok.
Test at line 26 ok.
Test at line 27 ok.
Test at line 28 ok.
Test at line 29 ok.
```

Бірақ функцияны келесідей қате нұсқаға өзгерттіңіз делік:

```python
def absolute_value(n):   # Қате нұсқасы 
    """ n абсолюттік мәнін есептеңіз """
    if n < 0:
        return 1
    elif n > 0:
        return n
```

Сіз осы кодта кем дегенде екі қате таба аласыз ба? Біздің сынақ жинағы ол қателерді табады! Мынаны аламыз:

```python
Test at line 25 ok.
Test at line 26 FAILED.
Test at line 27 FAILED.
Test at line 28 ok.
Test at line 29 FAILED.
```

Бұл _сынақтан өте алмайтын_ 3 сәтсіз жағдай мысалы.

Assert (растау) деп аталатын кіріктірілген Python амалы бар, ол біздің сынақ функциямызбен бірдей дерлік жұмыс жасайды (бірінші растау сәтсіз болғанда бағдарлама тоқтайды). Сіз бұл туралы оқып, оны сынақ функциямыздың орнына пайдаланғыңыз келуі мүмкін, танысып көріңіз

## 7.8 Өзгерткіш және таза функциялар

Аргумент ретінде тізімді қабылдайтын және оны орындау барысында өзгертетін функциялар өзгерткіш (**modifiers**) деп аталады, ал олардың өзгерістері жанама әсерлер (**side effects**) деп аталады. 

Таза функция (**pure function**) жанама әсерлер шығармайды. Таза функция шақырушы бағдарламамен тек параметрлер арқылы және қайтару ```return``` мәнімен ғана байланысады. Және таза функциялар параметрелерде өзгеріс жасамайды.

Тізімдегі элеметтерді екі еселейтін функция жазайық: 

```python
def double_stuff(values):
    """" Тізім мәндеріндегі элементтердің
    3 қосарлысын қамтитын жаңа тізімді қайтарыңыз."""

    new_list = []
    for value in values:
        new_elem = 2 * values
        new_list.append(new_elem)

    return new_list
```


```double_stuff``` бұл нұсқасы аргументтерін өзгертпейді:
```python
>>> things = [2, 5, 9]
>>> more_things = double_stuff(things)
>>> things
[2, 5, 9]
>>> more_things
[4, 10, 18]
```

Тағайындау үшін біз көрген ертерек ережеде «алдымен оң жағын бағалаңыз, содан кейін нәтиже мәнін айнымалыға тағайындаңыз» делінген. Сондықтан функция нәтижесін функцияға берілген айнымалыға тағайындау өте қауіпсіз:

```python
>>> things = [2, 5, 9]
>>> things = double_stuff(things)
>>> things
[4, 10, 18]
```

Алайда, ```double_stuff``` анықтамасын келесідей етіп өзгертсек: 

```python
def double_stuff(values):
    """" Орнындағы мәндердің элементтерін екі есе көбейтіңіз."""
    for index, value in enumerate(values):
        values[index] = 2 * value
```

Орындаған кезде мынандай нәтиже аламыз:

```python
>>> things = [2, 5, 9]
>>> more_things = double_stuff(things)
>>> things
[4, 10, 18]
>>> more_things
None
```

Біз бастапқы тізімнің өзгертілгенін көреміз, ал функция ештеңені қайтармайды. Бұл модификаторларды құру кезінде жақсы идея.

---

Қайсы әдіс жақсырақ?
Әдетте, таза функцияларды қолданған дұрыс. Өзгерткіш функциялардың әкелетін "қауіпті" нәтижесіне дайын болсаңыз және қолданылуына сенімді болсаңыз ғана пайдаланыңыз

---

# 7.9 Кеңестер, айла-амалдар және жиі кездесетін қателер

Бұл Python бастаушыларға пайдалы болуы мүмкін идеялардың, кеңестердің және жиі кездесетін қателердің шағын жиынтықтары.

## 7.10 Функциялар

Функциялар ойымыздағы мәселені бір код бөлігіне біріктіруге көмектеседі: олар бізге амалдарды жоғары деңгейлі мақсатта топтастыруға мүмкіндік береді, мысалы, элементтер тізімін сұрыптау функциясы, тасбақаны спираль салу функциясы немесе кейбір өлшемдердің орташа және стандартты ауытқуын есептеу функциясы. 

Функцияның екі түрі бар: жемісті, не нәтиже қайтаратын функиялар, олар _есептеуді жасайды және мән қайтарады_, және біз оларды қолданатын себебіміз де бізді қызықтыратын мәнді алу мақсатында. Void (бос, жеміссіз) функцияларының қолданылу себебі олар біз қалаған _әрекетті жасайды_ - мысалы тасбақаға тіктөртбұрыш сызғызу немесе алғашқы мың жай (prime) сандарды басып шығару. Олар _әрқашан_ ```None``` қайтарады — ерекше жалған мән.

---

Кеңес: **```None``` тіркес емес**

```None, True, False``` сияқты мәндер string емес: олар Python-дағы арнайы мәндер, және біз 2-ші тарауда берген кілтсөздер қатарына кіреді. Кілтсөздер бағдарламалау тілінде ерекше: олар тілдің синтаксистік құрамына кіреді. Сондықтан біз ```True``` деп аталатын мән немесе айнымалы жасай алмаймыз, біз ```Syntax Error``` қатесін аламыз.

---

Функциялардың нәтижелі/бос түрлерімен қатар Python-да қайтару ```return``` операторының екі нұсқасы бар: біреуі пайдалы мәнді қайтаратын, екіншісі ештеңені қайтармайтын немесе ```None```. Егер біз кез келген функцияның соңына жетсек және біз ешқандай ```return``` амалын нақты орындамаған болсақ, Python автоматты түрде ```None``` мәнін қайтарады.

---

Кеңес: **Функцияның нені қайтару керектігін түсініңіз**

Мүмкін, ештеңе — кейбір функциялар нәтижені есептеу және қайтару үшін емес, әрекеттерді орындау үшін ғана жасалады. Бірақ егер функция мәнді қайтаруы керек болса, оның барлық орындау жолдары мәнді қайтаратынына көз жеткізіңіз.

---

Функцияларды пайдалырақ ету үшін оларға _параметрлер_ беріледі. Осылайша, тасбақаға шаршы сызуға мүмкіндік беретін функцияның екі параметрі болуы мүмкін: біреуі сурет салу керек тасбақа үшін, екіншісі шаршы өлшемі үшін. 6-шы тараудағы бірінші мысалды (Функциялар) қараңыз — бұл функцияны кез келген тасбақамен және кез келген өлшемді шаршы үшін пайдалануға болады. Демек, бұл әрқашан бір тасбақаны, мысалы ```tess```-ті, және әрқашан бір шаршыны, мысалы 30 бірлік, салатын функцияға қарағанда әлдеқайда жалпы. 

---

Кеңес: **Функцияларды жалпылау үшін параметрлерді пайдаланыңыз**

Функцияның қай бөліктері қатаң кодталған және өзгермейтін болатынын түсініңіз және қандай бөліктер функцияны шақырушы арқылы реттелуі үшін параметрлерге айналуы керек.

---

---

Кеңес: **Біз осы сәтке дейін таныс болып, білетін идеяларға Python функцияларын байланыстыр**

Математикадан біз ```f(x) = 3x + 5``` сияқты функциялармен таныспыз. Біз ```f(3)``` функциясын шақырған кезде ```x``` параметрі мен 3 аргументі арасында қандай да бір ассоциация жасайтынымызды түсінеміз. Python-дағы аргумент беру осыған қалай ұқсас екенін ойлап көріңіз

---

Сұрақ: ```f(z) = 3z + 5``` функциясы жоғарыдағы ```f``` функциясымен бірдей ме?

## 7.11 Логикамен және басқару ағынымен байланысты мәселелер

Біз жиі тізімдегі кез келген элемент үшін қандай да бір шарт орындалатынын-орындалмайтынын білгіміз келеді, мысалы: «Тізімде тақ сандар бар ма?» Бұл жиі кездесетін қате:

```python
def any_odd(xs):            # Қате нұсқа
    """ xs бүтін сандар тізімінде тақ сан болса True деп қайтар"""
    for v in xs:
        if v % 2 == 1:
            return True
        else:
            return False
```

Мұндағы екі проблеманы байқай аламыз ба? Қайтаруды ```return``` орындаған сәтте біз функциядан шығамыз. "Егер мен тақ санды тапсам, True қайтара аламын" деген логика орынды. Дегенмен, біз тек бір элементті қарағаннан кейін ```False``` мәнін қайтара алмаймыз — егер біз барлық элементтерден өткен болсақ және олардың ешқайсысы тақ болмаса ғана ```False``` қайтара аламыз. Сондықтан 6-шы жол ол жерде болмауы керек, ал 7-ші жол циклден тыс болуы керек. Жоғарыдағы екінші мәселені табу үшін, бұл функцияны тізім бос болатын аргументпен шақырсаңыз, не болатынын қарастырыңыз. Міне, түзетілген нұсқасы:

```python
def any_odd(xs):            # Дұрыс нұсқа
    """ xs бүтін сандар тізімінде тақ сан болса True деп қайтар"""
    for v in xs:
        if v % 2 == 1:
            return True
    return False
```

Нәтижесі қандай болатынына көз жеткізгеннен кейін функциядан оралудың бұл «эврика» немесе «қысқа тұйықталу» стилі алғаш рет 5.2.1-бөлімде, Итерация тарауында көрсетілген.

Төменде кодтың тағы бір дұрыс жұмыс жасайтын нұсқасы келтірілген. Бірақ жоғарыдағы нұсқа жақсырақ нұсқасы:

```
sandar = [2, 4, 6, 9]

def any_odd(xs):            # жұмыс жасайтын өзге нұсқа
    """ xs бүтін сандар тізімінде тақ сан болса True деп қайтар"""
    count = 0
    for v in xs:
        if v % 2 == 1:
            count += 1      # тақ сандарды сана
    if count > 0:
        return True
    else:
        return False


print(any_odd(sandar))
```

Бұл жерде орындау тиімсіздігі бар - ол нәтижені ерте білсе де, бүкіл тізімді айналып өтеді.

---

Кеңес: **Функцияның return амалы туралы ойлан**

Маған барлық жағдайда барлық элементтерді қарау керек пе? Мен төте жолды таңдап, ертерек шығуға болады ма? Қандай жағдайларда? Тізімдегі барлық элементтерді қашан тексеруім керек?

---

6-шы және 9-шы жолдағы код та аздап туралана алады. ```count > 0``` өрнегінің өзі Boolean мән болып табылады, ```True``` немесе ```False``` (оның мәні ```True``` немесе ```False``` болып бағаланады деп айта аламыз). Осы ```True/False``` мәні тікелей ```print``` амалында қолданыла алады. Сондықтан жоғарыдағы кодты былай жаза аламыз: 

```python
numbers = [10, 5, 24, 8, 6]
count = 0
for number in numbers: 
    if number % 2 == 1:
        count += 1          # тақ сандарды сана
print(count > 0)            # Аха! Boolean өрнектері тек қана if амалында қолданылмайтынын 
                            # білетін программист
```

Бұл код қатаңырақ болса да, ол бірінші тақ сан табыла салысымен қысқа тұйықталуды қайтарған код сияқты жақсы емес.

Тіпті қысқарақ:

```python
numbers = [10, 5, 24, 8, 6]
count = 0
for number in numbers: 
    count += number % 2 == 1
print(count > 0)            # Аха! Boolean өрнектері тек қана if амалында қолданылмайтынын 
                            # білетін программист
```

Кеңес: Логикалық мәндерді пайдалануды жалпылаңыз (Tip: Generalize your use of Booleans)

Бағдарламашылар ```if is_prime(n) == True:``` деп жазбайды, оның орнына былай жазады ```if is_prime(n):```. Boolean мәндер туралы жалпылама ойлап үйреніңіз, тек ```if``` және ```while``` амалдарына байланыстырып емес. Арифметикалық өрнектер сияқты олардың да өзіндік операторлары (```and```, ```or```, ```not```) мен мәндері (```True```, ```False```) бар. Boolean қолдануды жетілдіру үшін тамаша ресурс [wikibooks/Python_Tutorial](https://en.wikibooks.org/wiki/Non-Programmer%27s_Tutorial_for_Python_3/Boolean_Expressions)


## 7.12 Жергілікті айнымалылар. Local variables

Функциялар шақырылады және олар жұмысын бастаған кезде жергілікті айнымалы мәндерді сақтайтын өздерінің стек қаңқасын жасайды. Жергілікті айнымалы – ағымдағы функция шақырылуына және жұмысына байланысты айнымалы мән. Функция қайтару жасаған сәтте (анық ```return``` амалы орындалып немесе Python соңғы амалға жеткеніне байланысты), стек қаңқасы және оның жергілікті айнымалы мәндері жойылады. Бұл жерден біздің түсінетініміз функция әртүрлі шықырулар арасында күйдің кез келген түрін есте сақтау үшін өзінің айнымалы мәндерін пайдалана алмайды. Ол қанша рет шақырылғанын санай алмайды немесе тасбақа сызатын түс көк не қызыл болуын анықтай алмайды, егер _ӘРИНЕ_ global айнымалы мәнін қолданбаса. Global айнымалылар функциямыздан шыққаннан кейін де сақталады, сондықтан олар шақырулар арасындағы ақпаратты сақтаудың дұрыс жолы болып табылады.

```python
sz = 2
def h2():
    """Әрбір шақыруда спиральдың келесі қадамын сызыңыз."""
    global sz
    tess.turn(42)
    tess.forward(sz)
    sz += 1
```

Бұл фрагмент біздің тасбақаны ```tess``` деп болжайды. Біз ```h2()``` функциясын шақырған сайын ол ```sz``` global айнымалысын үлкейтеді, сызады және бұрады. Айнымалыға тағайындау (7-ші жолдағы ```sz +=1```) жасасақ, және ```global``` амалын бермеген болсақ (4-ші жолдағыдай), Python біз жаңа жергілікті айнымалыны қалаймыз деп есептейді. Егер ```global``` амалын жазбай қалдырып кетсек, бұл код жұмыс жасамайды.

---

Кеңес: **Бағдарлама ағымы функциядан шыққан кезде жергілікті айнымалылар жойылады**

Функция шақырулары, стек frame-ы, жергілікті айнымалылар және функция қайтарулары туралы терең түсінік қалыптастыру үшін Python визуализаторын пайдаланыңыз. Оны Google-ден іздеп қараңыз

Кеңес: **Функция ішінде тағайындау жасау жергілікті айнымалы жасайды**

Функция ішіндегі айнымалыға кез келген тағайындау Python жергілікті айнымалыны жасайтынын білдіреді, тек ```global``` кілтсөзін пайдаланып қалмасақ.

---

## 7.13 Тіркестермен жұмыс жасау

* Бұл 7.13 бөлімді 8-ші тараудан кейін келіп оқысаңыз болады. 

Тіркестермен жұмыс жасайтын _шынымен_ маңызды төрт қана амал бар, және біз оларды жақсылап қолданып үйренсек, бізге керектің барлығын жасай аламыз. Әрине, өзге де "бар болса жақсы болар еді" дейтін, бағдарламалауды жеңлідедетін басқа да әдістер (methods) бар, бірақ осы қарастыратын төрт амалды жақсылап үйреніп алсақ оның өзі жақсы бастама. 

- ```len(str)``` - тіркестің ұзындығын табады
- ```str[i]``` - тармақша (subscript) операциясы жаңа тіркес ретінде тіркестің i'-ші таңбасын шығарады.
- ```str[i:j]``` - кесінді (slice) операциясы жолдан ішкі жолды шығарады.
- ```str.find(біз-іздейтін-сөз/әріп)``` - біз-іздейтін-сөз/әріп тіркестің ішінде орын алатын индексті қайтарады немесе ол табылмаса -1.

Мысалы "snake" тіркесі ```s``` тіркесінде substring ретінде бар ма деген сұраққа жауап іздесек, біз былай жаза аламыз:

```python
if s.find("snake") >= 0: ...

мына төмендегі нұсқасы да жұмыс жасайды. бұл Питонның жеңілдетілген дайын коды
if "snake" in s: ...
```

"Тіркесте «snake» _сөзі_ бар ма?" деп сұрақ қойылмаған болса, тіркесті сөздерге бөлу дұрыс болмас еді.

Бізден кейбір ақпараттар жазбасын оқып, бір функция анықтамасын табу сұралды делік, мысалы, ```def some_function_name(x, y):```, және бізге оны одан әрі оқшаулауды және функцияның атымен жұмыс істеуді сұрайды (мысалы оны басып шығаруымыз керек): 

```python
s = "..."       # Get the next line from somewhere
def_pos = s.find("def ") # Look for "def " in the line
if def_pos == 0: # If it occurs at the left margin
    op_index = s.find("(") # Find the index of the open parenthesis
    fnname = s[4:op_index] # Slice out the function name
    print(fnname) # ... and work with it.        
```

Бұл идеяларды ары қарай кеңейтуге болады:
- Егер функция ```def```-і бос орын қалдырылып жазылса және 0-ші жолда басталмаса не болар еді? Код аздаған түзетулерді талап етеді, және біз ```def_pos``` позициясының алдындағы бос орынның барлығы space екеніне нақты сенімді болуымыз керек. Біз келесідей мәнге қате әрекеттер жасағымыз келмейді: ```# I def initely like Python!```
- Біз 3-ші жолда ашық жақшаны табамыз деп болжадық. Біз оны жасағанымызды тексеру қажет болуы мүмкін!
- Біз сондай-ақ ```def``` кілт сөзі мен функция атауының басы арасында дәл бір бос орын бар деп болжадық. Бұл ```def   f(x)``` үшін сәйкес келмейді

Жоғарыда айтқанымыздай, тіркестермен оңай жұмыс істеуге мүмкіндік беретін көптеген «қантпен қапталған» әдістер бар. 

Тіркесті соңынан артқа қарай іздейтін ```find``` сияқты ```rfind``` әдісі бар. Егер біз бір нәрсенің соңғы пайда болуын тапқымыз келсе, бұл пайдалы. 

```lower``` (төменгі) және ```upper``` (жоғарғы) әдістері регистрді түрлендіруді жасай алады. 

Ал ```split``` (бөлу) әдісі тіркесті сөздер тізіміне немесе жолдар тізіміне бөлу үшін тамаша. 

Біз бұл кітапта ```format``` (пішім) әдісін де кеңінен қолдандық. 

Шындығында, егер біз Python құжаттамасын оқуды және кейбір жаңа әдістерді өз бетінше үйренгіміз келсе, string әдістері тамаша ресурс болып табылады.

Жаттығулар:

- Кез келген мәтін жолында «http://» деп басталып, жолдағы келесі бос орынмен аяқталатын ең көп дегенде бір ғана URL болуы мүмкін делік. Бар болса, осы URL-дің толық мекенжайын шығарып алу және басып шығару үшін код фрагментін жазыңыз. (Кеңес: ```find``` үшін құжаттаманы оқыңыз. Ол қосымша аргументтер қабылдайды, сондықтан ол іздейтін бастапқы нүктені орнатуға болады.)

- Тіркесте ең көбі бір «< . . . >” ішкі-тіркес (substring) бар делік. Бұрыштық жақшалар арасындағы тіркестің бөлігін шығарып алу және басып шығару үшін код фрагментін жазыңыз.


## 7.15 Глоссарий

**Логикалық функция / Boolean function**
Логикалық мәнді қайтаратын функция. ```bool``` түрінің жалғыз мүмкін мәндері - ```False``` және ```True```.

**сөйлесу жәшігі функциясы / chatterbox function**
Қажет емес кезде пайдаланушымен әрекеттесетін функция (енгізу немесе басып шығару арқылы). Кіріс аргументтерін шығыс нәтижелеріне түрлендіретін "дыбыссыз" функциялар әдетте ең пайдалы болып табылады.

**(функциялар) композициясы / composition (of functions)**
Бір функцияны басқасының денесінен шақыру немесе бір функцияның қайтару мәнін басқасының шақыруына аргумент ретінде пайдалану.

**dead code**
Ешқашан орындалмайтын бағдарламаның бөлігі, көбінесе ол қайтару операторынан кейін пайда болады.

**fruitful function / нәтижелі/жемісті функция**
```None``` емес, оның орнына қайтару мәнін беретін функция.

**incremental development / қадамдық жасақтау**
Бағдарламаны әзірлеу жоспары бір уақытта кодтың аз ғана мөлшерін қосу және сынау арқылы жөндеуді жеңілдетуге арналған.

**None**
Арнайы Python мәні. Python-да бір қолдану - бұл ```return``` аргументі болмайтын және қайтару амалын орындамайтын функциялар арқылы қайтарылады.

**қайтаратын мән / return value**
Функция шақыруының нәтижесі ретінде берілген мән.

**тіреуіштер / scaffolding**
Бағдарламаны әзірлеу кезінде әзірлеуге және жөндеуге көмектесетін код. Осы тарауда біз қосқан бірлік сынақ коды (unit test) scaffolding мысалдары болып табылады.

**уақытша айнымалы / temporary variable**
Күрделі есептеуде аралық мәнді сақтау үшін қолданылатын айнымалы.

**сынақ жинағы / test suite**
Сіз жазған кейбір кодқа арналған сынақтар жинағы.

**бірлік сынағы / unit testing**
Кодтың жеке бірліктерінің дұрыс жұмыс істеп тұрғанын тексеру үшін пайдаланылатын автоматты процедура. Сынақ жинағының болуы біреу кодты өзгерткенде немесе кеңейткенде өте пайдалы: ол бұрын жұмыс істеп тұрған кодқа жаңа қателерді енгізу арқылы кері кетуден сақтандырады. Регрессиялық тестілеу термині біз артқа кеткіміз келмейтін идеяны көрсету үшін жиі қолданылады!


## 7.16 Жаттығулар 

Әрбір жаттығуды орындағаннан кейін барлық сынақтардан өткенін растаңыз.

1. Төрт компас нүктесін «N», «E», «S» және «W» ретінде бір әріпті жолдармен қысқартуға болады. Осы төрт компас нүктесінің біреуін параметр ретінде қабылдайтын және келесі компас нүктесін сағат тілінің бағытымен қайтаратын ```turn_clockwiseу``` функциясын жазыңыз. Мұнда өту керек кейбір сынақтар:

```python
turn_clockwise("N") == "E"
turn_clockwise("W") == "N"
```

Сіз _"Функцияның аргументі басқа мән болса ше?"_ деп сұрауыңыз мүмкін. Барлық басқа жағдайлар үшін функция ```None``` мәнін қайтаруы керек:

```python
turn_clockwise(42) == None
turn_clockwise("rubbish") == None
```

2. 0-ден 6-ға дейінгі бүтін санды күннің атына түрлендіретін ```day_name``` функциясын жазыңыз. 0-ші күнді «Жексенбі» деп есептейік. Функцияның аргументтері жарамсыз болса, тағы да ```None``` қайтарыңыз. Мұнда өту керек кейбір сынақтар:

```python
test(day_name(3) == "Wednesday")
test(day_name(6) == "Saturday")
test(day_name(42) == None)
```

3. Күн атауы берілген және оның нөмірін қайтаратын ```day_num``` кері функциясын жазыңыз:

```python
day_num("Friday") == 5
day_num("Sunday") == 0
day_num(day_name(3)) == 3
day_name(day_num("Thursday")) == "Thursday"
```

Тағы да, егер бұл функцияға жарамсыз аргумент берілсе, ол ```None``` қайтаруы керек :

```python
day_num("Halloween") == None
```

4. «Бүгін сәрсенбі. Мен демалысқа 19 күннен кейін шығамын. Бұл аптаның қай күні болады?» деген сияқты сұрақтарға жауап беруге көмектесетін функцияны жазыңыз. Сондықтан функция күн атауын және ```delta``` аргументін — қосылатын күндер санын — алуы керек және нәтиже ретінде апта күнінің атауын қайтаруы керек:

Мысал және тест ретінде мынаны қараңыз:

```python
day_add("Monday", 4) == "Friday"
day_add("Tuesday", 0) == "Tuesday"
day_add("Tuesday", 14) == "Tuesday"
day_add("Sunday", 100) == "Tuesday"
```

_Кеңес: оны жазуға көмектесу үшін жоғарыда жазылған алғашқы екі функцияны пайдаланыңыз._

5. ```day_add``` функциясы теріс дельталармен жұмыс істей ала ма? Мысалы, кеше -1 немесе бір апта -7 бұрын болар еді:

```python
day_add("Sunday", -1) == "Saturday"
day_add("Sunday", -7) == "Sunday"
day_add("Tuesday", -100) == "Sunday"
```

Егер сіздің функцияңыз біз айтқанға дейін де теріс мәндермен жұмыс істеп тұрса, себебін түсіндіріңіз. Егер ол жұмыс істемесе, оны жұмыс істетіңіз.

_Нұсқау: Модуль % функциясын пайдаланудың кейбір жағдайларымен ойнаңыз (алдыңғы тараудың басында енгізілген). Атап айтқанда, x теріс болғанда x % 7 не болатынын зерттеңіз._

6. Айдың атын алып, айдағы күндер санын қайтаратын ```days_in_month``` функциясын жазыңыз . [Кібісе жылдарды](https://kk.wikipedia.org/wiki/%D0%9A%D1%96%D0%B1%D1%96%D1%81%D0%B5_%D0%B6%D1%8B%D0%BB%D1%8B) елемеуге болады:

```python
days_in_month("February") == 28
days_in_month("December") == 31
```

Егер функцияға жарамсыз аргументтер берілсе, ол ```None``` қайтаруы керек.

7. Сағаттарды, минуттарды және секундтарды жалпы секунд санына түрлендіретін ```to_secs``` функциясын жазыңыз. Мұнда өту керек кейбір сынақтар:

```python
to_secs(2, 30, 10) == 9010
to_secs(2, 0, 0) == 7200
to_secs(0, 2, 0) == 120
to_secs(0, 0, 42) == 42
to_secs(0, -10, 10) == -590
```

8. ```to_secs``` функциясын кіріс ретінде "шын өмірдегі" мәндерді алатындай етіп жетілдіріңіз. Ол әрқашан секундтардың бүтін санын қайтаруы керек (нөлге дейін қысқартылған):

```python
to_secs(2.5, 0, 10.71) == 9010
to_secs(2.433,0,0) == 8758
```

9. ```to_secs```-қа "кері" болатын мына үш функцияны жазыңыз:

- ```hours_in``` барлық берілген секундтағы бүтін санмен көрсетілген сағаттардың санын қайтарады.
- ```minutes_in``` сағаттар алынып тасталғаннан кейін жалпы секундтардағы қалған минуттардың бүтін санын қайтарады.
- ```seconds_in``` жалпы секунд санымен ұсынылған секундтардың қалғанын қайтарады.

Бұл функцияларға берілген секундтардың жалпы саны бүтін сан деп болжауға болады. Міне, кейбір сынақ жағдайлары:

```python
hours_in(9010) == 2
minutes_in(9010) == 30
seconds_in(9010) == 10
```

> Нені қалайтыны әрқашан анық бола бермейді...
> Жоғарыда келтірілген үшінші жағдайда талап біршама түсініксіз және анық емес болып көрінеді. Бірақ сынақ шын мәнінде не істеу керектігін түсіндіреді.
>
> Бірлік сынақтары көбінесе спецификацияларды нақтылаудың осы қосымша артықшылығына ие. Егер сіз өзіңіздің жеке сынақ жинақтарын жазсаңыз, шын мәнінде не болады деп 
> күткеніңіз және барлық ықтимал жағдайларды қарастырғаныңыз туралы сұрақтар қоя отырып, оны мәселені шешу процесінің бір бөлігі ретінде қарастырыңыз.
>
> Біздің кітабымыз « Қалай ойлау керек » деп аталатындықтан, сіз ойлау туралы кем дегенде бір анықтаманы және мәселені шешудегі негізгі ингредиент болып табылатын сұйық > интеллект сияқты қызықты идеялар туралы оқуды ұнатуыңыз мүмкін. Мысалы, http://psychology.about.com/od/cognitivepsychology/a/fluid-crystal.htm қараңыз . Информатиканы > үйрену үшін интеллекттің сұйық және кристалданған түрлерінің жақсы араласуы қажет.

10. Осы сынақтардың қайсысы сәтсіз? Себебін түсіндіріңіз.

```python
3 % 4 == 0
3 % 4 == 3
3 / 4 == 0
3 // 4 == 0
3+4 * 2 == 14
4-2+2 == 0
len("hello, world!") == 13
```

11. a > b болса 1 , а == b болса 0 және а < b болса -1 мәнін беретін салыстыру ```compare``` функциясын жазыңыз.

```python
compare(5, 4) == 1
compare(7, 7) == 0
compare(2, 3) == -1
compare(42, 1) == 1
```

12. Тік бұрышты үшбұрыштың екі катетінің ұзындықтары берілген гипотенузаның ұзындығын параметр ретінде қайтаратын гипотенуза ```hypotenuse``` деп аталатын функцияны жазыңыз:

```python
hypotenuse(3, 4) == 5.0
hypotenuse(12, 5) == 13.0
hypotenuse(24, 7) == 25.0
hypotenuse(9, 12) == 15.0
```

13. (x1, y1) және (x2, y2) нүктелері арқылы өтетін [түзудің көлбеуін](https://www.khanacademy.org/math/cc-eighth-grade-math/cc-8th-linear-equations-functions/8th-slope/a/slope-formula) қайтаратын ```slope(x1, y1, x2, y2)``` функциясын жазыңыз. ```slope``` функциясын мына мәндермен шақыру келесі сынақтардан өте алатынына көз жеткізіңіз:

```slope``` (көлбеу) [формуласы](https://www.khanacademy.org/math/cc-eighth-grade-math/cc-8th-linear-equations-functions/8th-slope/a/slope-formula) келесідей:

```slope = (y2 - y1) / (x2 - x1)```

```python
slope(5, 3, 4, 2) == 1.0
slope(1, 2, 3, 2) == 0.0
slope(1, 2, 3, 3) == 0.5
slope(2, 4, 1, 2) == 2.0
```

Содан кейін (x1, y1) және (x2, y2) нүктелері арқылы түзудің y-[кесіндісін](https://www.khanacademy.org/math/algebra/x2f8bb11595b61c86:forms-of-linear-equations/x2f8bb11595b61c86:intro-to-slope-intercept-form/a/introduction-to-slope-intercept-form) қайтаратын ```intercept(x1, y1, x2, y2)``` деп аталатын жаңа функцияда ```slope``` функциясын қолданып жазыңыз.

[Көлбеу-кесу формасы](https://www.khanacademy.org/math/algebra/x2f8bb11595b61c86:forms-of-linear-equations/x2f8bb11595b61c86:intro-to-slope-intercept-form/a/introduction-to-slope-intercept-form) дегеніміз не?

```python
y = mx + b
```

```python
intercept(1, 6, 3, 12) == 3.0
intercept(6, 1, 1, 6) == 7.0
intercept(4, 6, 12, 8) == 5.0
```

Бұл жаттығудың жауабын табу үшін [WikiHow](https://www-wikihow-com.translate.goog/Find-the-Y-Intercept?_x_tr_sl=en&_x_tr_tl=kk&_x_tr_hl=en&_x_tr_pto=wapp) сайтындағы мақаланы оқып түсініп алсаңыз көп көмегі болады. [En](https://www.wikihow.com/Find-the-Y-Intercept) WikiHow
2-ші тәсіл біздің жағдайға арналған.

14. Аргумент ретінде бүтін санды қабылдайтын және аргумент жұп сан болса ```True``` және тақ болса ```False``` мәнін қайтаратын ```is_even(n)``` деп аталатын функцияны жазыңыз.

Сынақ жиынтығына өз сынақтарыңызды қосыңыз.

15. Енді ```n``` тақ болғанда ```True``` мәнін, ал кері жағдайда ```False``` мәнін қайтаратын ```is_odd(n)``` функциясын жазыңыз. Бұл функция үшін бірлік сынақтарын да қосыңыз.

Соңында, оның аргументі тақ бүтін сан екенін анықтау үшін ```is_even``` шақыруын пайдаланатындай етіп өзгертіңіз және оның сынағы әлі де өткеніне көз жеткізіңіз.

16. Мына сынақтардан өтетін ```is_factor(f, n)``` функциясын жазыңыз:

Мұнда сізден талап етілетіні ```f``` саны ```n``` санының бөлшегі ме, яғни ```n``` саны ```f``` санына қалдықсыз бөліне ме деген сұрақ?

```python
is_factor(3, 12)
not is_factor(5, 12)
is_factor(7, 14)
not is_factor(7, 15)
is_factor(1, 15)
is_factor(15, 15)
not is_factor(25, 15)
```

Бірлік сынақтарының маңызды рөлі олар күтілетін нәрсенің бір мәнді «спецификациясы» ретінде әрекет ете алады. Бұл сынақ жағдайлары 1 және 15-ті 15-тің көбейткіштері ретінде қарастырамыз ба деген сұраққа жауап береді .

17. Мына бірлік сынақтарын қанағаттандыру үшін ```is_multiple``` деп аталатын функция жазыңыз:

 ```f``` саны ```n``` санының көбейтіндісі бола ала ма?
 
```python
is_multiple(12, 3)
is_multiple(12, 4)
not is_multiple(12, 5)
is_multiple(12, 6)
not is_multiple(12, 7)
```

```is_multiple``` анықтамасында ```is_factor``` пайдалану жолын таба аласыз ба?

18. Фаренгейттегі берілген температура үшін ең жақын Цельсий градусының бүтін мәнін қайтаруға арналған ```f2c(t)``` функциясын жазыңыз. ( кеңес: кірістірілген ```round``` функциясын пайдаланғыңыз келуі мүмкін. ```round.__doc__``` Python анықтамасын интернеттен не IDE-ден іздеп қарап алыңыз немесе ```round``` функция үшін анықтаманы іздеңіз және оның жұмыс істеу әдісі жайлы таныс болғанша онымен тәжірибе жасаңыз.)


```python
f2c(212) == 100 # Boiling point of water
f2c(32) == 0 # Freezing point of water
f2c(-40) == -40 # Wow, what an interesting case!
f2c(36) == 2
f2c(37) == 3
f2c(38) == 3
f2c(39) == 4
```

19. Енді керісінше орындаңыз: Цельсийді Фаренгейтке түрлендіретін ```c2f``` функциясын жазыңыз:

```python
c2f(0) == 32
c2f(100) == 212
c2f(-40) == -40
c2f(12) == 54
c2f(18) == 64
c2f(-48) == -54
```
