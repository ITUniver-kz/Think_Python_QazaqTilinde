---
title: Функциялар
isFree: true
---

# 6. Функциялар

## 6.1 Функциялар

Python тілінде функция - бұл, бір блокта жазылған амалдардың аталған тізбегі. Функцияның негізгі мақсаты - белгілі бір мәселе туралы ойымызді бір бағдарлама бөлігіне жинастыру.

Функцияны қолдану және шақырудан бұрын ол әрине анықталу керек.

Функция анықтамасының синтаксисі:

```python
def NAME ( PARAMETERS ):
    STATEMENTS
```

Біз өзіміз жасайтын функциялар үшін кез келген атауларды жасай аламыз, тек Python кілт сөзі болып табылатын атауларды пайдалана алмаймыз және атаулар заңды идентификаторларға арналған ережелерге сай болуы керек.

Функция ішінде амалдың кез келген саны болуы мүмкін, бірақ олар ```def```-тің ішінде және бос орын қалып жазылуы керек. Осы кітаптағы мысалдарда біз төрт бос орын стандартты шегінісін (indentation) қолданамыз. Функция анықтамалары біз көретін бірнеше **құрама амалдардың** (compound statements) екіншісі болып табылады, олардың барлығында бірдей үлгі бар:
1. Кілт сөзден басталып, қос нүктемен аяқталатын басты жолы.
2. Бір немесе бірнеше Python амалдарынан тұратын **дене / body**, амалдардың әрқайсысы бірдей бос орын шегініспен жазылады — _Python мәнерінің нұсқаулығы_ басты жолдан 4 бос орынды ұсынады.

Біз осы үлгіге сәйкес келетін ```for``` циклін көрдік. 

Сонымен, функция анықтамасына қайта қарасақ, басты жолдағы кілт сөз **```def```** болып табылады, одан кейін функцияның аты және жақшаға алынған кейбір _параметрлер_ келеді. Функциядағы параметрлер тізбегі бос болуы мүмкін немесе бір-бірінен үтірмен бөлінген параметрлердің кез келген санын қамтуы мүмкін. Параметрлер болса да, болмаса да жақшалар қажет. Параметрлер жаңа функцияны пайдалану үшін оны қандай ақпаратпен қамтамасыз ету керектігін анықтайды.

Біз тасбақалармен жұмыс істеп жатырмыз делік және бізге қажет қарапайым операция - шаршыларды салу. «Шаршы сызу» - бұл бірнеше кішірек қадамдардан тұратын _абстракция_ немесе ой бөлігі. Сонымен, осы «құрылыс блогының» үлгісін алу үшін функция жазайық:

```python
import turtle

def draw_square(t, qadam):
    """t тасбақасына, мынанша qadam шаршыны сал деп айту"""
    for i in range(4):
        t.forward(qadam)
        t.left(90)


window = turtle.Screen()        # Терезені және ойын атрибуттарын жасау
window.bgcolor("light green")
window.title("Alex meets a function")

alex = turtle.Turtle()      # alex-ті жасау
draw_square(alex, 50)       # Шаршыны салу үшін draw_square функциясын шақыру
window.mainloop()
```

![alex meets function](https://user-images.githubusercontent.com/84173441/172094581-04bc183b-6d55-4f6c-b02c-d3df9a8b5270.JPG)

Бұл функция ```draw_square``` деп аталады . Oның екі параметрі бар: біреуі функцияға қайсы тасбақа қозғалатынын айтады, екіншісі оған біз сызғымыз келетін шаршының өлшемін айтады. Функцияның негізгі бөлігі қайда аяқталатынын білетініңізге көз жеткізіңіз — бұл шегініске байланысты және бос жолдар бұл мақсат үшін есептелмейді!

> **Құжаттамаға арналған құжат жолдары**
> Функция басты жолынан төменгі бірінші қатар ```тіркес``` болса, ол **құжат тізбегі / docstring**  ретінде қарастырылады және Python тілінде және кейбір бағдарламалау құралдарында арнайы өңдеуден өтеді. Мысалы, PyScripter бағдарламасында кірістірілген функция атауын  ашық жақшамен терген кезде, функцияның қандай аргументтерді алатынын көрсететін құралдар кеңесі пайда болады және ол бізге құжат жолындағы (docstring) кез келген өзге де мәтінді көрсетеді.
>
> Docstrings Python-дағы функцияларды құжаттаудың негізгі әдісі және құжаттама жасау өте маңызды. Өйткені біздің функциямызды кім шақырса да, функцияда не болып жатқанын немесе оның қалай жұмыс істейтінін білу қажеттілігі миндетті емес; олар біздің функциямыз қандай аргументтерді алатынын, оның не істейтінін және күтілетін нәтиженің қандай екенін білсе жеткілікті. Функцияның ішкі детальдарын білмей-ақ, функцияны қолдана алса болды. Бұл, біз кейін толығырақ айтатын абстракция тұжырымдамасына сәйкес келеді.
>
> Құжат жолдары әдетте үш тырнақшалы тіркестер арқылы жасалады, өйткені олар кейінірек бір жолдан көп жазғымыз келсе, құжат жолын оңай кеңейтуге мүмкіндік береді.
>
> Түсініктемелерден ерекшелігі сол, функцияның құжат жолын (docstring-ті) орындау уақытында Python құралдары арқылы алуға болады. Керісінше, бағдарлама талдау (parsing) кезінде түсініктемелер толығымен жойылады.
   
Жаңа функцияны анықтап, жазып қоя салу функцияны іске қоспайды. Ол үшін бізге **функция шақыруы / function call** қажет. 

Біз **print , range** және **int** сияқты кейбір кірістірілген функцияларды қалай шақыру керектігін көрдік. Функция шақыруларында орындалатын функцияның аты, одан кейін функция анықтамасындағы параметрлерге тағайындалған _аргументтер_ деп аталатын мәндер тізімі болады. 

Сонымен, бағдарламаның екінші соңғы жолында біз функцияны шақырамыз және ```alex```-ті басқарылатын тасбақа ретінде және 50-ді біз қалаған шаршының өлшемі ретінде береміз. Функция орындалып жатқанда, ```qadam``` айнымалысы 50 мәніне, ал ```t``` айнымалысы дәл ```alex``` айнымалысы сілтеме жасайтын тасбақа инстанциясына сілтеме жасайды. (```t``` және ```alex``` айнымалылары бір мәнге сілтеме жасайды)

Функцияны анықтағаннан кейін біз оны қалауымызша шақыра аламыз және оның амалдары біз оны шақырған сайын орындалады. Біз оны кез келген тасбақамыз шаршы сызу үшін пайдалана аламыз. Келесі мысалда біз ```draw_square``` функциясын аздап өзгерттік және кейбір өзгерістері бар 15 квадрат салу үшін ```tess```-ті пайдаланамыз.

```python
import turtle

def draw_multicolor_square(t, qadam):
    """Тасбақа t-мен sz өлшеміндегі шаршыларды салу"""
    for i in ["red", "purple", "hotpink", "blue"]:
        t.color(i)
        t.forward(qadam)
        t.left(90)

wn = turtle.Screen()        # Терезені және оның атрибуттарын орнату
wn.bgcolor("lightgreen")

tess = turtle.Turtle()      # tess-ті жасаңыз және кейбір атрибуттарын орнатыңыз
tess.pensize(3)
tess.shape("turtle")

qadam = 20                   # Ең кіші шаршының өлшемі
for i in range(15):
    draw_multicolor_square(tess, qadam)
    qadam = qadam + 10        # келесі шаршының өлшемі 10-ға үлкейеді
    tess.forward(10)        # tess-ті аздап алға жылжыту
    tess.right(18)          #    ... және аздап бұру

wn.mainloop()
```

![tess_draws](https://user-images.githubusercontent.com/84173441/172103227-75b8e371-2cc1-4267-99d3-22ae3364b09e.JPG)

## 6.2 Функциялар басқа функцияларды шақыра алады 

Енді біз тіктөртбұрыш салу үшін функция жазғымыз келеді делік. Біз функцияны ені мен биіктігі үшін әртүрлі аргументтермен шақыра алуымыз керек. Ал шаршы жағдайынан айырмашылығы, біз бір нәрсені 4 рет қайталай алмаймыз, өйткені төрт жағы тең емес.

Сонымен, біз тіктөртбұрыш салуға болатын өте жақсы кодты ойлап табамыз.

```python
def draw_rectangle(t, w, h):
    """Ені w және 
    биіктігі h тіктөртбұрышын салу үшін t тасбақасын алыңыз."""
    for i in range(2):
        t.forward(w)
        t.left(90)
        t.forward(h)
        t.left(90)
```

Және осы кодты тасбақамен сурет салуға қолданатын болсақ:

```python
def draw_rectangle(t, w, h):
    """Ені w және
    биіктігі h тіктөртбұрышын салу үшін алыңыз тасбақа t-ді алыңыз."""
    for i in range(2):
        t.forward(w)
        t.left(90)
        t.forward(h)
        t.left(90)


import turtle

window = turtle.Screen()
window.bgcolor("light green")

tess = turtle.Turtle()
tess.pensize(3)

qadam = 20

draw_rectangle(tess, 60, 100)

window.mainloop()
```

Параметр атаулары дұрыс түсіну үшін әдейі жалғыз әріптер ретінде таңдалады. Нақты бағдарламаларда, бізде көбірек тәжірибе болғаннан кейін, біз бұдан дұрыстау айнымалы атауларын таңдап жазамыз. Бірақ мәселе мынада: бағдарлама біздің тіктөртбұрышты сызып жатқанымызды немесе параметрлер ені мен биіктігін көрсететінін «түсінбейді». Тіктөртбұрыш, ені және биіктік сияқты ұғымдар бағдарлама немесе компьютер түсінетін ұғымдар емес, біз адамдарда бар мағына болып табылады.

_Компьютер ғалымы сияқты ойлау_ заңдылықтар мен қарым-қатынастарды іздеуді қамтиды. Жоғарыдағы кодта біз мұны белгілі бір дәрежеде жасадық. Біз тіктөртбұрыштың жай ғана төрт жағын сызбадық. Oның орнына біз тіктөртбұрышты екі жарты етіп салуға болатынын байқадық және бұл үлгіні екі рет қайталау үшін циклды қолдандық.

Бірақ енді шаршының тіктөртбұрыштың ерекше түрі екенін байқаймыз. Бізде тіктөртбұрышты сызатын функция бар, сондықтан біз оны шаршыны салу үшін пайдалана аламыз.

```python
def draw_rectangle(t, w, h):
    """Ені w және
    биіктігі h тіктөртбұрышын салу үшін алыңыз тасбақа t-ді алыңыз."""
    for i in range(2):
        t.forward(w)
        t.left(90)
        t.forward(h)
        t.left(90)


def draw_square(tx, sz):  # draw_square функциясының жаңа нұсқасы
    draw_rectangle(tx, sz, sz)


import turtle

window = turtle.Screen()
window.bgcolor("light green")

tess = turtle.Turtle()
alex = turtle.Turtle()

tess.pensize(3)
alex.pensize(1)

alex.color("white")

qadam = 20

draw_square(tess, 150)

draw_rectangle(alex, 150, 150)

window.mainloop()
```

Кодтың мына бөлігіне баса назар аударыңыз: 

```python
def draw_square(tx, sz):        # draw_square функциясының жаңа нұсқасы
    draw_rectangle(tx, sz, sz)
```

Мұнда назар аударатын кейбір жайттар бар:

- Функциялар басқа функцияларды шақыра алады.
- ```draw_square``` функциясын қайта жазу шаршылар мен тіктөртбұрыштар арасындағы біз байқаған қатынасты көрсетеді.
- Бұл функцияны шақырушы ```draw_sqare(tess, 50)``` деп жазуы мүмкін. Бұл функцияның ```tx``` және ```sz``` параметрлеріне ```tess``` объектісі және ```int``` 50 тағайындалады.
- Функцияның денесінде олар кез келген басқа айнымалы сияқты.
- ```draw_square``` шақырылғанда, алдымен ```tx``` және ```sz``` айнымалыларындағы мәндер алынады, содан кейін шақыру орын алады. ```draw_rectangle``` функциясының жоғарғы жағына кіргенде, оның айнымалысы ```t```-ға ```tess``` обьектісі тағайындалады және сол функциядағы ```w``` және ```h``` екеуіне 50 мәні беріледі.

Дәл қазір бұл жаңа функцияларды жаза бергеннен не пайда бар деп ойлауыңыз мүмкін. Шын мәнінде оның себептері көп, бірақ біздің мысалдар екеуін көрсетеді:
1. Жаңа функция жасау бізге амалдар тобын атау мүмкіндігін береді. Функциялар күрделі есептеуді бір команданың астына жасыру арқылы бағдарламаны жеңілдетеді. Функция (атымен бірге) мәселенің ақыл-ой түйінін немесе _[абстракциясын](https://kk.wikipedia.org/wiki/%D0%90%D0%B1%D1%81%D1%82%D1%80%D0%B0%D0%BA%D1%86%D0%B8%D1%8F)_ жасайды.
2. Жаңа функция жасау қайталанатын кодты жою арқылы бағдарламаны кішірейте алады.

Біз күткендей, функцияны орындамас бұрын оны жасауымыз керек. Басқаша айтқанда, функцияның анықтамасы функция шақырылмас бұрын орындалуы керек.

## 6.3 Oрындалу ағыны / Flow of execution

Функцияны пайдаланбас бұрын оның анықталғанына көз жеткізу керекпіз, ол үшін біз амалдардың орындалу ретін білуіміз керек, ол **орындалу ағыны / flow of execution** деп аталады. Біз бұл туралы алдыңғы тарауда біраз айттық.

Орындау әрқашан бағдарламаның бірінші операторынан басталады. Амалдар жоғарыдан төменге қарай бір-бірден орындалады.

Функцияны жәй ғана бағдарламаның ішінде жазып қою бағдарламаның орындалу ағынын өзгертпейді, және функцияның ішіндегі амалдар функция шақырылмайынша орындалмайтынын есте сақтаңыз. Бұл кең таралған болмаса да, біз бір функцияны екіншісінің ішінде анықтай аламыз. Бұл жағдайда ішкі анықтама сыртқы функция шақырылмайынша орындалмайды.

Функцияны шақыру үлкен трассадағы айналма жол сияқты. Келесі операторға өтудің орнына, ағын шақырылған функцияның бірінші жолына секіреді, сол жерде барлық амалдарды орындайды, содан кейін тоқтаған жерінен жалғастыру үшін "трассаға" қайтып келеді.

Бұл оңай көрінгенмен, бір функция өзінің ішінде өзге функцияны шақыра алатынын ескеруіміз керек. Бір функсяның ортасында болған кезде, бағдарлама басқа функциядағы амалдарды орындауы керек болуы мүмкін. Бірақ бұл жаңа функцияны орындау кезінде бағдарлама тағы бір функцияны орындауы керек болуы мүмкін!

Бақытымызға орай, Python ағымның қай жерде екенін қадағалай алады, сондықтан оны шақырған функция аяқталған кезде бағдарлама тоқтаған жерінен жалғастырылады. Бағдарламаның соңына жеткенде ол жұмысын аяқтайды.

Бұл сұмдық ертегінің моральдық мәні неде? Сіз бағдарламаны оқығанда, жоғарыдан төменге қарай оқымаңыз. Оның орнына _орындалу ағынын_ қадағалаңыз.

> **Орындалу ағынын өзіңіз бақылап көріңіз**
> 
> PyScripter-де біз кез келген бағдарламаның орындалу ағынын «бір қадам» арқылы бақылай аламыз. PyScripter кодтың әрбір жолын орындалуға жақын қалғанда ерекшелейді.
> 
> PyScripter сонымен қатар тінтуірді бағдарламадағы кез келген айнымалының үстіне апаруға мүмкіндік береді және ол осы айнымалының ағымдағы мәнін ашады. Oсылайша, бұл бағдарламаның «күй суретін» — бағдарламаның айнымалыларына тағайындалған ағымдағы мәндерін көруді жеңілдетеді.
> 
> Бұл әр қадамда не болып жатқанын терең және мұқият түсінуді қалыптастырудың жақсы механизмі. _Бір қадам_ мүмкіндікті жақсы пайдалануды үйреніңіз және ойша белсенді болыңыз: кодпен жұмыс жасай отырып, әр қадам алдында өзіңізді сынап көріңіз: «Бұл жол бағдарламадағы кез келген айнымалыларға қандай өзгерістер енгізеді?» және «Oрындау ағыны әрі қарай қайда кетеді?»
> 
> Артқа оралып, 15 түрлі-түсті шаршы сызатын жоғарыдағы бағдарламада _бір қадам_ қалай жұмыс істейтінін көрейік. Біріншіден, біз import амалының астына бір сиқырлы жолды қосамыз — бұл өте қажет емес, бірақ бұл біздің жағдайды әлдеқайда жеңілдетеді, өйткені ол тасбақа коды бар модульге кіріп кетуден шектейді.

```python
import turtle
__import__("turtle").__traceable__ = False
```

>
> Енді біз бастауға дайынбыз. Тінтуір курсорын біз тасбақа экранын жасайтын бағдарламаның жолына қойып, F4 пернесін басыңыз. Бұл Python бағдарламасын тек курсор орналасқан жолға дейін іске қосады. Біздің бағдарлама қазір «үзіледі» және келесі орындалатын жолды бөлектеп көрсетеді, мысалы былай:
> 
![debug](https://user-images.githubusercontent.com/84173441/172139944-9543b8cd-00f6-49e1-a673-1846dc2b384e.JPG)
>
> Бұл кезде код арқылы бір қадам жасау үшін F7 пернесін (қадамға) қайта-қайта басуға болады. 10, 11, 12, ... жолдарды орындалған кезде тасбақа терезесі қалай жасалатынын, оның кенеп түсі қалай өзгеретінін, тақырып қалай өзгеретінін, кенепте тасбақа қалай жасалғанын, содан кейін орындалу ағынын бақылаңыз: циклге, одан функцияға және функцияның цикліне түседі, содан кейін сол цикл денесі арқылы қайта-қайта түседі.
> 
> Бұл әрекетті орындаған кезде біз тінтуірді бағдарламадағы кейбір айнымалылардың үстіне апарып, олардың мәндері болып жатқан жағдайдың тұжырымдамалық үлгісіне сәйкес келетінін растай аламыз.
>
> Бірнеше циклден кейін, біз 20-жолды орындағалы жатқанда және жалықтыра бастағанда, біз шақырып жатқан функцияны «үстінен өту» үшін F8 пернесін пайдалана аламыз. Бұл функциядағы барлық амалдарды орындайды, бірақ әрқайсысы арқылы өтудің қажеті жоқ. Бізде әрқашан «детальға бару» немесе «жоғары деңгейлі көріністі алу» және функцияны бір бөлік ретінде орындау таңдауы бар.
>
> Кейбір басқа опциялар бар, соның ішінде әрі қарай бір қадамдамай орындауды бірден жалғастыруға мүмкіндік беретін _resume_ функциясы. Оларды PyScripter _Run_ мәзірінен табыңыз.

## 6.4 Аргументтерді қажет ететін функциялар

Көптеген функциялар аргументтерді қажет етеді: аргументтер жалпылауды (gerneralization - кейін кең танысасыздар) қамтамасыз етеді. Мысалы, санның абсолютті мәнін тапқымыз келсе, ол қандай сан екенін көрсетуіміз керек. Python абсолютті мәнді есептеуге арналған кірістірілген функцияға ие:

```python
>>> abs(5)
5
>>> abs(-5)
5
```

Бұл мысалда ```abs``` функциясының аргументтері 5 және -5 болып табылады..

Кейбір функциялар бірнеше аргумент қабылдайды. Мысалы, кірістірілген функция ```pow``` екі аргументті, негіз және дарежені қабылдайды. Функция ішінде, берілген мәндер **параметрлер** деп аталатын айнымалыларға тағайындалады.

```python
>>> pow(2, 3)
8
>>> pow(7, 4)
2401
```

Бірден көп аргумент қабылдайтын тағы бір кірістірілген функция - ```max```.

```python
>>> max ( 7 ,  11 ) 
11 
>>> max ( 4 ,  1 ,  17 ,  2 ,  12 ) 
17 
>>> max ( 3  *  11 ,  5 ** 3 ,  512  -  9 ,  1024 ** 0 ) 
503
```

max функциясына үтірмен бөлінген аргументтердің кез-келген санын беруге болады және ең үлкен берілген мәнді қайтарады. Аргументтер қарапайым мәндер немесе өрнектер болуы мүмкін. Соңғы мысалда 503 қайтарылады, себебі ол 33, 125 және 1-ден үлкен.

## 6.5 Мәндерді қайтаратын функциялар

Жоғарыдағы барлық функциялар мәндерді қайтарады. Oған қоса, ```range, int, abs``` сияқты функциялар күрделірек өрнектерді құру үшін пайдаланылуы мүмкін мәндерді қайтарады.

Бұл функциялардың ```draw_square``` сияқты функциялардан маңызды айырмашылығы мынада: ```draw_sqare``` біз оның мәнді есептегенін қалаған үшін орындалмай қалған жоқ,  — керісінше, біз ```draw_square``` функциясын жаздық, өйткені оның тасбақаның сурет салуына себеп болатын қадамдар тізбегін орындауын қаладық.

Мәнді қайтаратын функция бұл кітапта **жемісті, нәтижелі функция / fruitful function** деп аталады. Нәтижелі функцияның қарама-қарсы түрі **бос функция / void function** — нәтижесі мән болуы үшін емес, пайдалы нәрсе жасайтындықтан орындалатын функция. (Java, C#, C және C++ сияқты тілдер «жарамсыз функция» терминін пайдаланады, Паскаль сияқты басқа тілдер оны процедура **procedure** деп атайды.) Void функциялар алынған мән үшін орындалмаса да, Python әрқашан бір нәрсені қайтаруы керек. Сонымен, егер бағдарламашы мәнді қайтаруды ұйымдастырмаса, Python автоматты түрде ```None``` мәнін қайтарады.

Өзіміздің нәтижелі функциямызды қалай жазамыз? 2-ші тараудың соңындағы жаттығуларда күрделі пайыздың стандартты формуласын көрдік, оны енді нәтижелі функция ретінде жазамыз:

![compound](https://user-images.githubusercontent.com/84173441/172148925-b3f84781-518a-4c85-bab7-fd38a8d69d66.JPG)

P = негізгі қаражат / бастапқы инвестиция
r = жылдық номиналды пайыз мөлшерлемесі
n = пайыздар жылына қанша рет қосылды
t = жылдар саны

```python
def final_amt(p, r, n, t):
    """ Соңғы соманы шығару P-ге күрделі пайыз формуласын қолданыңыз."""
    a = p * (1 + r/n) ** (n*t)
    return a         # Бұл (return) жаңа нәрсе және функцияны нәтижелі етеді.



# енді бізде жоғарыдағы функция болғандықтан, оны шақырайық.

toInvest = float(input("Қанша теңге инвестиция салғыңыз келеді??"))

fnl = final_amt(toInvest, 0.08, 12, 5)

print("Сізде мерзімнің соңында", fnl, "теңге болады")
```

- ```a = p * (1 + r/n) ** (n*t)``` өрнегінен кейін **return** (қайтару) амалы жазылған. Бұл өрнек бағаланады және шақырушыға осы функцияны шақырудың «жемісі» ретінде қайтарылады.
- Біз пайдаланушыдан негізгі соманы сұрадық. ```toInvest``` дерек түрі тіркес болып табылады, бірақ онымен жұмыс істеу үшін бізге сан қажет. Бұл ақша болғандықтан және ондық таңбалары болуы мүмкін болғандықтан, жолды өңдеу және float мәнді қайтару үшін ```float``` түрлендіргіш функциясын қолдандық.

- 5 жыл бойы жылына 12 рет қосылатын 8% пайыз үшін аргументтерді қалай енгізгенімізге назар аударыңыз.

- Бұл кодты іске қосқан кезде біз нәтиже аламыз 

> _Сізде мерзімнің соңында 14898,457083 теңге болады_.

_Бөлшек сандар біршама шатастыратын болар, бірақ Python біздің ақшамен жұмыс істеп жатқанымызды түсінбейтінін есте сақтаңыз: ол дөңгелектеусіз тек мүмкіндігінше есептеуді жасайды. Кейінірек біз басып шығару алдында екі ондық таңбаға дейін жақсы дөңгелектенетін етіп басып шығарылатын жолды қалай пішімдеу керектігін көреміз._

- ```toInvest = float(input("Қанша теңге инвестиция салғыңыз келеді??"))``` жолы композицияның тағы бір мысалын көрсетеді  — біз float сяқты функцияны шақыра аламыз және оның аргументтері біз бірге шақырған басқа функция шақыруларының нәтижелері болуы мүмкін (мысалы, ```input```).

Мұнда тағы бір маңызды нәрсеге назар аударыңыз. Біз аргумент ретінде беретін ```toInvest``` айнымалының атауы, ```p``` — параметрдің атымен ешқандай байланысы жоқ. 
```final_amt``` шақырылғанда, ```p = toInvest``` сияқты болады. Шақырушыда мәннің қандай аталғаны маңызды емес, ```final_amt``` ішінде оның аты ```p``` болып табылады.

Бұл қысқа айнымалы атаулары өте қиын болып барады, сондықтан оның орнына осы нұсқалардың бірін таңдаған болар едік:

```python
def final_amount_v2(principal_amount, nominal_percentage_rate, num_times_per_year, years):
    a = principal_amount * (1 + nominal_percentage_rate / num_times_per_year) ** (num_times_per_year*years)
    
    return a
    
    
def final_amount_v3(amount, rate, compounded, years):
    a = amount * (1 + rate/compounded) ** (componded*years)
    return a
    
    
def final_amount_v4(amount, rate, compounded, years):
    """
    The a in final_amount_v3 was a useless asignment.
    We might as well skip it.
    """
    
    return amount * (1 + rate/compounded) ** (componded*years)
```

Олардың барлығы бірдей нәрсені жасайды. Басқа адамдарға жақсы түсінуге болатын код жазу үшін өз пайымдауыңызды пайдаланыңыз! Қысқа айнымалы атаулары үнемді және кейде кодты оқуды жеңілдетеді: Эйнштейн ұзағырақ айнымалы атауларды пайдаланған болса, E = mc 2 есте қаларлықтай болмас еді! Ал егер қысқа атауларды қаласаңыз, айнымалылардың не үшін пайдаланылатыны туралы оқырманға түсініктеме беру үшін сізде де кейбір ақпараттың бар екеніне көз жеткізіңіз.

## 6.6 Айнымалылар мен параметрлер жергілікті

Функция ішінде **жергілікті айнымалыны / local variable** жасағанда, ол тек функцияның ішінде болады және біз оны сыртында пайдалана алмаймыз. Мысалы, бұл функцияны қайта қарастырыңыз:

```python
def final_amt(p, r, n, t):
    a = p * (1 + r/n) ** (n*t)
    return a


print(a)
```

```a```-ны функция сыртында қолданбақ болғанда біз қате аламыз.

```python
Traceback (most recent call last):
  File "C:\Users\abay_ongar\PycharmProjects\chapter_3_tasbaqalar\app.py", line 6, in <module>
    print(a)
NameError: name 'a' is not defined
```

```a``` айнымалысы ```final_amt``` үшін жергілікті болып табылады және функциядан тыс көрінбейді. Біз оны сыртта қолдана алмаймыз.

Oған қоса, ```а``` тек функция орындалып жатқанда ғана болады — біз оны оның **қызмет ету мерзімі / lifetime** деп атаймыз. Функцияның орындалуы аяқталған кезде жергілікті айнымалылар жойылады.

Параметрлер де жергілікті болып табылады және жергілікті айнымалылар сияқты әрекет етеді. Мысалы, ```p, r, n, t``` өмір сүру уақыты ```final_amt``` шақырылғанда басталады және функция өзінің орындалуын аяқтаған кезде жойылады.

Сондықтан, функция, кейбір мәнге жергілікті айнымалыны тағайындап, орындалуын аяқтап, содан кейін келесі жолы қайта шақырылған кезде жергілікті айнымалының мәнін қалпына келтіру мүмкін емес. Функцияның әрбір шақырылуы жаңа жергілікті айнымалылар жасайды және функция шақырушыға оралған кезде олардың қызмет ету мерзімі аяқталады.

## 6.7 Тасбақаларға қайта оралсақ

Енді бізде нәтижелі функциялар бар, олай болса кодты ойымыздағы жинақтауға сәйкес етіп жазып көрейік. Бұлай кодты қайта реттеу процесі **рефакторинг** деп аталады.

Тасбақалармен жұмыс істегенде біз әрқашан істегіміз келетін екі нәрсе – тасбақа үшін терезе жасау және бір немесе бірнеше тасбақаларды жасау. Болашақта бұл тапсырмаларды жеңілдету үшін кейбір функцияларды жаза аламыз:

```python
import turtle

def make_window(color, title):
    """
       Set up the window with the given background color and title.
       Returns the new window.
    """
    window = turtle.Screen()
    window.bgcolor(color)
    window.title(title)
    return window
    
def make_turtle(color, size):
    """
       Set up a turtle with the given color and pensize.
       Returns the new turtle.
    """
    animal = turtle.Turtle()
    animal.color(color)
    animal.pensize(size)
    return animal
    
window = make_window("lightgreen", "Tess and Alex dancing")
tess = make_turtle("hotpink", 5)
alex = make_turtle("black", 1)
dave = make_turtle("yellow", 2)
```

Кодты рефакторингке қатысты трюк функцияны шақырған сайын қандай нәрселерді өзгерткіміз келетінін болжау болып табылады: олар біз жазатын функциялардың параметрлері немесе өзгермелі бөліктері болуы керек.

## 6.8 Глоссарий

**аргумент / arugment**
Функция шақырылған кезде функцияға берілетін мән. Бұл мән функциядағы сәйкес параметрге тағайындалады. Сондай-ақ аргумент операторларды, операндтарды және басқа нәтижелі функцияларға шақыруды қамтуы мүмкін өрнектің нәтижесі болуы мүмкін.

**дене /body**
Құрама амалдардың екінші бөлігі. Бастапқы жолдан бірдей мөлшерде шегініс жасалған амалдар тізбегінен тұрады. Python қауымдастығында қолданылатын шегіністің стандартты мөлшері - 4 бос орын.

**құрама амалдар / compound statement**
Екі бөліктен тұратын амал:

1. басты жол – амал типін анықтайтын кілт сөзден басталып, қос нүктемен аяқталады.
2. негізгі мәтін / body / дене - басты жолдан бірдей шамаға шегініс жасалған бір немесе бірнеше амалды қамтитын блок.

Құрама амалдың синтаксисі келесідей болады:

```python
keyword ... :
    амал
    амал
    амал ...
```

**құжат жолдары / docstring**
Функцияға оның ```__doc__``` атрибуты ретінде тіркелген арнайы жол. PyScripter сияқты құралдар құжаттаманы немесе бағдарламашыға кеңестер беру үшін құжат жолдарын пайдалана алады. Модульдерге, класстарға және әдістерге қатысты сабақтарға жеткенде, онда да құжат жолдарын қолдануға болатынын көреміз.

**орындалу ағымы / flow of execution**
Бағдарламаны орындау кезінде амалдардың орындалу реті.

**фрейм / frame**
Стек диаграммасында функция шақыруын көрсететін жолақ. Ол функцияның жергілікті айнымалылары мен параметрлерін қамтиды.

**функция / function**
Бір пайдалы әрекетті орындайтын амалдар тізбегінің атауы. Функциялар параметрлермен не параметрлерсіз болуы мүмкін және нәтиже шығаратын да, шығармайтын да болуы мүмкін.

**функцияны шақыру / function call**
Функцияны іске қосатын амал - функцияның атынан жане одан кейін келетін жақшаға алынған аргументтер тізімінен тұрады.

**функция композициясы / function composition**
Бір функция шақыруының шығысын екіншісіне кіріс ретінде пайдалану.

**функцияны анықтау / function definition**
Жаңа функцияны жасайтын, оның атын, параметрлерін және орындайтын операторларын көрсететін амал.

**нәтижелі функция / fruitful function**
Шақырылған кезде мәнді қайтаратын функция.

**бастапқы жол / header line**
Құрама амалдың бірінші бөлігі. Бастапқы жол кілт сөзден басталып, қос нүктемен аяқталады (:)

**import амалы / import statement**
Басқа Python модулінде анықталған функциялар мен айнымалыларды екінші script ортасына (environment) енгізуге мүмкіндік беретін амал. Тасбақа мүмкіндіктерін пайдалану үшін алдымен тасбақа модулін импорттау керек ```import turtle```.

**қызмет уақыты / lifetime**
Айнымалылар мен объектілердің өмір сүру уақыты бар — олар бағдарламаны орындау кезінде белгілі бір уақытта жасалады және белгілі бір уақытта жойылады.

**жергілікті айнымалы / local variable**
Функция ішінде анықталған айнымалы. Жергілікті айнымалыны тек оның функциясының ішінде пайдалануға болады. Функцияның параметрлері де жергілікті айнымалының ерекше түрі болып табылады.

**параметр / parameter**
Аргумент ретінде оған жіберілген мәнге сілтеме жасау үшін функция ішінде пайдаланылатын атау.

**рефакторинг / refactor**
Әдетте оны түсінікті ету үшін бағдарлама кодымызды қайта ұйымдастыруды сипаттайтын әдемі сөз. Әдетте, бізде қазірдің өзінде жұмыс істеп тұрған бағдарлама бар, содан кейін біз «оны ретке келтіруге» ораламыз. Oл, дұрыс айнымалы атауларын таңдауды немесе қайталанатын үлгілерді анықтауды және сол кодты функцияға біріктіруді қамтиды.

**стек диаграммасы / stack diagram**
Функциялар стегінің, олардың айнымалыларының және олар сілтеме жасайтын мәндердің графикалық көрінісі.

**аңду / traceback**
Орындалу уақыты қатесі орын алған кезде басып шығарылатын орындалатын функциялардың тізімі. Кері бақылау әдетте стек ізі деп аталады , өйткені ол функцияларды орындалу уақытының стекінде сақталу ретімен тізімдейді .

**бос функция / void function**
Нәтижелі функцияға қарама-қарсы функция: мәнді қайтармайтын функция. Ол қайтаратын мән үшін емес, ол орындайтын жұмыс үшін шақырылады.


## 6.9. Жаттығулар  

![image](https://user-images.githubusercontent.com/84173441/172375559-431cd678-bed1-4c2c-9621-715fe02ee091.png)

1. Шаршы салу үшін void (бос, жеміссіз) функцияны жазыңыз. Жоғарыда көрсетілген 1-ші суретті салу үшін оны бағдарламада пайдаланыңыз. Әр жағы 20 бірлік болсын. (Кеңес: бағдарлама аяқталғанда тасбақа соңғы шаршының аяқталу нүктесінен алыстап кеткенін ескеріңіз.)

2. #2 суретті салу салу үшін програма жазыңыз. Ең ішкі шаршы бір қабырғаға 20 бірлік, ал әрбір келесі квадрат оның ішіндегіден 20 бірлік үлкен деп алыныз.

3. Тасбақа дұрыс көпбұрышты сызуға мүмкіндік беретін ```draw_poly(t, n, sz)``` бос функциясын жазыңыз. draw_poly(tess, 8, 50) арқылы шақырылғанда, ол келесідей пішін салады:  жоғарыдағы #3-ші сурет

4. #4-ші суретті салыңыз.

5. #5. Бұл суреттегі екі спираль тек бұрылыс бұрышымен ерекшеленеді. Екеуін де сызыңыз.

6. Тасбақа тең бүйірлі үшбұрыш салу үшін алдыңғы сұрақтағы ```draw_poly``` функциясын шақыратын ```draw_equitriangle(t, sz)``` void функциясын жазыңыз.

7. ```n```-ге дейінгі барлық бүтін сандардың қосындысын (n-де кіреді) қайтаратын ```sum_to(n)``` нәтижелі функциясын жазыңыз. Осылайша, ```sum_to(10)``` 1+2+3...+10 болады, ол 55 мәнін қайтарады.

8. Радиусы ```r``` шеңберінің ауданын қайтаратын ```area_of_circle(r)``` функциясын жазыңыз.

9. Әр қабырғасының ұзындығы 100 бірлік болатын жұлдызды салу үшін бос функцияны жазыңыз. (Кеңес: тасбақаны әр нүктеде 144 градусқа бұру керек.)

![star](https://user-images.githubusercontent.com/84173441/172377656-cd3c936d-43de-4a67-a74e-0977970a50d5.JPG)

10. Жоғарыдағы бағдарламаңызды кеңейтіңіз. Бес жұлдызды салыңыз, бірақ әрқайсысының арасында қаламды алыңыз, 350 бірлікке алға жылжыңыз, 144-ке оңға бұрылыңыз, қаламды қойыңыз және келесі жұлдызды салыңыз. Сіз келесідей нәрсені аласыз:

![many_Star](https://user-images.githubusercontent.com/84173441/172377849-a322b225-c335-431b-83b8-65d5a89d4764.JPG)


