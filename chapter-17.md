---
title: Кластар мен объектілер
isFree: True
---

# 17. Кластар мен объектілер. Негіздері. Classes and Objects. Basics

## 17.1. Объектіге бағытталған бағдарламалау

Python - объектіге бағытталған бағдарламалау тілі, яғни ол объектіге бағытталған бағдарламалауды (OOP) қолдайтын мүмкіндіктерді қамтамасыз етеді.
(OOP - Object oriented programming)

Объектіге бағытталған бағдарламалау 1960-шы жылдардан бастау алады, ал 1980-ші жылдардың ортасынан кейін бағдарламалық жасақтамада қолданылатын жаңа негізгі бағдарламалау [парадигмасына](https://en-m-wikipedia-org.translate.goog/wiki/Paradigm?_x_tr_sl=en&_x_tr_tl=kk&_x_tr_hl=en&_x_tr_pto=wapp) (үлгісіне) айналды. Ол бағдарламалық жүйелердің тез өсіп келе жатқан көлемі мен күрделілігін өңдеуге және уақыт өте келе осы үлкен және күрделі жүйелерді өзгертуді жеңілдетуге арналған әдіс ретінде әзірленді.

Осы уақытқа дейін біз жазып жүрген бағдарламалардың көпшілігі процедуралық бағдарламалау парадигмасын пайдаланады. Процедуралық бағдарламалауда деректермен жұмыс істейтін функцияларды немесе _процедураларды_ жазуға назар аударылады. Объектіге бағытталған бағдарламалауда басты назар деректер мен функционалдылықты бірге қамтитын объектілерді (**objects**) құруға аударылады. (Объектілермен жұмыс істеген бірнеше мысалды атау үшін біз тасбақа объектісін, string объектісін және кездейсоқ сандар генераторларын көрдік.)

Әдетте, әрбір объект анықтамасы нақты әлемдегі қандай да бір объектіге немесе тұжырымдамаға сәйкес келеді және сол объектіде жұмыс істейтін функциялар нақты әлем объектілерінің өзара әрекеттесу тәсілдеріне сәйкес келеді.

## 17.2. Пайдаланушы анықтайтын құрама деректер түрлері

Біз ```str```, ```int```, ```float``` және ```Turtle``` сияқты кластарды көрдік. Біз енді өзіміздің _пайдаланушы-анықтайтын_ класты жасауға дайынбыз: ол **```Point```** болады.

![xy coordinates](https://github.com/abay-ongar-botabek/Think_Python_ITUniver_QAZ/assets/84173441/98f422f9-0680-4da4-ac4f-279426d253a8)

Математикалық нүкте ұғымын қарастырыңыз. Екі өлшемде (2D) нүкте бір объект ретінде бірге қарастырылатын екі сан (координаталар) болып табылады. Нүктелер көбінесе жақшаның ішінде координаталарды бөлетін үтірмен жазылады. Мысалы, (```0```, ```0```) бастапқы нүктені , ал (```x```, ```y```) бастапқы нүктеден оң жақтағы ```х``` бірлікті және бастапқы нүктеден жоғары ```у``` бірлігін көрсетеді.

Нүктелермен байланыстырылатын кейбір типтік операциялар: координата басынан немесе басқа нүктеден қашықтығын есептеу немесе екі нүктенің ара қашықтығын табу немесе нүктенің берілген тіктөртбұрыштың немесе шеңбердің ішіне түсетінін-түспейтінін сұрау болуы мүмкін. Деректердің көмегімен осының барлығын бірге қалай ұйымдастыруға болатынын жақын арада көреміз.

Python-да нүктені көрсетудің қалыпты жолы - екі сандық мән. Олай болса, мәселе осы екі мәнді құрамалы объектіге қалай топтастыруға болады. Жылдам және "лас" шешім кортежді пайдалану және кейбір бағдарламалар үшін жақсы таңдау болуы мүмкін.

Өзге тәсілі - жаңа **class**-ты анықтау. Бұл тәсіл біршама ұзақ код жазып, қосымша жұмыс жасауды талап етеді, бірақ оның жақын арада көрінетін артықшылықтары бар. Біз әрбір нүктеміздің ```x``` және ```y``` атрибуты болғанын қалаймыз, сондықтан бірінші класс анықтамасы келесідей болады:

```python
class Point:
    """ Point class represents and manipulates x,y coords. 
        Нүкте класы x,y координаталарын көрсетеді және басқарады.
    """

    def __init__(self):
        """ Create a new point at the origin 
            Координат басында жаңа нүкте жасау
        """
        self.x = 0
        self.y = 0
```

Класс анықтамалары бағдарламаның кез келген жерінде жазыла беруі мүмкін, бірақ олар әдетте басына жақын болады (```import``` амалдарынан кейін). Кейбір бағдарламашылар мен тілдер әрбір класты жеке модульге қоюды жөн көреді — біз әзірге мұны істемейміз. Класс анықтамасының синтаксистік ережелері басқа құрама амалдармен бірдей. ```class``` кілт сөзінен басталып, класс атауынан кейін қос нүктемен аяқталатын бас жол бар. Шегініс деңгейлері бізге класстың қай жерде аяқталатынын көрсетеді.

Егер класс бас жолынан кейінгі бірінші жол string болса, ол класстың құжат тізбегі (docstring) болады және әртүрлі құралдар арқылы танылады. (Функциядағы dogstring-те осылай жұмыс жасайтынын білесіздер)

Әрбір класста ```__init__``` арнайы атауы бар әдіс болуы керек. Бұл **инициализатор әдісі** ```Point```-тың кез-келген жаңа инстанциясы жасалған сайын автоматты түрде шақырылады. Бұл бағдарламашыға олардың бастапқы күйін/мәнін беру арқылы жаңа инстанцияда талап етілетін атрибуттарды орнату мүмкіндігін береді. ```self``` параметрі - инициализациялануы қажет жаңадан жасалған объектіге сілтеме жасау үшін автоматты түрде орнатылады. (```self```-тің орнына біз кез келген басқа атауды таңдай аламыз, бірақ ```self``` - конвенция, әдеттегі жасалу жолы)

Енді жаңа Point класымызды қолданайық:

```python
p = Point()         # Instantiate an object of type Point
                    # типі Point болатын жаңа объектіні инициализациялау/жасау
q = Point()         # Make a second point / екіншісін жасау

print(p.x, p.y, q.x, q.y)  # Each point object has its own x and y / Әрбір point объектісінің өз x және y-і бар
```

Бұл бағдарлама басып шығарады:

```python
0 0 0 0
```

өйткені объектілерді инициализациялау кезінде біз әрқайсысы үшін ```x``` және ```y``` деп аталатын екі атрибут жасап, екеуіне де 0 мәнін бердік.

Бұл таныс болып көрінуі керек - біз объектінің бірнешеуін жасау үшін бұрын кластарды пайдаландық:

```python
from turtle import Turtle

tess = Turtle()     # Instantiate objects of type Turtle
                    # типі Turtle болатын жаңа объектілерді инициализациялау/жасау
alex = Turtle()
```

```p``` және ```q``` айнымалыларына жаңа екі ```Point``` объектілеріне сілтемелер тағайындалады. Жаңа объект инстанциясын (данасын) жасайтын ```Turtle``` немесе ```Point``` сияқты функция конструктор (**constructor**) деп аталады және әрбір класс автоматты түрде класспен бірдей аталатын конструктор функциясын қамтамасыз етеді.

Классты объектілерді жасайтын _зауыт_ ретінде қарастыру пайдалы болуы мүмкін. Класстың өзі point-тың данасы емес, бірақ ол ```Point``` даналарды жасауға арналған техниканы қамтиды. Конструкторды шақырған сайын біз зауыттан жаңа объект жасауды сұраймыз. Объект өндіріс желісінен шыққан кезде объектке зауыттың әдепкі параметрлері дұрыс орнатылуы үшін оның инициализация әдісі (initialization method) орындалады.

«Мені жаңа объект етіп жаса» және «оның параметрлерін зауыттық әдепкі параметрлерге инициализациялау» біріккен процесі инстанциялау (**instantiation**) деп аталады.

---
Интернеттен қосымша анықтамалар:

Python тілінде конструктор класс объектілерін инициализациялау үшін қолданылатын арнайы әдіс болып табылады. Ол сынып ішінде анықталады және сол сыныптың объектісі жасалған кезде автоматты түрде орындалады. Конструктор әдісі **```__init__()```** деп аталады («init» алдында және кейін екі астын сызу __ ).

Мұнда конструкторы бар қарапайым класстың мысалы келтірілген:

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def introduce(self):
        print(f"My name is {self.name} and I am {self.age} years old.")

# Creating objects using the constructor
person1 = Person("Alice", 25)
person2 = Person("Bob", 30)

# Accessing object attributes
print(person1.name)  # Output: Alice
print(person2.age)  # Output: 30

# Calling object methods
person1.introduce()  # Output: My name is Alice and I am 25 years old.
person2.introduce()  # Output: My name is Bob and I am 30 years old.
```

Жоғарыда келтірілген мысалда "Person" классында екі параметрді, «аты» және «жасы» қабылдайтын **```__init__()```** конструктор әдісі бар. Конструктор ішінде ```name``` және ```age``` мәндері сәйкесінше объектінің ```self.name``` және ```self.age``` атрибуттарына тағайындалады. ```self``` параметрі жасалып жатқан объектінің данасын білдіреді.

Конструкторды пайдаланып, **```Person```** классының объектілерін жасағанда, мысалы, **```person1 = Person("Алиса", 25)```**, **```__init__()```** әдісі автоматты түрде шақырылады және аргумент ретінде берілген мәндер объектінің атрибуттарын инициализациялау үшін қойылады.

**```Introduce()```** әдісі адамның аты мен жасын көрсету үшін класс ішінде анықталған. Нүкте белгісін (**```person1.name```**, **```person2.age```**) пайдаланып класстың атрибуттарына қол жеткізе аламыз және класстың әдістерін шақырамыз (**```person1.introduce(), person2.introduce()```**).

Конструкторларды пайдалану арқылы біз класс объектілерінің жасалған кезде қажетті атрибуттармен немесе мәндермен инициализациялануын қамтамасыз ете аламыз.

## 17.3. Атрибуттар

Шын өмірдегі кез-келген объектілер сияқты, объект даналарының да атрибуттары мен әдістері бар.

Нүкте белгісін пайдаланып, данадағы атрибуттарды өзгерте аламыз:

```python
>>> p.x = 3
>>> p.y = 4
```

Модульдер де, даналар да өздерінің аттар кеңістігін жасайды және ондағы атауларға (**attributes**/атрибуттарға) қатынасу синтаксисі бірдей. Бұл жағдайда инстанциядан біз таңдайтын атрибуттар деректер элементі.

Келесі күй диаграммасы осы тағайындаулардың нәтижесін көрсетеді:

![poin](https://user-images.githubusercontent.com/84173441/176863693-138dc0a8-0ecc-4902-9087-036843c601d0.JPG)

```p``` айнымалысы екі атрибуттан тұратын ```Point``` объектісіне сілтеме жасайды. Әрбір атрибут санға сілтеме жасайды.

Біз осы синтаксисті пайдаланып атрибуттың мәніне қол жеткізе аламыз:

```python
>>> print(p.y)
4
>>> x = p.x
>>> print(x)
3
```

```p.x``` өрнегі "p сілтеме жасайтын объектіге өтіп, ```x``` мәнін алу" дегенді білдіреді. Бұл жағдайда біз бұл мәнді ```x``` деп аталатын айнымалыға тағайындаймыз. ```x``` айнымалысы (мұндағы golbal аттар кеңістігіндегі) мен ```x``` атрибуты (инстанцияға жататын аттар кеңістігінде) арасында қайшылық жоқ. Нүктелік білгінің мақсаты - қай айнымалыға сілтеме жасайтынымызды толық (FQ) әрі нақты анықтау.

Біз нүкте белгісін кез келген өрнектің бөлігі ретінде пайдалана аламыз, сондықтан келесі амалдар заңды:

```python
print("(x={0}, y={1})".format(p.x, p.y))
distance_squared_from_origin = p.x * p.x + p.y * p.y
```

Бірінші жол (x=3, y=4) шығарады . Екінші жол 25 мәнін есептейді.

## 17.4. Инициализаторды жақсарту

Бізге (7, 6) позицияда нүкте жасау үшін қазіргі уақытта кодтың үш жолы қажет:

```python
p = Point()
p.x = 7
p.y = 6
```

Төмендегі мысалда көрсетілгендей ```__init__``` әдісіне қосымша параметрлерді енгізу арқылы класс конструкторын жалпылай аламыз:

```python
class Point:
    """ Point class represents and manipulates x,y coords. 
        Point класы x,y координаттарын көрсетеді және басқарады.
    """

    def __init__(self, x=0, y=0):
        """ Create a new point at x, y """
        self.x = x
        self.y = y

# Other statements outside the class continue below here.
# Класстан тыс басқа амалдар төменде осы жерде жалғасады.
```

Мұндағы ```x``` және ```y``` параметрлерінің екеуі де міндетті емес. Шақырушы аргументтерді бермесе, олар әдепкі 0 мәндерін алады. Міне, біздің жақсартылған класс қолданыс барысында:

```python
>>> p = Point(4, 2)
>>> q = Point(6, 3)
>>> r = Point()       # r represents the origin (0, 0) / r координата басын білдіреді
>>> print(p.x, q.y, r.x)
4 3 0
```

---

**Техникалық тұрғыдан алғанда** ...

Егер біз шынымен терең қазбалайтын болсақ, ```__init__``` әдісінің құжат жолы дұрыс емес деп айта алатын едік. ```__init__``` объектіні жасамайды (яғни ол үшін жад бөлуді істемейді), — ол жасалғаннан кейін объектіні "зауыттық" әдепкі параметрлеріне инициализациялайды.

Бірақ PyScripter сияқты құралдар instantiation жасау - жасау және инициализация - бірге болатынын түсінеді және олар сынып конструкторын шақыратын бағдарламашыны бағыттау үшін инициализатордың құжат жолын құрал кеңесі ретінде көрсетуді таңдайды.

Сонымен, біз құжат жолын біздің ```Point``` классын қолданатын бағдарламашыға көмектесу үшін пайда болған кезде ең мағыналы болатындай етіп жазып жатырмыз :

![point](https://user-images.githubusercontent.com/84173441/176870326-7968c3c4-9472-45ac-8f3a-5ded99580602.JPG)

---

## 17.5. Біздің классқа басқа әдістерді қосу

Қарапайым кортеж ```(6, 7)``` емес, ```Point``` сияқты классты пайдаланудың негізгі артықшылығы енді айқын болады. 

Біз ```Point``` классына, нүктелер үшін маңызды амалдар болып табылатын әдістерді қоса аламыз, бірақ ол әдістер бір күн мен айды, мысалы, Рождество күнін білдіруі мүмкін ```(25, 12)``` сияқты басқа кортеждерге сәйкес келмеуі мүмкін. Сондықтан бастапқы координатадан қашықтықты есептей алу нүктелер үшін маңызды, бірақ (күн, ай) деректер үшін емес. (Күн, ай) деректері бойынша біз басқа операцияларды, мүмкін оның 2023 жылы аптаның қай күніне түсетінін табуды қалаймыз.

```Point``` сияқты классты құру бағдарламаларымызға және ойлауымызға ерекше «ұйымдастырушылық күш» әкеледі. Біз бір мақсаттағы операцияларды және олар әрекеттесетін деректер түрлерін біріктіре аламыз және класстың әрбір данасы өз күйіне (state) ие болуы мүмкін.

Әдіс функция сияқты әрекет етеді, бірақ ол белгілі бір инстанцияда шақырылады, мысалы, ```tess.right(90)```. Деректердің атрибуты сияқты әдістерге нүктелік белгі арқылы қол жеткізіледі.

--- 
Интернеттен қосымша ақпарат

Python-да функциялар мен әдістер көп жағынан ұқсас, бірақ олардың анықталуы мен шақырылуында шамалы айырмашылық бар. Міне, олардың айырмашылықтары:
(In Python, **functions** and **methods** are similar in many ways but have a slight difference in how they are defined and called. Here's a breakdown of their differences:)

1. Анықтама және синтаксис:
    - Функциялар: Функциялар белгілі бір тапсырманы орындайтын жеке код блоктары болып табылады. Олар **```def```** кілт сөзі, одан кейін функция атауы, қосымша параметрлер үшін жақшалар және қос нүкте арқылы анықталады. Функция денесі/блогы функция анықтаманың астында шегініспен жазылған.

```python
def my_function(arg1, arg2):
    # Function code block
    # ...
```

- Әдістер: Әдістер, керісінше, класс ішінде анықталған және осы класстың объектілерімен немесе даналарымен байланысты функциялар. Олар функциялар сияқты анықталады, бірақ класс анықтамасының ішінде шегініспен жазылған.

```python
class MyClass:
    def my_method(self, arg1, arg2):
        # Method code block
        # ...
```

2. Параметрлер мен аргументтер:
    - Функциялар: Функциялар шақырылған кезде оларға жіберілетін аргументтерді немесе параметрлерді қабылдай алады. Бұл параметрлер функция анықтамасының жақша ішінде анықталған. Аргументтер - бұл функция шақырылған кезде оған берілетін нақты мәндер.

```python
def add_numbers(a, b):
    return a + b

result = add_numbers(2, 3)  # Arguments: 2 and 3
```
- Әдістер: Класстағы әдістер әдетте әдіс шақырылатын класс данасына сілтеме жасайтын "self" деп аталатын арнайы бірінші параметрге ие. Бұл әдістерге нысанның атрибуттарына және басқа әдістерге қол жеткізуге және оларды басқаруға мүмкіндік береді.

```python
class MyClass:
    def set_value(self, value):
        self.value = value

obj = MyClass()
obj.set_value(10)  # Argument: 10
```

3. Функцияны не әдісті шақыру:
    - Функциялар: Функциялар тікелей атымен шақырылады, содан кейін жақшалар және кез келген қажетті аргумент қойылады.

```python
result = add_numbers(2, 3)
```

- Әдістер: Әдістер класстың объектісіне немесе данасына нүкте белгісін қолданып шақырылады. Класстан кейін нүкте, содан кейін әдіс атауы және кез келген қажетті аргумент болады.

```python
obj = MyClass()
obj.set_value(10)
```

Қорытындылай келе, функциялар белгілі бір тапсырманы орындайтын тәуелсіз код блоктары болып табылады, ал әдістер сынып ішінде анықталған функциялар болып табылады және осы сыныптың нысандарымен (класс объектілерімен) немесе даналарымен байланысты. Әдістердің класс данасына сілтеме жасайтын арнайы бірінші параметрі («self») болады. Функцияларды шақыру кезінде сіз функция атын тікелей пайдаланасыз, ал әдістер нүкте белгісін қолданатын нысандарда шақырылады.

Әдістердің қалай жұмыс істейтінін жақсырақ көру үшін ```distance_from_origin``` деген басқа әдісті қосайық:

```python
class Point:
    """ Create a new Point, at coordinates x, y 
    x, y координатында жаңа Point жасау
    """

    def __init__(self, x=0, y=0):
        """ Create a new point at x, y 
            x, y-те жаңа нүктені жасау
        """
        self.x = x
        self.y = y

    def distance_from_origin(self):
        """ Compute my distance from the origin 
            оның координата басынан ара-қашықтығын өлше
        """
        return ((self.x ** 2) + (self.y ** 2)) ** 0.5
```

Бірнеше нүктелік даналарды жасайық, олардың атрибуттарын қарастырайық және оларда жаңа әдісімізді шақырайық: (Біз Point классын интерпретаторға қолжетімді ету үшін алдымен бағдарламамызды іске қосуымыз керек.)

```python
>>> p = Point(3, 4)
>>> p.x
3
>>> p.y
4
>>> p.distance_from_origin()
5.0
>>> q = Point(5, 12)
>>> q.x
5
>>> q.y
12
>>> q.distance_from_origin()
13.0
>>> r = Point()
>>> r.x
0
>>> r.y
0
>>> r.distance_from_origin()
0.0
```

Әдісті анықтау кезінде бірінші параметр әрекет жасалатын данаға сілтеме жасайды. Жоғарыда айтылғандай, бұл параметрді ```self``` деп атау әдеттегі жағдай/стандарт.

Назар аударыңыз, ```distance_from_origin``` әдісін шақырушы ```self``` параметріне сәйкес келетін аргументті нақты ұсынбайды — бұл бізге көрсетілмей, программамен жасырын орындалады.

## 17.6. Инстанциялар аргумент және параметр ретінде

Біз объектіні аргумент ретінде әдеттегідей бере аламыз. Біз мұны кейбір тасбақа мысалдарында көрдік, онда біз тасбақаны ```draw_bar``` сияқты функцияға бердік, осылайша функция біз оған берген кез келген тасбақа данасын басқара және пайдалана алады.

Есіңізде болсын, біздің айнымалы тек объектіге сілтемені сақтайды, сондықтан функцияға ```tess```-ті аргумент ретінде беру бүркеншік ат жасайды: енді шақырушыда да, шақырылған функцияда да сілтеме бар, бірақ мұнда бір ғана тасбақа!

Біздің жаңа ```Point``` объектіні қамтитын қарапайым функция мысалы:

```python
def print_point(pt):
    print("({0}, {1})".format(pt.x, pt.y))
```

```print_point``` аргумент ретінде нүктені қабылдайды және шығатын нәтижені біз қалағандай пішімдейді. Егер біз бұрын анықталған ```p``` нүктесімен ```print_point(p)``` деп шақырсақ, шығыс (3, 4) болады.

## 17.7. Дананы тіркеске түрлендіру

Объектіге-бағытталған бағдарламашылардың көпшілігі ```print_point```-та біз жасаған нәрсені жасамайтын шығар. Біз класстармен және объектілермен жұмыс істегенде, таңдаулы баламасы классқа жаңа әдісті қосу болып табылады. Бізге ```print```-ті шақыратын chatterbox әдістері ұнамайды. Жақсы тәсіл - әрбір дананың өз тіркес (string) көрінісін жасай алатын әдістің болуы. Алдымен оны ```to_string``` деп атайық:

```python
class Point:
    # ...

    def to_string(self):
        return "({0}, {1})".format(self.x, self.y)
```

Енді біз айта аламыз:

```python
>>> p = Point(3, 4)
>>> print(p.to_string())
(3, 4)
```

Бірақ бізде объекті тіркеске айналдыра алатын ```str``` түрлендіргіші бар емес пе? Иә! ```print``` әр нәрсені басып шығару кезінде мұны автоматты түрде пайдаланады емес пе? Тағы да иә! Бірақ бұл автоматты механизмдер әлі де нақты біз қалаған нәрсені орындамайды:

```python
>>> str(p)
'<__main__.Point object at 0x01F9AA10>'
>>> print(p)
'<__main__.Point object at 0x01F9AA10>'
```

Мұны түзету үшін Python-ның ақылды айласы бар. Егер біз ```to_string``` орнына жаңа әдісімізді ```__str__``` деп атасақ, Python интерпретаторы ```Point```-ты тіркеске түрлендіру қажет болғанда біздің кодты пайдаланады. Олай болса басқаша жазып көрейік:

```python
    class Point:
        # ...

        def __str__(self):    # All we have done is renamed the method
                              # Біздің бар жасағанымыз әдістің атын ауыстырдық
            return "({0}, {1})".format(self.x, self.y)
```

енді бәрі керемет көрінеді!

```python
>>> str(p)     # Python now uses the __str__ method that we wrote.
               # Python енді біз жазған __str__ әдісін қолданады
(3, 4)
>>> print(p)
(3, 4)
```

## 17.8. Даналар қайтарылатын мәндер

Функциялар мен әдістер инстанцияларды қайтара алады. Мысалы, екі ```Point``` объектісі берілген, олардың орта нүктесін табыңыз. Алдымен біз оны кәдімгі функция ретінде жазамыз:

```python
def midpoint(p1, p2):
    """ Return the midpoint of points p1 and p2 
        p1 және p2 орта нүктесін қайтар
    """
    mx = (p1.x + p2.x)/2
    my = (p1.y + p2.y)/2
    return Point(mx, my)
```

Функция жаңа ```Point``` объектін жасайды және қайтарады:

```python
>>> p = Point(3, 4)
>>> q = Point(5, 12)
>>> r = midpoint(p, q)
>>> r
(4.0, 8.0)
```

Енді біз мұны функция емес әдіс ретінде жасайық. Бізде нүктелік объект бар делік және оның ортасы мен басқа бір-мысал нүкте арасындағы орта нүктені тапқымыз келеді:

```python
class Point:
   # ...

   def halfway(self, target):
        """ Return the halfway point between myself and the target 
            Мен және нысан нүкте арамыздағы жарты қашықтық нүктені қайтарыңыз
        """
        mx = (self.x + target.x)/2
        my = (self.y + target.y)/2
        return Point(mx, my)
```

Бұл әдіс кейбір атауларды өзгертуден басқа жоғарыдағы функциямен бірдей. Оның қолданылуы келесідей болуы мүмкін:

```python
>>> p = Point(3, 4)
>>> q = Point(5, 12)
>>> r = p.halfway(q)
>>> r
(4.0, 8.0)
```

Бұл мысал әрбір нүктені айнымалыға тағайындағанымен, мұны істеу қажет емес. Функция шақырулары құрастырылатын сияқты, әдіс шақырулары мен объект жасау да құрастырылады, бұл айнымалы мәндерді пайдаланбайтын мынандай нұсқасы да болуым мүмкіндігін білдіреді:

```python
>>> print(Point(3, 4).halfway(Point(5, 12)))
(4.0, 8.0)
```

## 17.9. Көзқарастың өзгеруі

```print_time(current_time)``` функция шақыруының түпнұсқа синтаксисі,  функцияның белсенді агент екенін көрсетеді. Ол мынаған ұқсас нәрсені айтады: _"Ей, print_time! Мұнда сізге басып шығаруға арналған объект бар"_.

Объектіге бағытталған бағдарламалауда объектілер белсенді агенттер болып саналады. ```current_time.print_time()``` сияқты шақыру: _"Эй, ағымдағы\_уақыт! Өзіңізді басып шығар!"_

Тасбақалар туралы алғашқы кіріспеде біз объектіге бағытталған стильді қолдандық, осылайша ```tess.forward(100)```, ол тасбақаны берілген қадамдар саны бойынша алға жылжуын сұрайды.

Перспективаның бұл өзгеруі жайлы болуы мүмкін, бірақ бастапқыда оның пайдалы екені анық болмауы мүмкін. Бірақ кейде жауапкершілікті функциялардан объектілерге ауыстыру жан-жақты функцияларды жазуға мүмкіндік береді және кодты сақтауды және қайта пайдалануды жеңілдетеді.

Объектіге бағытталған бағдарламалау стильінің ең маңызды артықшылығы - ол біздің программалық ой жинақтау мен нақты өмірлік тәжірибемізге дәлірек сәйкес келеді. Шынайы өмірде біздің ```cook``` (пісіру) әдісіміз микротолқынды пештің бір бөлігі болып табылады — бізде асүйдің бұрышында микротолқынды пешті пісіретін ```cook``` функциясы жоқ! Сол сияқты, біз SMS жіберу немесе оның күйін дыбыссыз күйге өзгерту үшін ұялы телефонның өз әдістерін қолданамыз. Нақты дүние объектілерінің функционалдығы объектінің өздерімен тығыз байланысты болады. OOP бағдарламаларымызды ұйымдастырған кезде мұны дәл көрсетуге мүмкіндік береді.

## 17.10. Объекттің күйі болуы мүмкін

Объектілер бізге өте пайдалы болатын тағы бір жағдай оның күйді сақтап тұруы және ол күйді уақыт аралығында өзгертіп, жаңартып тұра алуымыз. Тасбақа объектісін қарастырайық. Оның күйі оның орны, қарап тұрған бағыты, түсі және пішіні сияқты нәрселерден тұрады. ```left(90)``` сияқты әдіс тасбақаның қарап тұрған бағытын жаңартады, ```forward``` (алға жылжыту) оның орнын өзгертеді және т.б.

Банктік шот объектісі үшін күйдің негізгі құрамдас бөлігі ағымдағы баланс және мүмкін барлық транзакциялардың журналы болуы мүмкін. Әдістер ағымдағы балансты сұрауға, жаңа қаражат салуға немесе төлем жасауға мүмкіндік береді. Төлем жасау сома мен транзакция журналына қосылуы үшін қажетті сипаттаманы қамтиды. Біз сондай-ақ транзакция журналын көрсету әдісін қалаймыз.

## 17.11. Глоссарий

**атрибут** / **attribute**
Инстанцияны құрайтын аталған деректер элементтерінің бірі.

**класс** / **class**
Пайдаланушы анықтайтын құрама түрі. Сондай-ақ класстар оның инстанциясы (данасы) болып табылатын объектілер үшін үлгі ретінде қарастыруға болады. (iPhone - бұл класс. 2010 жылдың желтоқсан айына қарай 50 миллион дана сатылған!)

**конструктор** / **constructor**
Әрбір класста жаңа даналарды жасау үшін класспен бірдей атпен аталатын «зауыт» бар. Егер класста _инициализатор әдісі_ болса, осы әдіс жаңа объектінің дұрыс орнатылған  атрибуттарын (яғни күйін) алу үшін пайдаланылады.

**инициализатор әдісі** / **initializer method**
Жаңадан жасалған объектінің атрибуттарын бастапқы (factory-default) күйіне орнату үшін автоматты түрде шақырылатын Python тіліндегі арнайы әдіс ( ```__init__``` деп аталады).

**инстанция/дана** / **instance**
Түрі (type) қандай да бір классқа жататын объект. Инстанция және объект сөздері алмастырылып қолданыла береді.

**жасау** / **instantiate**
Класс данасын жасау және оның инициализаторын іске қосу.

**әдіс** / **method**
Класс анықтамасында анықталған және сол класстың инстанциясында шақырылатын функция.

**объект** / **object**
Нақты әлемдегі затты немесе тұжырымдаманы модельдеу үшін жиі қолданылатын құрама деректер түрі. Ол осы деректер түріне қатысты деректер мен операцияларды біріктіреді. Инстанция және объект сөздері алмастырылып қолданыла береді.

**объектіге бағытталған бағдарламалау** / **object-oriented programming**
Деректер мен оны басқаратын операциялар объектіге жинастырылып-ұйымдастырылған бағдарламалаудың қуатты стилі.

**объектіге бағытталған тіл** / **object-oriented language**
Объектіге бағытталған бағдарламалауды жеңілдететін пайдаланушы анықтайтын класстар және inheritance (мұрагерлік) сияқты мүмкіндіктерді қамтамасыз ететін тіл.

## 15.12. Жаттығулар

1. _Нәтижелі функциялар_ тарауындағы ```distance``` функциясын төрт санның орнына параметр ретінде екі ```Point``` алатындай етіп қайта жазыңыз .

2. ```Point```-қа жаңа ```Point``` қайтаратын ```reflect_x``` әдісін қосыңыз, ол нүктенің ```х``` осі бойындағы айна-көрінісі болып табылады. Мысалы, ```Point(3, 5).reflect_x()``` мәні (3, -5)

3. Нүктені координата басына қосатын сызықтың [көлбеуін](https://en-m-wikipedia-org.translate.goog/wiki/Slope?_x_tr_sl=en&_x_tr_tl=kk&_x_tr_hl=en&_x_tr_pto=wapp) қайтаратын ```slope_from_origin``` әдісін жазыңыз. Мысалға,

```python
>>> Point(4, 10).slope_from_origin()
2.5
```

Қандай жағдайларда бұл әдіс сәтсіз болады?

4. Түзу сызықтың теңдеуі «y = ax + b», (немесе «y = mx + c» болуы мүмкін). a және b коэффициенттері сызықты толығымен сипаттайды. ```Point``` классында point инстанциясына басқа нүкте берілсе, ол екі нүктені қосатын түзудің теңдеуін есептейтіндей әдісті жазыңыз. Ол екі коэффициентті екі мәннен тұратын кортеж ретінде қайтаруы керек. Мысалға,

```python
>>> print(Point(4, 11).get_line_to(Point(6, 15)))
>>> (2, 3)
```

Бұл екі нүктені қосатын түзудің теңдеуі «y = 2x + 3» екенін көрсетеді. Бұл әдіс қашан сәтсіздікке ұшырайды?

5. Шеңбердің шеңберіне түсетін төрт нүкте берілген болса, шеңбердің ортасын табыңыз. Бұл функция қашан істен шығады?

Нұсқау: Бағдарламалауды бастамас бұрын, геометриялық есепті шешу жолын білуіңіз керек. Компьютер не істеу керек екенін айта алмасаңыз, есептің (проблеманың) шешімін программалай алмайсыз!

6. Жаңа ```SMS_store``` классын жасаңыз. Класс ұялы телефондағы inbox (кіріс) немесе outbox (шығыс) жәшігіне ұқсас SMS_store объектілерін жасайды:

```python
my_inbox = SMS_store()
```

Бұл жәшік бірнеше SMS хабарламаларын сақтай алады (яғни оның ішкі күйі тек хаттар тізімі болады). Әрбір хат кортеж ретінде көрсетіледі:

```python
(has_been_viewed, from_number, time_arrived, text_of_SMS)
```

Inbox (кіріс жәшігі) объекті мына әдістерді қамтамасыз етуі керек:

```python
my_inbox.add_new_arrival(from_number, time_arrived, text_of_SMS)
  # Makes new SMS tuple, inserts it after other messages
  # in the store. When creating this message, its
  # has_been_viewed status is set False.

my_inbox.message_count()
  # Returns the number of sms messages in my_inbox

my_inbox.get_unread_indexes()
  # Returns list of indexes of all not-yet-viewed SMS messages

my_inbox.get_message(i)
  # Return (from_number, time_arrived, text_of_sms) for message[i]
  # Also change its state to "has been viewed".
  # If there is no message at position i, return None

my_inbox.delete(i)     # Delete the message at index i
my_inbox.clear()       # Delete all messages from inbox
```

Кластты жазыңыз, хаттар жәшігінің объектісін жасаңыз және әдістерді орындаңыз.
