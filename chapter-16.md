---
title: Рекурсия
isFree: True
---

# Recursion. Рекурсия

**Рекурсия** - керекті нәтижені алу үшін бірнеше рет «бір нәрсені өз тұрғысынан анықтауды» білдіреді. 

[Wikipedia](https://en-m-wikipedia-org.translate.goog/wiki/Recursion_(computer_science)?_x_tr_sl=en&_x_tr_tl=kk&_x_tr_hl=en&_x_tr_pto=wapp)
Информатикада рекурсия - үлкен есептеу мәселесін (computational problem) шешудің жолы осы үлкен есептеудің кіші инстанциясын шешуге байланысты болатын әдіс. Рекурсия осындай рекурсивті есептерді өз кодының ішінен шақыратын функцияларды қолдану арқылы шешеді. Тәсіл есептердің көптеген түрлеріне қолданылуы мүмкін, ал рекурсия информатиканың орталық идеяларының бірі болып табылады.

Көптеген компьютерлік бағдарламалау тілдері _функцияның ішіндегі код функцияның өзін қайта шақыруға мүмкіндік беру_ арқылы рекурсияны қолдайды.

Итеративті түрде (```for``` немесе ```while``` циклімен) шешілетін кез келген мәселені рекурсивті түрде шешуге болады. Дегенмен, рекурсияны түсініп, рекурсияда ойлай білу үшін біраз уақыт керек, сондықтан ол әдетте мәселеңіз рекурсивті сипатта немесе деректеріңіз рекурсивті болып табылатын нақты жағдайларда ғана қолданылады.

## 16.1. Фракталдарды сызу

Біз қарастырып отырған **фрактал** - бұл _өз-өзіне ұқсас_ құрылымы бар сызба, өзі арқылы өзін анықтай алады. (қазір көреміз)

Әйгілі Кох фракталын қарастырудан бастайық. 0-інші реттегі Кох фракталы берілген өлшемдегі жай қарапайым түзу сызық болып табылады.

![Koch_0](https://user-images.githubusercontent.com/84173441/176164474-60a59794-f57a-412f-adcf-ba50d1e2efc2.JPG)

Кох фракталы 1-ші реті келесідей алынады: бір сызық салудың орнына, мұнда көрсетілген үлгі бойынша төрт кішірек сегментті сызыңыз:

![Koch_1](https://user-images.githubusercontent.com/84173441/176164515-388a3c09-e849-46bd-9841-fc834f9ad3fc.JPG)

Енді осы Кох үлгісін 1-ші реттік сегменттердің әрқайсысында қайталасақ не болар еді? Біз Кох фракталы 2-ші ретін аламыз:

![Koch_2](https://user-images.githubusercontent.com/84173441/176164594-15d41616-24ba-41dc-8b62-2245d7a3328d.JPG)

Үлгімізді қайтадан қайталау бізге Кох фракталы 3-ші ретін береді:

![Koch_3](https://user-images.githubusercontent.com/84173441/176164630-dbd45cb9-6519-4962-9333-5b192b13495d.JPG)

Енді бұл туралы керісінше ойланайық. 3-ші ретті Кох фракталын салу үшін біз жай ғана төрт 2-ші ретті Кох фракталын сала аламыз. Бірақ олардың әрқайсысына өз кезегінде төрт рет 1-ші рет Кох фракталдары қажет, ал олардың әрқайсысына өз кезегінде 0 ретті төрт фракталдар қажет. Сайып келгенде, жалғыз сызба 0 ретімен орындалады. Бұл Python-да кодтау өте оңай:

```python
import turtle

import turtle             # turtles деп аталатын модульді пайдалануға мүмкіндік береді
wn = turtle.Screen()      # тасбақалар қозғалатын ойын алаңын жасайды
tess = turtle.Turtle()    # тасбақа жасаймыз, оны alex айнымалысына тағайындаймыз


def koch(tortoise, order, size):
    """
       Make turtle tortoise draw a Koch fractal of 'order' and 'size'.
       Leave the turtle facing the same direction.

       Тасбақа tortoise «тәртіп» және «өлшем» бойынша Кох фракталын салсын.
       Тасбақа сол бағытта беттеп қала берсін.
    """

    if order == 0:  # The base case is just a straight line. Базалық жағдай жәй ғана түзу сызық
        tortoise.forward(size)
    else:
        koch(tortoise, order - 1, size / 3)  # Go 1/3 of the way. Жолдың 1/3-ін жүріп өт
        tortoise.left(60)
        koch(tortoise, order - 1, size / 3)
        tortoise.right(120)
        koch(tortoise, order - 1, size / 3)
        tortoise.left(60)
        koch(tortoise, order - 1, size / 3)


koch (tess, 4, 500)

wn.mainloop()
```

Мұндағы жаңа негізгі нәрсе, егер рет нөлге тең болмаса, ```koch``` өз жұмысын орындау үшін өзін рекурсивті түрде шақырады.

Қарапайым бақылау жасап, осы кодты жинақылап жазайық. 120-ға оңға бұрылу солға -120-ға бұрылумен бірдей екенін есте сақтаңыз. Сонымен, бағдарламашылар сияқты тереңірек ойлауды іске қосып, 19-26 код жолдар орнына циклды пайдалана аламыз:

```python
def koch(tortoise, order, size):
    if order == 0:
        tortoise.forward(size)
    else:
        for angle in [60, -120, 60, 0]:
           koch(tortoise, order-1, size/3)
           tortoise.left(angle)
```

Соңғы бұрылыс 0 градус, сондықтан оның әсері болмайды. Бірақ бұл бізге үлгіні табуға және кодтың жеті жолын үшке дейін азайтуға мүмкіндік берді, бұл біздің келесі бақылауларымызды жеңілдетеді.

---

**Рекурсия, үстінен көрініс**

Бұл туралы ойлаудың бір жолы - 0 фрактал реті үшін оны шақырған кезде функцияның дұрыс жұмыс істейтініне өзіңізді сендіру. Содан кейін сенімнің ақыл-ой секірісін жасаңыз: «_Джин_ (немесе Python, егер сіз Питонды ертегідегі Джин деп ойласаңыз) _20, 22, 24 және 26-шы код жолдарында_ (```koch(tortoise, order - 1, size / 3)```) _мен шақыратын рекурсивті 0 деңгейін қалай өңдеу керектігін біледі, сондықтан маған бұл туралы егжей-тегжей ойлаудың қажеті жоқ!_ Маған назар аудару керек нәрсе, _егер 0 реті қазірдің өзінде жұмыс істеп тұр деп болжасам_, 1 фрактальды ретті қалай салу керек.

Сіз _ақыл-ой абстракциясымен_ айналысып жатырсыз - үлкен мәселені шешу кезінде ішкі мәселені елемеу.

Егер бұл ойлау әдісі жұмыс істесе (және сіз оны жаттығуыңыз керек!), онда оны келесі деңгейге көтеріңіз. Аха! енді мен оның 1-деңгейде жұмыс істеп тұрғанын болжаған кезде 2-ші ретке шақырылғанда жұмыс істейтінін көре аламын ба.

Жалпы, егер мен n-1 жағдайының реті жұмыс істейді деп есептей алсам, мен n деңгейіндегі мәселені шеше аламын ба?

Индукция дәлелдерімен жұмыс істеген математика студенттері мұнда өте күшті ұқсастықтарды көруі керек.


**Рекурсия, төмен деңгейлі операциялық көрініс**

Рекурсияны түсінудің тағы бір жолы - одан құтылу! Егер бізде 3-деңгей фракталы, 2-деңгей фракталы, 1-деңгей фракталы және 0-деңгей фракталын салу үшін бөлек функциялар болса, біз жоғарыда аталған кодты бұдан былай рекурсия болмайтын жағдайға дейін механикалық түрде жеңілдете аламыз.:

```python
def koch_0(tortoise, size):
    tortoise.forward(size)

def koch_1(tortoise, size):
    for angle in [60, -120, 60, 0]:
       koch_0(tortoise, size/3)
       tortoise.left(angle)

def koch_2(tortoise, size):
    for angle in [60, -120, 60, 0]:
       koch_1(tortoise, size/3)
      tortoise.left(angle)

def koch_3(tortoise, size):
    for angle in [60, -120, 60, 0]:
       koch_2(tortoise, size/3)
       tortoise.left(angle)
```

Рекурсияны «ашудың» бұл айласы бізге не болып жатқаны туралы оперативті көрініс береді. Сіз бағдарламаны ```koch_3``` ішіне , одан кейін ```koch_2``` ішіне, содан кейін ```koch_1``` және т.б. ішіне рекурсияның әртүрлі қабаттары бойымен қарай аласыз.

Бұл сіздің түсінуіңізді жақсарту үшін пайдалы кеңес болуы мүмкін. Дегенмен, ақыл-ой мақсаты - абстракцияны жасай алу!

---

## 16.2. Рекурсивті деректер құрылымдары

Біз көрген Python деректерінің барлық түрлерін тізімдер мен кортеждер ішінде әртүрлі тәсілдермен топтастыруға болады. Тізімдер мен кортеждер деректерді ұйымдастырудың көптеген мүмкіндіктерін қамтамасыз ете отырып, кірістірілуі мүмкін. Пайдалануды жеңілдету мақсатында мәліметтерді ұйымдастыру деректер құрылымы деп аталады .

Сайлау уақыты келді, біз дауыстарды олар келген кезде есептеуге көмектесеміз. Жеке округтерден, учаскелерден, муниципалитеттерден, округтерден және штаттардан келген дауыстар кейде дауыстардың жалпы сомасы, кейде дауыстардың аралық жиынтықтарының тізімі ретінде хабарланады. Есептерді қалай жақсы сақтау керектігін қарастырғаннан кейін біз кірістірілген сандар тізімін пайдалануды шештік, оны келесідей анықтаймыз:

Кірістірілген сандар тізімі - элементтері келесі тізімнен тұрады:

сандар
кірістірілген сандар тізімдері
Кірістірілген сандар тізімі термині өз анықтамасында қолданылатынына назар аударыңыз . Осындай рекурсивті анықтамалар математика мен информатикада жиі кездеседі. Олар ішінара өздерінің кішірек және қарапайым даналарынан тұратын рекурсивті деректер құрылымдарын сипаттаудың қысқа және күшті әдісін қамтамасыз етеді . Анықтама дөңгелек емес, өйткені белгілі бір уақытта біз элементтер ретінде тізімдері жоқ тізімге жетеміз.

Енді біздің жұмысымыз кірістірілген сандар тізіміндегі барлық мәндерді қосатын функцияны жазу болып табылады делік. Python-да сандар тізбегінің қосындысын табатын кіріктірілген функция бар:

```python
>>> sum([1, 2, 8])
11
```

Біздің кірістірілген нөмірлер тізімі үшін сома жұмыс істемейді:

```python
>>> sum([1, 2, [11, 13], 8])
Traceback (most recent call last):
  File "<interactive input>", line 1, in <module>
TypeError: unsupported operand type(s) for +: 'int' and 'list'
>>>
```

Мәселе мынада, бұл тізімнің үшінші элементі \[11, 13] өзі тізім болып табылады, сондықтан оны жай ғана 1 , 2 және 8 сандарына қосу мүмкін емес .

## 18.3. Рекурсивті сандар тізімдерін өңдеу

Рекурсивті кірістірілген сандар тізіміндегі барлық сандарды қосу үшін біз тізімді айналып өтуіміз керек, оның кірістірілген құрылымындағы элементтердің әрқайсысына баруымыз, қосындыға кез келген сандық элементтерді қосуымыз және өздері ішкі элементтер болып табылатын кез келген элементтермен қосу процесін рекурсивті қайталауымыз керек. тізімдер.

Рекурсияның арқасында кірістірілген сандар тізімінің мәндерін қосу үшін қажет Python коды таңқаларлық қысқа:

```python
def r_sum(nested_num_list):
    tot = 0
    for element in nested_num_list:
        if type(element) == type([]):
            tot += r_sum(element)
        else:
            tot += element
    return tot
```

r_sum денесі негізінен кірістірілген_сан_тізімі арқылы өтетін for циклінен тұрады . Егер элемент сандық мән болса ( басқа тармақ), ол жай ғана tot ішіне қосылады . Егер элемент тізім болса, r_sum элементі аргумент ретінде қайта шақырылады. Функция өзін шақыратын функция анықтамасының ішіндегі мәлімдеме рекурсивті шақыру ретінде белгілі .

Жоғарыдағы мысалда рекурсивті шақыруға әкелмейтін негізгі регистр (13-жолда) бар: элемент (ішкі) тізім болып табылмайтын жағдай. Негізгі жағдайсыз сізде шексіз рекурсия болады және сіздің бағдарламаңыз жұмыс істемейді.

Рекурсия шынымен де информатикадағы ең әдемі және талғампаз құралдардың бірі болып табылады.

Кірістірілген сандар тізіміндегі ең үлкен мәнді табу біршама күрделі мәселе:

```python
def r_max(nxs):
    """
      Find the maximum in a recursive structure of lists
      within other lists.
      Precondition: No lists or sublists are empty.
    """
    largest = None
    first_time = True
    for e in nxs:
        if type(e) == type([]):
            val = r_max(e)
        else:
            val = e

        if first_time or val > largest:
            largest = val
            first_time = False

    return largest

test(r_max([2, 9, [1, 13], 8, 6]) == 13)
test(r_max([2, [[100, 7], 90], [1, 13], 8, 6]) == 100)
test(r_max([[[13, 7], 90], 2, [1, 100], 8, 6]) == 100)
test(r_max(["joe", ["sam", "ben"]]) == "sam")
```

Жұмыста r_max мысалдарын қамтамасыз ету үшін сынақтар қамтылған .

Бұл мәселеге қосылған бұралу - ең үлкенін инициализациялау үшін мәнді табу . Біз жай ғана nxs[0] пайдалана алмаймыз , себебі бұл элемент немесе тізім болуы мүмкін. Бұл мәселені шешу үшін (әрбір рекурсивті шақыруда) логикалық жалаушаны инициализациялаймыз (8-жолда). Қызығушылықтың мәнін тапқан кезде (15-жолда) бұл large үшін инициализациялау (бірінші) мән немесе ең үлкен мәнін өзгертуі мүмкін мән екенін тексереміз .

Мұнда тағы да бізде 13-жолда негізгі жағдай бар. Егер біз негізгі жағдайды бермесек, Python максималды рекурсия тереңдігіне жеткеннен кейін тоқтайды және орындалу қатесін қайтарады. Бұл қалай болатынын қараңыз, біз infinite_recursion.py деп аталатын шағын сценарийді іске қосу арқылы :

```python
def recursion_depth(number):
    print("{0}, ".format(number), end="")
    recursion_depth(number + 1)

recursion_depth(0)
```

Хабарламалардың жыпылықтауын көргеннен кейін сізге келесідей хабарламамен аяқталатын ұзақ бақылаудың соңы ұсынылады:

```python
RuntimeError: maximum recursion depth exceeded ...
```

Біз, әрине, бағдарламаларымыздың бірінің пайдаланушысымен мұндай жағдайдың болғанын ешқашан қаламас едік, сондықтан келесі тарауда Python тілінде қателерді, кез келген қателерді қалай өңдейтінін көреміз.

## 16.4. Жағдайды зерттеу: Фибоначчи сандары

Әйгілі Фибоначчи тізбегі 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 134, ... Фибоначчи (1170-1250) ойлап тапқан, ол оны өсіруді модельдеу үшін пайдаланған. қояндардың (жұптары). Егер 7-ші ұрпақта сізде барлығы 21 жұп болса, оның 13-і ересек болса, келесі ұрпақ ересектердің барлығы жаңа балаларды туып, алдыңғы балалар өсіп, ересек болады. Сонымен, 8 ұрпақта сізде 13+21=34 болады, оның 21-і ересектер.

Қоян өсіруді түсіндіруге арналған бұл модель қояндар ешқашан өлмейді деген жеңілдететін болжамды жасады. Ғалымдар мәселені шешуде біршама алға жылжу үшін жиі жеңілдететін болжамдар мен шектеулер жасайды (шынайы емес).

Егер тізбектің мүшелерін 0-ден бастап нөмірлесек, біз әрбір терминді алдыңғы екі мүшенің қосындысы ретінде рекурсивті сипаттай аламыз:


```python
fib(0) = 0
fib(1) = 1
fib(n) = fib(n-1) + fib(n-2)  for n >= 2
```

Бұл кейбір Python тіліне тікелей аударылады:

```python
def fib(n):
    if n <= 1:
        return n
    t = fib(n-1) + fib(n-2)
    return t
```

Бұл әсіресе тиімсіз алгоритм және сөздіктер туралы білгенде оны түзетудің бір жолын көрсетеміз:

```python
import time
t0 = time.clock()
n = 35
result = fib(n)
t1 = time.clock()

print("fib({0}) = {1}, ({2:.2f} secs)".format(n, result, t1-t0))
```

Біз дұрыс нәтиже аламыз, бірақ жұмыстың үлкен көлемі!

```python
fib(35) = 9227465, (10.54 secs)
```

## 16.5. Рекурсивті каталогтар мен файлдармен мысал

Келесі бағдарлама каталогтың және оның барлық ішкі каталогтарының мазмұнын тізімдейді.

```python
import os

def get_dirlist(path):
    """
      Return a sorted list of all entries in path.
      This returns just the names, not the full path to the names.
    """
    dirlist = os.listdir(path)
    dirlist.sort()
    return dirlist

def print_files(path, prefix = ""):
    """ Print recursive listing of contents of path """
    if prefix == "":  # Detect outermost call, print a heading
        print("Folder listing for", path)
        prefix = "| "

    dirlist = get_dirlist(path)
    for f in dirlist:
        print(prefix+f)                    # Print the line
        fullname = os.path.join(path, f)   # Turn name into full pathname
        if os.path.isdir(fullname):        # If a directory, recurse.
            print_files(fullname, prefix + "| ")
```

print_files функциясын кейбір қалта атауымен шақыру келесідей нәтиже береді:

```python
Folder listing for c:\python31\Lib\site-packages\pygame\examples
| __init__.py
| aacircle.py
| aliens.py
| arraydemo.py
| blend_fill.py
| blit_blends.py
| camera.py
| chimp.py
| cursors.py
| data
| | alien1.png
| | alien2.png
| | alien3.png
...
```

## 16.6. PyGame көмегімен анимациялық фрактал

Мұнда бізде 8 ретті ағаш фракталды үлгісі бар. Біз әрбір жиек сызылған рекурсияның тереңдігін көрсететін кейбір жиектерді белгіледік.

![tree](https://user-images.githubusercontent.com/84173441/176164950-ae72fd4c-0d90-400c-93ca-113feefa3b1a.JPG)

Жоғарыдағы ағашта магистральдан ауытқу бұрышы 30 градус. Бұл бұрышты өзгерту басқа қызықты пішіндерді береді, мысалы, 90 градус бұрышпен біз мынаны аламыз:

![afterTree](https://user-images.githubusercontent.com/84173441/176164987-5c4bb343-1977-482b-a960-3d85fd134b14.JPG)

Ағаштарды өте жылдам жасап, әр жолы бұрышты аздап өзгертетін болсақ, қызықты анимация пайда болады. Тасбақа модулі осындай ағаштарды өте талғампаз түрде тарта алатынына қарамастан, біз жақсы кадр жиілігі үшін күресуіміз мүмкін. Сондықтан біз оның орнына бірнеше әшекейлер мен бақылаулармен PyGame қолданамыз. (Тағы да осы кодты Python ортаңызға қиып, қоюды ұсынамыз.)

```python
import pygame, math
pygame.init()           # prepare the pygame module for use

# Create a new surface and window.
surface_size = 1024
main_surface = pygame.display.set_mode((surface_size,surface_size))
my_clock = pygame.time.Clock()


def draw_tree(order, theta, sz, posn, heading, color=(0,0,0), depth=0):

   trunk_ratio = 0.29       # How big is the trunk relative to whole tree?
   trunk = sz * trunk_ratio # length of trunk
   delta_x = trunk * math.cos(heading)
   delta_y = trunk * math.sin(heading)
   (u, v) = posn
   newpos = (u + delta_x, v + delta_y)
   pygame.draw.line(main_surface, color, posn, newpos)

   if order > 0:   # Draw another layer of subtrees

      # These next six lines are a simple hack to make the two major halves
      # of the recursion different colors. Fiddle here to change colors
      # at other depths, or when depth is even, or odd, etc.
      if depth == 0:
          color1 = (255, 0, 0)
          color2 = (0, 0, 255)
      else:
          color1 = color
          color2 = color

      # make the recursive calls to draw the two subtrees
      newsz = sz*(1 - trunk_ratio)
      draw_tree(order-1, theta, newsz, newpos, heading-theta, color1, depth+1)
      draw_tree(order-1, theta, newsz, newpos, heading+theta, color2, depth+1)


def gameloop():

    theta = 0
    while True:

        # Handle evente from keyboard, mouse, etc.
        ev = pygame.event.poll()
        if ev.type == pygame.QUIT:
            break;

        # Updates - change the angle
        theta += 0.01

        # Draw everything
        main_surface.fill((255, 255, 0))
        draw_tree(9, theta, surface_size*0.9, (surface_size//2, surface_size-50), -math.pi/2)

        pygame.display.flip()
        my_clock.tick(120)


gameloop()
pygame.quit()
```

Математикалық кітапхана градуспен емес, радиандағы бұрыштармен жұмыс істейді .

14 және 15-жолдарда кейбір орта мектеп тригонметриясы қолданылады. Қажетті сызықтың ұзындығынан ( магистраль ) және оның қалаған бұрышынан cos және sin бізге жылжытуымыз керек x және y қашықтықтарын есептеуге көмектеседі .

22-30 жолдар қажет емес, егер біз түрлі-түсті ағаш алғымыз келсе.

Негізгі ойын циклінде 49-жолда біз әрбір кадрдың бұрышын өзгертеміз және жаңа ағашты қайта саламыз.

18-жолда PyGame сонымен қатар сызықтар және тағы басқалар сыза алатынын көрсетеді. Құжаттаманы тексеріңіз. Мысалы, ағаштың әрбір бұтақ нүктесінде шағын шеңбер салуды осы сызықты тікелей 18-жолдың астына қосу арқылы орындауға болады:

```python
pygame.draw.circle(main_surface, color, (int(posn[0]), int(posn[1])), 3)
```

Тағы бір қызықты әсер – тағы бір нұсқаушы, егер сіз рекурсияның әртүрлі тереңдіктерінде шақырылатын функцияның әртүрлі даналарының идеясын күшейткіңіз келсе – түстер тізімін жасау және әр рекурсивті тереңдікке сурет салу үшін басқа түсті пайдалануға мүмкіндік беру. (Түстер тізімін индекстеу үшін рекурсияның тереңдігін пайдаланыңыз.)

## 16.7. Глоссарий

негізгі корпус
Ары қарай рекурсивті шақыруларды тудырмайтын рекурсивті функциядағы шартты оператордың тармағы.
шексіз рекурсия
Ешқашан негізгі регистрге жетпестен өзін рекурсивті шақыратын функция. Ақыр соңында, шексіз рекурсия орындау уақытының қатесін тудырады.
рекурсия
Орындалып тұрған функцияны шақыру процесі.
рекурсивті шақыру
Қазірдің өзінде орындалатын функцияны шақыратын мәлімдеме. Рекурсия да жанама болуы мүмкін — f функциясы h шақыратын g шақыруы мүмкін , ал h f функциясына кері шақыруы мүмкін .
рекурсивті анықтама
Бір нәрсені өзі тұрғысынан анықтайтын анықтама. Пайдалы болу үшін ол рекурсивті емес негізгі жағдайларды қамтуы керек. Осылайша ол дөңгелек анықтамадан ерекшеленеді . Рекурсивті анықтамалар басқа каталогтарды қамтитын каталог немесе басқа мәзірлерді қамтитын мәзір сияқты күрделі деректер құрылымдарын көрсетудің талғампаз әдісін қамтамасыз етеді.

## 16.8. Жаттығулар

Кох фракталды бағдарламасын келесідей Кох қар ұшқынын салатындай етіп өзгертіңіз:

![ex1](https://user-images.githubusercontent.com/84173441/176165035-f05e3157-4f55-45a6-9ec2-507c47a66264.JPG)

Пайдаланушы берген ретпен Cesaro үзілген сызық фракталы сызыңыз. Біз 0,1,2,3 реттік төрт түрлі жолды көрсетеміз. Бұл мысалда жыртылу бұрышы 10 градус.

![ex2](https://user-images.githubusercontent.com/84173441/176165070-707f2197-1be6-496e-97c5-b3c935985c20.JPG)

Төрт сызық төртбұрышты құрайды. Кезаро квадраттарын салу үшін а) бөлігіндегі кодты пайдаланыңыз. Бұрыштың өзгеруі қызықты әсерлер береді - аздап тәжірибе жасаңыз немесе пайдаланушыға жыртылу бұрышын енгізуге мүмкіндік беріңіз.

![ex2b](https://user-images.githubusercontent.com/84173441/176165103-e0a1e745-1d68-456b-9da1-8073cdff101a.JPG)

(Математикаға бейімдер үшін). Мұнда көрсетілген квадраттарда жоғары ретті сызбалар сәл үлкейеді. (Әр шаршының төменгі жолын қараңыз – олар тураланбаған.) Себебі біз әрбір рекурсивті ішкі мәселе үшін сызықтың сызылған бөлігін екі есеге қысқарттық. Осылайша, біз жалпы шаршыны жыртылатын (лар) енімен «өсірдік». Сіз геометриялық есепті шеше аласыз ба, осылайша ішкі мәселенің жалпы өлшемі (жыртылуды қоса) түпнұсқамен бірдей өлшемде қалады?

0 ретті Сьерпинский үшбұрышы тең қабырғалы үшбұрыш болып табылады. 1 реттік үшбұрышты 3 кішірек үшбұрыш салу арқылы салуға болады (бұл жерде аздап ажыратылған, түсінуге көмектесу үшін көрсетілген). Жоғары ретті 2 және 3 үшбұрыштар да көрсетілген. Пайдаланушы енгізген кез келген тапсырыстың Sierpinski үшбұрыштарын салыңыз.

![ex3](https://user-images.githubusercontent.com/84173441/176165132-2b4481c1-504e-422a-919d-20d597ecdbc2.JPG)

Рекурсияның белгілі бір тереңдігінде оның үш ішкі үшбұрышының түсін өзгерту үшін жоғарыдағы бағдарламаны бейімдеңіз. Төмендегі суретте екі жағдай көрсетілген: сол жақта түс 0 тереңдікте (рекурсияның ең жоғарғы деңгейі), оң жақта, 2 тереңдікте өзгереді. Пайдаланушы теріс тереңдік берсе, түс ешқашан өзгермейді. (Кеңес: жаңа қосымша colorChangeDepth параметрін қосыңыз (ол әдепкі мәні -1) және оны әрбір рекурсивті қосалқы шақыруда кішірейтіңіз. Содан кейін, қайталамас бұрын код бөлімінде параметрдің нөл екенін тексеріп, түсін өзгертіңіз.)

![ex4](https://user-images.githubusercontent.com/84173441/176165171-184326b8-1765-4050-9298-301844cbd1ac.JPG)

Кірістірілген сандар тізіміндегі ең кіші мәнді қайтаратын recursive_min функциясын жазыңыз . Ешқандай бос тізімдер немесе ішкі тізімдер жоқ делік:

```python
test(recursive_min([2, 9, [1, 13], 8, 6]) == 1)
test(recursive_min([2, [[100, 1], 90], [10, 13], 8, 6]) == 1)
test(recursive_min([2, [[13, -7], 90], [1, 100], 8, 6]) == -7)
test(recursive_min([[[-13, 7], 90], 2, [1, 100], 8, 6]) == -13)
```

Кірістірілген тізімдегі мақсаттың қайталану санын қайтаратын функция санын жазыңыз:

```python
test(count(2, []), 0)
test(count(2, [2, 9, [2, 1, 13, 2], 8, [2, 6]]) == 4)
test(count(7, [[9, [7, 1, 13, 2], 8], [7, 6]]) == 2)
test(count(15, [[9, [7, 1, 13, 2], 8], [2, 6]]) == 0)
test(count(5, [[5, [5, [1, 5], 5], 5], [5, 6]]) == 6)
test(count("a",
     [["this",["a",["thing","a"],"a"],"is"], ["a","easy"]]) == 4)
```

Кірістірілген тізімдегі барлық мәндерді қамтитын қарапайым тізімді қайтаратын тегістеу функциясын жазыңыз :

```python
test(flatten([2,9,[2,1,13,2],8,[2,6]]) == [2,9,2,1,13,2,8,2,6])
test(flatten([[9,[7,1,13,2],8],[7,6]]) == [9,7,1,13,2,8,7,6])
test(flatten([[9,[7,1,13,2],8],[2,6]]) == [9,7,1,13,2,8,2,6])
test(flatten([["this",["a",["thing"],"a"],"is"],["a","easy"]]) ==
              ["this","a","thing","a","is","a","easy"])
test(flatten([]) == [])
```

Фибоначчи алгоритмін рекурсияны қолданбай қайта жазыңыз. Сіз тізбектің үлкенірек шарттарын таба аласыз ба? fib(200) таба аласыз ба ?

sys.getrecursionlimit() және sys.setrecursionlimit(n) не істейтінін білу үшін анықтаманы пайдаланыңыз . Бұл модуль функцияларының қалай жұмыс істейтінін түсінуді тексеру үшін infinite_recursion.py файлында жасалғанға ұқсас бірнеше эксперимент жасаңыз .

Каталог құрылымы бойынша жүретін бағдарламаны жазыңыз (осы тараудың соңғы бөліміндегідей), бірақ файл атауларын басып шығарудың орнына ол каталогтағы немесе ішкі каталогтардағы файлдардың барлық толық жолдарының тізімін қайтарады. (Бұл тізімге каталогтарды қоспаңыз — тек файлдар.) Мысалы, шығыс тізімінде келесідей элементтер болуы мүмкін:


```python
["C:\Python31\Lib\site-packages\pygame\docs\ref\mask.html",
 "C:\Python31\Lib\site-packages\pygame\docs\ref\midi.html",
 ...
 "C:\Python31\Lib\site-packages\pygame\examples\aliens.py",
 ...
 "C:\Python31\Lib\site-packages\pygame\examples\data\boom.wav",
 ... ]
```

Аргумент ретінде ағаштың түбірі (немесе әдепкі ретінде ағымдағы каталог) берілген каталогтар ағашының әрбір ішкі каталогында trash.txt атты бос файлды жасайтын litter.py атты бағдарламаны жазыңыз . Енді осы файлдардың барлығын жойатын cleanup.py атты бағдарламаны жазыңыз .

№1 кеңес: Осы тараудың соңғы бөліміндегі мысалдағы бағдарламаны осы екі рекурсивті бағдарламаның негізі ретінде пайдаланыңыз. Дискілеріңіздегі файлдарды жойғыңыз келетіндіктен, мұны дұрыс орындағаныңыз жөн, әйтпесе сізді қызықтыратын файлдарды жоғалту қаупі бар. Ең жақсы кеңес, бастапқыда файлдарды жоюды қолдан жасау керек — жойғыңыз келетін әрбір файлдың толық жол атауларын басып шығарыңыз. Логикаңыздың дұрыс екеніне қуанғаннан кейін және сіз дұрыс емес нәрселерді жоймайтыныңызды байқасаңыз, басып шығару мәлімдемесін нақты нәрсемен ауыстыруға болады.

№2 кеңес: файлдарды жоятын функцияны OS модулінен іздеңіз .


--- 

Рекурсияның тағы бір коды 

```python
import turtle

import turtle             # turtles деп аталатын модульді пайдалануға мүмкіндік береді
wn = turtle.Screen()      # тасбақалар қозғалатын ойын алаңын жасайды
tess = turtle.Turtle()    # тасбақа жасаймыз, оны alex айнымалысына тағайындаймыз
turtle.screensize(canvwidth=6000, canvheight=6000, bg="cyan")


def koch(tortoise, order, size):
    """
       Make turtle tortoise draw a Koch fractal of 'order' and 'size'.
       Leave the turtle facing the same direction.

       Тасбақа tortoise «тәртіп» және «өлшем» бойынша Кох фракталын салсын.
       Тасбақа сол бағытта беттеп қала берсін.
    """

    if order == 0:  # The base case is just a straight line. Базалық жағдай жәй ғана түзу сызық
        tortoise.forward(size)
    else:
        koch(tortoise, order - 1, size / 3)  # Go 1/3 of the way. Жолдың 1/3-ін жүріп өт
        tortoise.left(60)
        koch(tortoise, order - 1, size / 3)
        tortoise.right(120)
        koch(tortoise, order - 1, size / 3)
        tortoise.left(60)
        koch(tortoise, order - 1, size / 3)


koch (tess, 5, 1500)

wn.mainloop()
```

