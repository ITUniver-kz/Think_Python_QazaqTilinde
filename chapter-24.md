---
title: PyGame
isFree: True
---

## 17. PyGame

PyGame – стандартты Python дистрибутивінің бөлігі болып табылмайтын бума, сондықтан ол әлі орнатылмаған болса (яғни , pygame импорты сәтсіз аяқталса), http://pygame.org/download.shtml сайтынан сәйкес нұсқаны жүктеп алып, орнатыңыз . Бұл ескертпелер жазу кезіндегі ең соңғы нұсқасы PyGame 1.9.1 негізінде жасалған.

PyGame оқулықтардың, мысалдардың және анықтамалардың айтарлықтай жиынтығымен бірге келеді, сондықтан кодта өзіңізді кеңейтуге мүмкіндік мол. Бұл ресурстарды табу үшін сізге аздап қарау қажет болуы мүмкін, бірақ: егер сіз PyGame-ді Windows құрылғысына орнатқан болсаңыз, мысалы, олар C:\Python31\Lib\site-packages\pygame сияқты қалтада болады. \ мұнда сіз құжаттар мен мысалдар үшін каталогтарды таба аласыз .

## 17.1. Ойын циклі

Біз қарастыратын ойындардың құрылымы әрқашан осы бекітілген үлгіге сәйкес келеді:

![pyGame_1](https://user-images.githubusercontent.com/84173441/176385023-63062c18-984a-45be-bdd0-ae51acddfd63.JPG)

Әрбір ойында орнату бөлімінде біз терезе жасаймыз, кейбір мазмұнды жүктеп, дайындаймыз, содан кейін ойын цикліне кіреміз . Ойын циклі үздіксіз төрт негізгі әрекетті орындайды:

ол оқиғалар үшін сауалнама жүргізеді , яғни жүйеден оқиғалардың орын алғанын сұрайды және тиісті жауап береді,
ол өзгертуді қажет ететін ішкі деректер құрылымдарын немесе нысандарын жаңартады,
ол ойынның ағымдағы күйін (көрінбейтін) бетке тартады,
ол жаңа ғана сызылған бетті дисплейге қояды.

```python
import pygame

def main():
    """ Set up the game and run the main game loop """
    pygame.init()      # Prepare the pygame module for use
    surface_sz = 480   # Desired physical surface size, in pixels.

    # Create surface of (width, height), and its window.
    main_surface = pygame.display.set_mode((surface_sz, surface_sz))

    # Set up some data to describe a small rectangle and its color
    small_rect = (300, 200, 150, 90)
    some_color = (255, 0, 0)        # A color is a mix of (Red, Green, Blue)

    while True:
        ev = pygame.event.poll()    # Look for any event
        if ev.type == pygame.QUIT:  # Window close button clicked?
            break                   #   ... leave game loop

        # Update your game objects and data structures here...

        # We draw everything from scratch on each frame.
        # So first fill everything with the background color
        main_surface.fill((0, 200, 255))

        # Overpaint a smaller rectangle on the main surface
        main_surface.fill(some_color, small_rect)

        # Now the surface is ready, tell pygame to display it!
        pygame.display.flip()

    pygame.quit()     # Once we leave the loop, close the window.

main()
```

Бұл бағдарлама терезені ашады, ол біз оны жапқанша сол жерде қалады:

![PyGame_2](https://user-images.githubusercontent.com/84173441/176385458-f4245671-f227-4464-8858-ee7ec14c2962.JPG)

PyGame барлық суретін төртбұрышты беттерге жасайды . 5-жолда PyGame іске қосылғаннан кейін біз негізгі бетті ұстайтын терезені жасаймыз. Ойынның негізгі циклі келесі логикалық биттермен 15-тен 30-ға дейін созылады:

Алдымен (16-жол) біз үшін дайын болуы мүмкін келесі оқиғаны алу үшін сауалнама жүргіземіз. Бұл қадам әрқашан бізді қызықтыратын кез келген оқиғаның орын алған-болмағанын анықтайтын кейбір шартты мәлімдемелерден кейін болады. PyGame-ге қатысты оқиға үшін сауалнама оны жұмсайды, сондықтан біз әрбір оқиғаны алу және пайдалану үшін бір ғана мүмкіндік аламыз. 17-жолда оқиға түрі pygame.QUIT деп аталатын алдын ала анықталған тұрақты болып табылатынын тексереміз. Бұл пайдаланушы PyGame терезесіндегі жабу түймесін басқанда көретін оқиға. Осы оқиғаға жауап ретінде біз циклды қалдырамыз.
Біз циклден шыққаннан кейін, 32-жолдағы код терезені жабады және біз main функциясынан ораламыз . Сіздің бағдарламаңыз басқа әрекеттерді орындауға немесе pygame-ді қайта инициализациялауға және басқа терезе жасауға болады, бірақ ол әдетте аяқталады.
Оқиғалардың әртүрлі түрлері бар — пернені басу, тінтуірдің қозғалысы, тінтуірдің басуы, джойстик қозғалысы және т.б. Біз бұл жағдайлардың барлығын 19-жолдың алдында сығымдалған жаңа кодпен тексереміз және өңдейміз. Жалпы идея: «алдымен оқиғаларды өңдеңіз, содан кейін басқа нәрселер туралы алаңдаңыз».
20-жолда біз нысандарды немесе деректерді жаңартамыз — мысалы, біз сызатын тіктөртбұрыштың түсін, орнын немесе өлшемін өзгерткіміз келсе, мұнда some_color және small_rect қайта тағайындаймыз .
Ойындарды жазудың заманауи тәсілі (қазір бізде жылдам компьютерлер мен жылдам графикалық карталар бар) ойын циклінің әрбір итерациясында барлығын нөлден бастап қайта салу болып табылады. Сонымен, 24-жолда жасайтын бірінші нәрсе - бүкіл бетті фон түсімен толтыру. Беттің толтыру әдісі екі дәлелді қажет етеді: толтыру үшін қолданылатын түс және толтырылатын тіктөртбұрыш. Бірақ екінші аргумент міндетті емес, ал егер ол қалдырылса, бүкіл бет толтырылады.
27-жолда біз екінші тіктөртбұрышты толтырамыз, бұл жолы some_color көмегімен . Тіктөртбұрыштың орналасуы мен өлшемі small_rect кортежімен беріледі , 4 элементтен тұратын кортеж (x, y, ені, биіктігі) .
PyGame бетінің шығу тегі жоғарғы сол жақ бұрышта (экранның ортасына шыққан тасбақа модулінен айырмашылығы) екенін түсіну маңызды. Сонымен, егер сіз тіктөртбұрышты терезенің жоғарғы жағына жақындатқыңыз келсе, оның у координатын кішірейтуіңіз керек.
Егер графикалық дисплейдің аппараттық құралы бағдарлама сол жадқа жазып жатқан кезде бір уақытта жадтан оқуға әрекет жасаса, олар бір-біріне кедергі жасап, бейне шуы мен жыпылықтауын тудырады. Мұны айналып өту үшін PyGame негізгі бетінде екі буферді сақтайды — бағдарлама тартатын артқы буфер , ал алдыңғы буфер пайдаланушыға көрсетіліп жатыр. Бағдарлама өзінің артқы буферін толығымен дайындаған сайын, ол екі буфердің артқы/алдыңғы рөлін ауыстырады. Сонымен, 24 және 27-жолдардағы сызба 30-жолдағы буферлерді аудармайынша экранда көрінетін нәрсені өзгертпейді .


## 17.2. Суреттер мен мәтінді көрсету

Негізгі бетке сурет салу үшін суретті, айталық жағажай шарын өзінің жаңа бетіне жүктейміз. Негізгі бетінде жағажай шарының бетінен пикселдерді өз бетіне көшіретін блит әдісі бар. Біз blit деп атаған кезде жағажай допын негізгі бетке қай жерде орналастыру керектігін анықтай аламыз. Блит термині компьютерлік графикада кеңінен қолданылады және жадтың бір аймағынан екіншісіне пикселдердің жылдам көшірмесін жасауды білдіреді .

Сонымен, орнату бөлімінде, ойын цикліне кірмес бұрын, суретті келесідей жүктейміз:


```python
ball = pygame.image.load("ball.png")
```

және жоғарыдағы бағдарламадағы 28 жолдан кейін суретімізді (100,120) позицияда көрсету үшін осы кодты қосамыз:

```python
main_surface.blit(ball, (100, 120))
```

Мәтінді көрсету үшін бізге үш әрекетті орындау керек. Ойын цикліне кірмес бұрын, біз қаріп нысанын жасаймыз:

```python
# Instantiate 16 point Courier font to draw text.
my_font = pygame.font.SysFont("Courier", 16)
```

және 28-жолдан кейін біз қайтадан қаріптің көрсету әдісін қолданып, сызылған мәтіннің пикселдерін қамтитын жаңа бетті жасаймыз, содан кейін кескіндер жағдайындағыдай, біз жаңа бетті негізгі бетке жылтыратамыз. Рендерлеу екі қосымша параметрді қажет ететініне назар аударыңыз — екіншісі сурет салу кезінде мәтіннің жиектерін мұқият тегістеу керектігін айтады (бұл процесс антиалиасинг деп аталады ) , ал екіншісі - мәтін мәтіні қалайтын түс. Мұнда біз қара түсті (0,0,0) қолдандық:

```python
the_text = my_font.render("Hello, world!", True, (0,0,0))
main_surface.blit(the_text, (10, 10))
```

Біз осы екі жаңа мүмкіндікті фреймдерді санау — ойын циклінің итерациялары — және біраз уақыт ақпаратын сақтау арқылы көрсетеміз. Әрбір кадрда кадр санын және кадр жиілігін көрсетеміз. Біз кадр жиілігін әрбір 500 кадрдан кейін ғана жаңартамыз, біз уақыт аралығын қарап, есептеулерді жасай аламыз.

```python
import pygame
import time

def main():

    pygame.init()    # Prepare the PyGame module for use
    main_surface = pygame.display.set_mode((480, 240))

    # Load an image to draw. Substitute your own.
    # PyGame handles gif, jpg, png, etc. image types.
    ball = pygame.image.load("ball.png")

    # Create a font for rendering text
    my_font = pygame.font.SysFont("Courier", 16)

    frame_count = 0
    frame_rate = 0
    t0 = time.clock()

    while True:

        # Look for an event from keyboard, mouse, joystick, etc.
        ev = pygame.event.poll()
        if ev.type == pygame.QUIT:   # Window close button clicked?
            break                    # Leave game loop

        # Do other bits of logic for the game here
        frame_count += 1
        if frame_count % 500 == 0:
            t1 = time.clock()
            frame_rate = 500 / (t1-t0)
            t0 = t1

        # Completely redraw the surface, starting with background
        main_surface.fill((0, 200, 255))

        # Put a red rectangle somewhere on the surface
        main_surface.fill((255,0,0), (300, 100, 150, 90))

        # Copy our image to the surface, at this (x,y) posn
        main_surface.blit(ball, (100, 120))

        # Make a new surface with an image of the text
        the_text = my_font.render("Frame = {0},  rate = {1:.2f} fps"
                  .format(frame_count, frame_rate), True, (0,0,0))
        # Copy the text surface to the main surface
        main_surface.blit(the_text, (10, 10))

        # Now that everything is drawn, put it on display!
        pygame.display.flip()

    pygame.quit()


main()
```

Кадр жиілігі күлкіліге жақын — кадрларды көзбен өңдеуге қарағанда әлдеқайда жылдам. (Коммерциялық бейне ойындар әдетте өз әрекетін секундына 60 кадрға (fps) жоспарлайды.) Әрине, ойын циклінің ішінде біршама күштірек нәрсені жасай бастағанда, жылдамдығымыз төмендейді.

![PyGame_3](https://user-images.githubusercontent.com/84173441/176385965-2d62439f-da60-47f6-8e62-4bc282c533e7.JPG)

## 17.3. N Queens пазлы үшін тақтаны салу

Біз бұрын N Queens жұмбақ шештік. 8x8 тақтасы үшін шешімдердің бірі тізім болды \[6,4,2,0,5,7,1,3] . Бұл шешімді сынақ деректері ретінде қолданайық, ал енді PyGame көмегімен шахмат тақтасын ханшайымдарымен бірге салайық.

Біз сурет коды үшін draw_queens.py деп аталатын жаңа модуль жасаймыз . Сынақ жағдай(лар)ымыз жұмыс істеп тұрғанда, біз шешушіге оралып, осы жаңа модульді импорттай аламыз және шешім табылған сайын тақтаны салу үшін жаңа функциямызға шақыруды қоса аламыз.

Біз тақтаға арналған қара және қызыл шаршылардың фонынан бастаймыз. Мүмкін біз жүктей алатын және сызатын кескін жасай алар едік, бірақ бұл тәсіл әртүрлі өлшемді тақталар үшін әртүрлі фондық кескіндерді қажет етеді. Сәйкес өлшемдегі өзіміздің қызыл және қара тіктөртбұрыштарымызды салу әлдеқайда қызықты көрінеді!

```python
def draw_board(the_board):
    """ Draw a chess board with queens, from the_board. """

    pygame.init()
    colors = [(255,0,0), (0,0,0)]    # Set up colors [red, black]

    n = len(the_board)         # This is an NxN chess board.
    surface_sz = 480           # Proposed physical surface size.
    sq_sz = surface_sz // n    # sq_sz is length of a square.
    surface_sz = n * sq_sz     # Adjust to exactly fit n squares.

    # Create the surface of (width, height), and its window.
    surface = pygame.display.set_mode((surface_sz, surface_sz))
```

Мұнда біз шаршыларды қол жетімді терезеге жақсы орналастыру үшін sq_sz , әрбір шаршы болатын бүтін өлшемді алдын ала есептейміз. Сонымен, егер біз тақтаның 480x480 болуын қаласақ және біз 8x8 шахмат тақтасын салсақ, онда әрбір шаршының өлшемі 60 бірлік болуы керек. Бірақ біз 7x7 тақтасы 480-ге жақсы сәйкес келмейтінін байқаймыз - біз квадраттарымыз дәл толтырмайтын кейбір жағымсыз жиекті аламыз. Сондықтан біз терезені жасамас бұрын квадраттарымызға дәл сәйкестендіру үшін бет өлшемін қайта есептейміз.

Енді ойын циклында шаршыларды саламыз. Бізге кірістірілген цикл қажет: сыртқы цикл шахмат тақтасының жолдарының үстінен, ішкі цикл бағандардың үстінен өтеді:

```python
# Draw a fresh background (a blank chess board)
for row in range(n):           # Draw each row of the board.
    c_indx = row % 2           # Change starting color on each row
    for col in range(n):       # Run through cols drawing squares
        the_square = (col*sq_sz, row*sq_sz, sq_sz, sq_sz)
        surface.fill(colors[c_indx], the_square)
        # now flip the color index for the next square
        c_indx = (c_indx + 1) % 2
```

Бұл кодта екі маңызды идея бар: біріншіден, олардың орнын алу үшін жол және col циклінің айнымалы мәндерінен толтырылатын тіктөртбұрышты есептейміз, оларды квадрат өлшеміне көбейтеміз. Және, әрине, әрбір шаршы бекітілген ені мен биіктігі. Сонымен , шаршы циклдің ағымдағы итерациясында толтырылатын тіктөртбұрышты білдіреді. Екінші идея - біз әр шаршыда түстерді алмастыруымыз керек. Бұрынғы орнату кодында біз екі түсті қамтитын тізімді жасадық, мұнда әр жолды алдыңғы жолдың бастапқы түсінен өзгеше түстен бастау және түстерді ауыстыру үшін c_indx (әрдайым 0 немесе 1 мәні болады) өңдейміз. шаршы толтырылған сайын.

Бұл (дисплейге бетті аудару үшін көрсетілмеген басқа фрагменттермен бірге) әртүрлі өлшемді тақталар үшін келесідей жағымды фонға әкеледі:

![PyGame_4](https://user-images.githubusercontent.com/84173441/176386211-897a8f68-eacd-4e91-a361-d53d673b0595.JPG)

Енді ханшайымдарды салуға көшейік! Еске салайық, біздің шешім \[6,4,2,0,5,7,1,3] тақтаның 0-бағанында 6-жолда патшайым, 1-бағанда 4-жолда патшайым керек дегенді білдіреді және т.б. қосулы. Сондықтан бізге әрбір ханшайымның үстінен өтетін цикл қажет:

```python
for (col, row) in enumerate(the_board):
    # draw a queen at col, row...
```

Бұл тарауда бізде жағажай допының суреті бар, сондықтан оны ханшайымдарымыз үшін қолданамыз. Ойын циклінің алдындағы орнату кодында біз доп кескінін жүктейміз (бұрынғыдай) және циклдің негізгі бөлігіне жолды қосамыз:

```python
surface.blit(ball, (col * sq_sz, row * sq_sz))
```

![PyGame_5](https://user-images.githubusercontent.com/84173441/176386391-1ba19e72-7041-40f8-85e2-9a99cbb9ad73.JPG)

Біз жетіп жатырмыз, бірақ бұл патшайымдар өз алаңдарында орналасуы керек! Біздің мәселе доптың да, тіктөртбұрыштың да тірек нүктелері ретінде жоғарғы сол жақ бұрышы болатындығынан туындайды. Егер біз бұл допты шаршының ортасына орналастыратын болсақ, оған x және y бағытында қосымша ығысу беруіміз керек. (Доп дөңгелек және шаршы шаршы болғандықтан, екі бағыттағы ығысу бірдей болады, сондықтан біз тек бір ығысу мәнін есептеп, оны екі бағытта да қолданамыз.)

Бізге қажет офсет жартысы (шаршы өлшемі шардың өлшемінен аз). Сондықтан біз допты жүктеп алып, шаршы өлшемін анықтағаннан кейін ойынның орнату бөлімінде алдын ала есептейміз:

```python
ball_offset = (sq_sz - ball.get_width()) // 2
```

Енді біз доптың сурет кодын түртеміз және біз аяқтадық:

```python
surface.blit(ball, (col * sq_sz + ball_offset, row * q_sz + ball_offset))
```

Біз жай ғана доп шаршыдан үлкен болған жағдайда не болатынын ойлағымыз келуі мүмкін. Бұл жағдайда ball_offset теріс болады. Осылайша, ол әлі де шаршының ортасында болады - ол жай ғана шекарадан асып кетеді немесе алаңды толығымен жасырады!

Мұнда толық бағдарлама:

```python
import pygame

def draw_board(the_board):
    """ Draw a chess board with queens, as determined by the the_board. """

    pygame.init()
    colors = [(255,0,0), (0,0,0)]    # Set up colors [red, black]

    n = len(the_board)         # This is an NxN chess board.
    surface_sz = 480           # Proposed physical surface size.
    sq_sz = surface_sz // n    # sq_sz is length of a square.
    surface_sz = n * sq_sz     # Adjust to exactly fit n squares.

    # Create the surface of (width, height), and its window.
    surface = pygame.display.set_mode((surface_sz, surface_sz))

    ball = pygame.image.load("ball.png")

    # Use an extra offset to centre the ball in its square.
    # If the square is too small, offset becomes negative,
    #   but it will still be centered :-)
    ball_offset = (sq_sz-ball.get_width()) // 2

    while True:

        # Look for an event from keyboard, mouse, etc.
        ev = pygame.event.poll()
        if ev.type == pygame.QUIT:
            break;

        # Draw a fresh background (a blank chess board)
        for row in range(n):           # Draw each row of the board.
            c_indx = row % 2           # Alternate starting color
            for col in range(n):       # Run through cols drawing squares
                the_square = (col*sq_sz, row*sq_sz, sq_sz, sq_sz)
                surface.fill(colors[c_indx], the_square)
                # Now flip the color index for the next square
                c_indx = (c_indx + 1) % 2

        # Now that squares are drawn, draw the queens.
        for (col, row) in enumerate(the_board):
          surface.blit(ball,
                   (col*sq_sz+ball_offset,row*sq_sz+ball_offset))

        pygame.display.flip()


    pygame.quit()

if __name__ == "__main__":
    draw_board([0, 5, 3, 1, 6, 4, 2])    # 7 x 7 to test window size
    draw_board([6, 4, 2, 0, 5, 7, 1, 3])
    draw_board([9, 6, 0, 3, 10, 7, 2, 4, 12, 8, 11, 5, 1])  # 13 x 13
    draw_board([11, 4, 8, 12, 2, 7, 3, 15, 0, 14, 10, 6, 13, 1, 5, 9])
```

Бұл жерде тағы бір қарап шығуға тұрарлық нәрсе бар. 50-жолдағы шартты оператор ағымдағы орындалатын бағдарламаның аты __main__ екенін тексереді . Бұл бұл модуль негізгі бағдарлама ретінде іске қосылып жатқанын немесе басқа жерде импортталғанын және модуль ретінде пайдаланылғанын ажыратуға мүмкіндік береді. Егер бұл модульді Python-да іске қоссақ, 51-54-жолдардағы сынақ жағдайлары орындалады. Дегенмен, егер біз бұл модульді басқа бағдарламаға импорттасақ (яғни біздің N queens шешушісі бұрынғыдан) 50-жолдағы шарт жалған болады және 51-54-жолдардағы мәлімдемелер орындалмайды.

Сегіз ханшайымның басқатырғышы бөлімінде , 2 бөлімде біздің негізгі бағдарламамыз келесідей болды:

```python
def main():

    bd = list(range(8))     # Generate the initial permutation
    num_found = 0
    tries = 0
    while num_found < 10:
       random.shuffle(bd)
       tries += 1
       if not has_clashes(bd):
           print("Found solution {0} in {1} tries.".format(bd, tries))
           tries = 0
           num_found += 1

main()
```

Енді бізге екі өзгеріс қажет. Бұл бағдарламаның жоғарғы жағында біз осы жерде жұмыс істеп жатқан модульді импорттаймыз (біз оны draw_queens деп атадық делік ). (Екі модуль бір қалтада сақталғанына көз жеткізуіңіз керек.) Содан кейін 10-жолдан кейін біз жаңа ғана тапқан шешімді салу үшін шақыруды қосамыз:

```python
draw_queens.draw_board(bd)
```

Бұл N Queens мәселесінің шешімдерін іздейтін бағдарламаның өте қанағаттандырарлық комбинациясын береді және ол әрқайсысын тапқан кезде шешімді көрсететін тақта шығады.

## 17.4. Спрайттар

Спрайт - ойында қозғала алатын және ішкі мінез-құлқы мен өзіндік күйі бар нысан. Мысалы, ғарыш кемесі спрайт, ойыншы спрайт, ал оқтар мен бомбалардың барлығы спрайт болады.

Объектіге бағытталған бағдарламалау (OOP) осындай жағдайға өте қолайлы: әрбір нысанның өз атрибуттары мен ішкі күйі және бірнеше әдістері болуы мүмкін. N Queens тақтамызбен көңілді болайық. Королеваны соңғы орнына қоюдың орнына, біз оны тақтаның жоғарғы жағынан түсіріп, оның орнына құлап кетуіне, мүмкін, жол бойына секіруге рұқсат еткіміз келеді.

Бізге қажет бірінші инкапсуляция - әрбір ханшайымымызды нысанға айналдыру. Біз барлық белсенді спрайттардың тізімін (яғни, патшайым нысандарының тізімі) сақтаймыз және ойын циклінде екі жаңа нәрсені реттейміз:

Оқиғаларды өңдегеннен кейін, бірақ сурет салу алдында әрбір спрайттағы жаңарту әдісін шақырыңыз. Бұл әрбір спрайтқа өзінің ішкі күйін қандай да бір жолмен өзгертуге мүмкіндік береді — мүмкін оның кескінін өзгертуі немесе орнын өзгертуі немесе өзін айналдыруы немесе өзін сәл үлкейту немесе сәл кішірейту мүмкіндігін береді.
Барлық спрайттар өздерін жаңартқаннан кейін, ойын циклі сурет салуды бастай алады - алдымен фон, содан кейін әр спрайтқа кезекпен тарту әдісін шақырады және сурет салу тапсырмасын нысанның өзіне тапсырады (қолданады). Бұл біз «Эй, сурет сал, мына патшайымды көрсет!» Демейміз, бірақ біз «Эй, патшайым, өзіңді сал!» Дегенді жөн көреміз деген OOP идеясына сәйкес келеді .
Біз қарапайым нысаннан бастаймыз, әзірге ешқандай қозғалыс немесе анимация жоқ, барлық бөліктерді қалай біріктіру керектігін көру үшін жай ғана тірек:

```python
class QueenSprite:

    def __init__(self, img, target_posn):
        """ Create and initialize a queen for this
            target position on the board
        """
        self.image = img
        self.target_posn = target_posn
        self.posn = target_posn

    def update(self):
        return                # Do nothing for the moment.

    def draw(self, target_surface):
        target_surface.blit(self.image, self.posn)
```

Біз спрайтқа үш атрибут бердік: сызылатын кескін, мақсатты орын және ағымдағы орын. Егер біз ренішті қозғалтқымыз келсе, қазіргі позиция нысанадан өзгеше болуы керек болуы мүмкін, бұл біз патшайымның соңында аяқталуын қалаймыз. Бұл кодта біз қазіргі уақытта жаңарту әдісінде ештеңе жасамадық және біздің тарту әдісіміз (ол болашақта қарапайым болып қалуы мүмкін) қоңырау шалушы ұсынған беттегі ағымдағы орнында өзін тартады.

Класс анықтамасы орнында, біз енді N патшайымдарымызды іске қосамыз, оларды спрайттар тізіміне енгіземіз және әр кадрға жаңарту және сызу әдістерін шақыру үшін ойын циклін ұйымдастырамыз. Жаңа код биттері және қайта қаралған ойын циклі келесідей:

```python
    all_sprites = []      # Keep a list of all sprites in the game

    # Create a sprite object for each queen, and populate our list.
    for (col, row) in enumerate(the_board):
        a_queen = QueenSprite(ball,
                   (col*sq_sz+ball_offset, row*sq_sz+ball_offset))
        all_sprites.append(a_queen)

    while True:
        # Look for an event from keyboard, mouse, etc.
        ev = pygame.event.poll()
        if ev.type == pygame.QUIT:
            break;

        # Ask every sprite to update itself.
        for sprite in all_sprites:
            sprite.update()

        # Draw a fresh background (a blank chess board)
        # ... same as before ...

        # Ask every sprite to draw itself.
        for sprite in all_sprites:
            sprite.draw(surface)

        pygame.display.flip()
```

Бұл бұрынғыдай жұмыс істейді, бірақ ханшайымдарға арналған заттарды жасаудағы біздің қосымша жұмысымыз біршама өршіл кеңейтімдерге жол дайындады.

Құлап жатқан ханшайым затынан бастайық. Кез келген сәтте оның белгілі бір бағытта жылдамдығы, яғни жылдамдығы болады. (Біз тек y бағытында қозғалыспен жұмыс істейміз, бірақ өз қиялыңызды пайдаланыңыз!) Сонымен объектіні жаңарту әдісінде оның ағымдағы орнын оның жылдамдығы бойынша өзгерткіміз келеді. Егер біздің N Queens тақтасы ғарышта қалқып жүрсе, жылдамдық тұрақты болып қалар еді, бірақ жер бетінде бізде тартылыс бар! Гравитация әр уақыт аралығында жылдамдықты өзгертеді, сондықтан біз одан әрі құлаған сайын жылдамдығын арттыратын допты қалаймыз. Гравитация барлық ханшайымдар үшін тұрақты болады, сондықтан біз оны инстанцияларда сақтамаймыз — біз оны модульде айнымалы етіп жасаймыз. Біз тағы бір өзгеріс жасаймыз: біз әрбір ханшайымды тақтаның жоғарғы жағынан бастаймыз, осылайша ол өз мақсатына қарай құлай алады. Осы өзгертулер арқылы біз келесіні аламыз:

```python
gravity = 0.0001

class QueenSprite:

    def __init__(self, img, target_posn):
        self.image = img
        self.target_posn = target_posn
        (x, y) = target_posn
        self.posn = (x, 0)     # Start ball at top of its column
        self.y_velocity = 0    #    with zero initial velocity

    def update(self):
        self.y_velocity += gravity       # Gravity changes velocity
        (x, y) = self.posn
        new_y_pos = y + self.y_velocity  # Velocity moves the ball
        self.posn = (x, new_y_pos)       #   to this new position.

    def draw(self, target_surface):      # Same as before.
        target_surface.blit(self.image, self.posn)
```

Бұл өзгерістерді енгізу бізге жаңа шахмат тақтасын береді, онда әрбір патшайым өз бағанының жоғарғы жағынан басталады және тақтаның төменгі жағынан түсіп, мәңгілікке жоғалып кеткенше жылдамдығын арттырады. Жақсы бастама - бізде қозғалыс бар!

Келесі қадам - ​​допты өзінің мақсатты орнына жеткенде секіру. Бір нәрсені секіру өте оңай — сіз оның жылдамдығының белгісін өзгертсеңіз болғаны, ол бірдей жылдамдықпен қарсы бағытта қозғалады. Әрине, егер ол тақтаның жоғарғы жағына көтерілсе, ол ауырлық күшімен баяулайды. (Гравитация әрқашан төмендейді!) Және сіз оның басталған жеріне дейін секіретінін, нөлдік жылдамдыққа жеткенін және қайтадан құлай бастағанын көресіз. Сондықтан бізде ешқашан реттелмейтін секіретін доптар болады.

Объектіні орналастырудың нақты жолы - ол секірген сайын біраз энергияны (мүмкін үйкеліске) жоғалту - сондықтан жылдамдықтың белгісін жай ғана өзгертудің орнына, біз оны қандай да бір бөлшек коэффициентке көбейтеміз - айталық -0,65. Бұл доп әрбір секіру кезінде өзінің энергиясының 65% ғана сақтайды дегенді білдіреді, сондықтан ол нақты өмірдегідей аз уақыттан кейін секіруді тоқтатады және «жерге» орналасады.

Жалғыз өзгертулер жаңарту әдісінде, ол енді келесідей көрінеді:

```python
def update(self):
    self.y_velocity += gravity
    (x, y) = self.posn
    new_y_pos = y + self.y_velocity
    (target_x, target_y) = self.target_posn   # Unpack the position
    dist_to_go = target_y - new_y_pos         # How far to our floor?

    if dist_to_go < 0:                        # Are we under floor?
        self.y_velocity = -0.65 * self.y_velocity     # Bounce
        new_y_pos = target_y + dist_to_go     # Move back above floor

    self.posn = (x, new_y_pos)                # Set our new position.
```

Хе, хе, хе! Біз анимациялық скриншоттарды көрсетпейміз, сондықтан кодты Python ортаңызға көшіріп, өзіңіз көріңіз.

## 17.5. Оқиғалар

Осы уақытқа дейін біз өңдеген жалғыз оқиға түрі QUIT оқиғасы болды. Бірақ біз сондай-ақ пернені төмен түсіру және пернелерді орнату оқиғаларын, тінтуірдің қозғалысын және тінтуірдің төмен немесе жоғары түймелерінің оқиғаларын анықтай аламыз. PyGame құжаттамасымен танысыңыз және Оқиға сілтемесін орындаңыз.

Бағдарлама PyGame-тен оқиға нысанын сұрағанда және оны қабылдағанда, оның оқиға түрі қандай қосымша ақпарат қолжетімді екенін анықтайды. Әрбір оқиға нысанында сөздік бар (оны тек осы жазбаларда уақытында қамтуға болады). Сөздікте оқиға түрі үшін мағынасы бар белгілі бір кілттер мен мәндер бар.

Мысалы, егер оқиға түрі MOUSEMOTION болса, біз оқиғаға тіркелген сөздікте тінтуірдің орнын және тінтуір түймелерінің күйі туралы ақпаратты таба аламыз. Сол сияқты, егер оқиға KEYDOWN болса, біз сөздіктен қай перненің төмендегенін және кез келген өзгертуші пернелердің (shift, control, alt, т. Сондай-ақ ойын терезесі белсенді болған кезде (яғни фокусталады) немесе фокусты жоғалтқанда оқиғаларды аласыз.

NOEVENT түрі бар оқиға нысаны күтілетін оқиғалар болмаса қайтарылады. Оқиғаларды басып шығаруға болады, бұл тәжірибе жасауға және ойнауға мүмкіндік береді. Сондықтан кез келген оқиға үшін сауалнама жүргізгеннен кейін осы код жолдарын ойын цикліне тікелей түсіру өте ақпараттылық болып табылады:

```python
if ev.type != pygame.NOEVENT:   # Only print if it is interesting!
    print(ev)
```

Бұл орынмен бос орын мен шығу пернесін басып, алынған оқиғаларды қараңыз. Тінтуірдің үш түймешігін басыңыз. Тінтуірді терезенің үстіне апарыңыз. (Бұл оқиғалардың үлкен каскадын тудырады, сондықтан оларды басып шығарудан сүзгілеу қажет болуы мүмкін.) Мынадай көрінетін нәтиже аласыз:

```python
<Event(17-VideoExpose {})>
<Event(1-ActiveEvent {'state': 1, 'gain': 0})>
<Event(2-KeyDown {'scancode': 57, 'key': 32, 'unicode': ' ', 'mod': 0})>
<Event(3-KeyUp {'scancode': 57, 'key': 32, 'mod': 0})>
<Event(2-KeyDown {'scancode': 1, 'key': 27, 'unicode': '\x1b', 'mod': 0})>
<Event(3-KeyUp {'scancode': 1, 'key': 27, 'mod': 0})>
...
<Event(4-MouseMotion {'buttons': (0, 0, 0), 'pos': (323, 194), 'rel': (-3, -1)})>
<Event(4-MouseMotion {'buttons': (0, 0, 0), 'pos': (322, 193), 'rel': (-1, -1)})>
<Event(4-MouseMotion {'buttons': (0, 0, 0), 'pos': (321, 192), 'rel': (-1, -1)})>
<Event(4-MouseMotion {'buttons': (0, 0, 0), 'pos': (319, 192), 'rel': (-2, 0)})>
<Event(5-MouseButtonDown {'button': 1, 'pos': (319, 192)})>
<Event(6-MouseButtonUp {'button': 1, 'pos': (319, 192)})>
<Event(4-MouseMotion {'buttons': (0, 0, 0), 'pos': (319, 191), 'rel': (0, -1)})>
<Event(5-MouseButtonDown {'button': 2, 'pos': (319, 191)})>
<Event(5-MouseButtonDown {'button': 5, 'pos': (319, 191)})>
<Event(6-MouseButtonUp {'button': 5, 'pos': (319, 191)})>
<Event(6-MouseButtonUp {'button': 2, 'pos': (319, 191)})>
<Event(5-MouseButtonDown {'button': 3, 'pos': (319, 191)})>
<Event(6-MouseButtonUp {'button': 3, 'pos': (319, 191)})>
 ...
<Event(1-ActiveEvent {'state': 1, 'gain': 0})>
<Event(12-Quit {})>
```

Енді ойын циклінің жоғарғы жағындағы кодқа осы өзгерістерді енгізейік:

```python
while True:

    # Look for an event from keyboard, mouse, etc.
    ev = pygame.event.poll()
    if ev.type == pygame.QUIT:
        break;
    if ev.type == pygame.KEYDOWN:
        key = ev.dict["key"]
        if key == 27:                  # On Escape key ...
            break                      #   leave the game loop.
        if key == ord("r"):
            colors[0] = (255, 0, 0)    # Change to red + black.
        elif key == ord("g"):
            colors[0] = (0, 255, 0)    # Change to green + black.
        elif key == ord("b"):
            colors[0] = (0, 0, 255)    # Change to blue + black.

    if ev.type == pygame.MOUSEBUTTONDOWN: # Mouse gone down?
        posn_of_click = ev.dict["pos"]    # Get the coordinates.
        print(posn_of_click)              # Just print them.
```

7-16 жолдар KEYDOWN оқиғасы үшін типтік өңдеуді көрсетеді — егер кілт төмендеп кетсе, біз оның қай перне екенін тексереміз және біраз әрекет жасаймыз. Бұл жерде бізде Queens бағдарламасынан шығудың тағы бір жолы бар - escape пернесін басу. Сондай-ақ, біз сызылған тақтаның түсін өзгерту үшін пернелерді пайдалана аламыз.

Соңында, 20-жолда біз тінтуірдің төмен түсуіне жауап береміз (әдемі).

Осы бөлімдегі соңғы жаттығу ретінде біз тінтуірді басу үшін жақсырақ жауап өңдеушісін жазамыз. Қолданушы біздің спрайттардың бірінде тінтуірді басқан-басқанын анықтаймыз. Егер шерткенде тінтуірдің астында спрайт болса, біз шертуді спрайтқа жібереміз және оған қандай да бір мағыналы түрде жауап беруге мүмкіндік береміз.

Біз басқан позицияның астында қай спрайт екенін анықтайтын кодпен бастаймыз, мүмкін ешқайсысы да жоқ! Біз классқа әдісті қосамыз, contain_point , ол нүкте спрайттың тіктөртбұрышында болса, True мәнін қайтарады:

```python
def contains_point(self, pt):
      """ Return True if my sprite rectangle contains point pt """
      (my_x, my_y) = self.posn
      my_width = self.image.get_width()
      my_height = self.image.get_height()
      (x, y) = pt
      return ( x >= my_x and x < my_x + my_width and
               y >= my_y and y < my_y + my_height)
```

Енді ойын циклінде тінтуір оқиғасын көргеннен кейін біз қандай патшайымға, егер бар болса, оқиғаға жауап беру керектігін анықтаймыз:

```python
if ev.type == pygame.MOUSEBUTTONDOWN:
    posn_of_click = ev.dict["pos"]
    for sprite in all_sprites:
        if sprite.contains_point(posn_of_click):
            sprite.handle_click()
            break
```

Және соңғы нәрсе - QueenSprite сыныбында handle_click деп аталатын жаңа әдісті жазу . Спрайт басылғанда, біз жоғары бағытта жылдамдықты қосамыз, яғни оны қайтадан ауаға жібереміз.

```python
def handle_click(self):
    self.y_velocity += -0.3   # Kick it up
```

Осы өзгерістер арқылы бізде ойнауға болатын ойын бар! Ешкімге отыруға мүмкіндік бермей, барлық шарларды қозғалыста ұстай алатыныңызды қараңыз!

## 17.6. Анимация толқыны

Көптеген ойындарда анимациялық спрайт бар: олар еңкейіп, секіреді және атады. Олар мұны қалай жасайды?

10 кескіннің осы тізбегін қарастырайық: егер біз оларды кезекпен көрсетсек, Дюк бізге қол бұлғайды. (Герцог - Яваланд патшалығынан келген мейірімді қонақ.)

![PyGame_6](https://user-images.githubusercontent.com/84173441/176387047-c41a9961-e263-4e56-a60c-8b1aa26890de.JPG)

Анимацияға арналған кішірек патчтары бар күрделі кескін спрайт парағы деп аталады . Бұл спрайт парағын браузерде тінтуірдің оң жақ түймешігімен басып, оны duke_spritesheet.png атауымен жұмыс каталогында сақтау арқылы жүктеп алыңыз .

Спрайт парағы өте мұқият дайындалған: 10 патчтың әрқайсысы бір-бірінен дәл 50 пиксель қашықтықта орналасқан. Сонымен, №4 патчты (0-ден бастап нөмірлеу) салғымыз келеді деп есептесек, спрайт парағында x 200 позициясынан басталатын және ені 50 пиксель болатын тіктөртбұрышты ғана салғымыз келеді. Мұнда біз патчтарды көрсеттік және сызғымыз келетін патчты бөлектедік.

![PyGame_7](https://user-images.githubusercontent.com/84173441/176387210-7f2f2818-47c1-4012-af0a-b94984b26c42.JPG)

Біз қолданып жүрген блит әдісі — пикселдерді бір беттен екіншісіне көшіру үшін — бастапқы беттің ішкі төртбұрышын көшіре алады. Сонымен, бұл жердегі басты идея - біз Дюкті салған сайын, біз бүкіл спрайт парағын жарып жібермейміз. Оның орнына біз спрайт парағының қай бөлігі өшірілетінін анықтайтын қосымша тіктөртбұрыш аргументін береміз.

Біз осы бөлімде N Queens сурет салу ойынына жаңа код қосамыз. Біздің қалағанымыз - шахмат тақтасында герцогтың кейбір мысалдарын бір жерге қою. Егер пайдаланушы олардың біреуін басса, біз оның анимациясының бір циклі үшін кері сілтеу арқылы жауап беруін талап етеміз.

Бірақ мұны жасамас бұрын бізге тағы бір өзгеріс қажет. Осы уақытқа дейін біздің ойын циклі күтпеген жерден өте жылдам кадр жиіліктерінде жұмыс істеп келеді. Сондықтан біз сынау және қателесу негізінде ауырлық күші мен допты секіру және тебу үшін сиқырлы сандарды таңдадық. Егер біз көбірек спрайттарды анимациялауды бастайтын болсақ, бекітілген, белгілі кадр жиілігінде жұмыс істеу үшін ойын циклін реттеуіміз керек. Бұл бізге анимацияны жақсырақ жоспарлауға мүмкіндік береді.

PyGame бізге мұны тек екі код жолында орындауға арналған құралдарды береді. Ойынның орнату бөлімінде біз жаңа Clock нысанын жасаймыз:

```python
my_clock = pygame.time.Clock()
```

және ойын циклінің дәл төменгі жағында біз осы нысандағы кадр жиілігін біз көрсеткен кез келген нәрсеге шектейтін әдісті шақырамыз. Сонымен, ойын циклінің төменгі жағындағы жолды қосу арқылы ойын мен анимацияны секундына 60 кадрға жоспарлайық:

```python
my_clock.tick(60)  # Waste time so that frame rate becomes 60 fps
```

Осы әлдеқайда баяу кадр жиілігіне сәйкес келу үшін кері қайтып, гравитация мен допты соғу үшін сандарды реттеу керек екенін көресіз. Біз анимацияны тек бекітілген кадр жиілігінде ақылға қонымды жұмыс істейтін етіп жоспарлағанда, біз анимацияны дайындадық деп айтамыз . Бұл жағдайда біз анимацияларымызды секундына 60 кадрға дайындаймыз.

QueenSprite класы үшін бұрыннан бар құрылымға сәйкес келу үшін біз QueenSprite сыныбымен бірдей әдістерге ие DukeSprite сыныбын жасағымыз келеді. Содан кейін біз all_sprites тізіміне бір немесе бірнеше Duke данасын қоса аламыз және біздің бар ойын циклі содан кейін Duke экземплярының әдістерін шақырады. Жаңа сынып үшін қаңқалық тіректерден бастайық:

```python
class DukeSprite:

    def __init__(self, img, target_posn):
        self.image = img
        self.posn = target_posn

    def update(self):
        return

    def draw(self, target_surface):
        return

    def handle_click(self):
        return

    def contains_point(self, pt):
        # Use code from QueenSprite here
        return
```

Бар ойынға қажет болатын жалғыз өзгерістердің барлығы орнату бөлімінде. Біз жаңа спрайт парағын жүктейміз және шахмат тақтасында қалаған орындарда Дюктің бірнеше данасын жасаймыз. Сондықтан ойын цикліне кірмес бұрын біз мына кодты қосамыз:

```python
# Load the sprite sheet
duke_sprite_sheet = pygame.image.load("duke_spritesheet.png")

# Instantiate two duke instances, put them on the chessboard
duke1 = DukeSprite(duke_sprite_sheet,(sq_sz*2, 0))
duke2 = DukeSprite(duke_sprite_sheet,(sq_sz*5, sq_sz))

# Add them to the list of sprites which our game loop manages
all_sprites.append(duke1)
all_sprites.append(duke2)
```

Енді ойын циклі әрбір дананың басылғанын тексереді, сол данаға шерту өңдеушісін шақырады. Ол сондай-ақ жаңартуды шақырады және барлық спрайттарды тартады. Біз жасауымыз керек қалған барлық өзгертулер DukeSprite класының әдістерінде жасалады.

Патчтардың бірін салудан бастайық. Біз сыныпқа curr_patch_num жаңа төлсипатын енгіземіз . Ол 0 мен 9 арасындағы мәнді сақтайды және қай патчты салу керектігін анықтайды. Осылайша, сызу әдісінің жұмысы сызылатын патчтың ішкі тіктөртбұрышын есептеу және спрайт парақтың сол бөлігін ғана кесу болып табылады:

```python
def draw(self, target_surface):
    patch_rect = (self.curr_patch_num * 50, 0,
                    50, self.image.get_height())
    target_surface.blit(self.image, self.posn, patch_rect)
```

Енді анимацияны іске қосу. Жаңарту кезінде логиканы реттеу керек, осылайша біз анимациялаумен айналысып жатсақ, curr_patch_num нөмірін жиі өзгертеміз, сонымен қатар Дьюкті қашан демалыс орнына қайтару және анимацияны тоқтату керектігін шешеміз. Маңызды мәселе мынада, ойын циклінің кадр жиілігі — біздің жағдайда 60 кадр/с — анимация жылдамдығымен бірдей емес — Дьюктің анимациялық патчтарын өзгерткіміз келетін жылдамдық. Сонымен, біз Дьюк толқынының анимация циклін 1 секундқа жоспарлаймыз. Басқаша айтқанда, біз Дьюктің 10 анимациялық патчтарын жаңарту үшін 60 қоңыраудан астам ойнатқымыз келеді .. (Анимацияны пісіру осылай жүзеге асады!) Сондықтан біз сыныпта басқа анимация кадрының есептегішін сақтаймыз, ол анимацияланбаған кезде нөлге тең болады және жаңартуға әрбір шақыру есептегішті 59-ға дейін арттырады, содан кейін 0-ге қайта оралыңыз. Көрсеткіміз келетін патчты таңдау үшін curr_patch_num айнымалы мәнін орнату үшін сол анимация санауышын 6-ға бөлуге болады.

```python
def update(self):
    if self.anim_frame_count > 0:
       self.anim_frame_count = (self.anim_frame_count + 1 ) % 60
       self.curr_patch_num = self.anim_frame_count // 6
```

Назар аударыңыз, егер anim_frame_count нөлге тең болса, яғни Дьюк тыныштықта болса, мұнда ештеңе болмайды. Бірақ есептегішті іске қоса бастасақ, ол нөлге дейін 59-ға дейін есептеледі. Сондай-ақ, anim_frame_count тек 0 мен 59 арасындағы мән болуы мүмкін болғандықтан, curr_patch_num әрқашан 0 мен 9 арасында қалатынына назар аударыңыз. Бізге қажет нәрсе!

Енді анимацияны қалай іске қосамыз және оны іске қосамыз? Тінтуірде басыңыз.

```python
def handle_click(self):
     if self.anim_frame_count == 0:
        self.anim_frame_count = 5
```

Мұнда екі нәрсе қызықтырады. Біз анимацияны Дюк демалыста болған жағдайда ғана бастаймыз. Ол қол бұлғап тұрған кезде Дюкті шерту еленбейді. Ал анимацияны іске қосқан кезде біз санауышты 5-ке қоямыз — бұл келесі қоңырауда санауыш жаңартуға 6-ға айналады және кескін өзгереді. Есептегішті 1-ге қойған болсақ, бірдеңе болмай тұрып жаңарту үшін тағы 5 қоңырау күтуіміз керек еді — сәл кідіріс, бірақ жағдайды баяу сезіну үшін жеткілікті.

Соңғы түзету - сыныпты құру кезінде екі жаңа атрибутымызды инициализациялау. Міне, қазір бүкіл сыныпқа арналған код:

```python
class DukeSprite:

    def __init__(self, img, target_posn):
        self.image = img
        self.posn = target_posn
        self.anim_frame_count = 0
        self.curr_patch_num = 0

    def update(self):
        if self.anim_frame_count > 0:
           self.anim_frame_count = (self.anim_frame_count + 1 ) % 60
           self.curr_patch_num = self.anim_frame_count // 6

    def draw(self, target_surface):
        patch_rect = (self.curr_patch_num * 50, 0,
                       50, self.image.get_height())
        target_surface.blit(self.image, self.posn, patch_rect)

    def contains_point(self, pt):
         """ Return True if my sprite rectangle contains  pt """
         (my_x, my_y) = self.posn
         my_width = self.image.get_width()
         my_height = self.image.get_height()
         (x, y) = pt
         return ( x >= my_x and x < my_x + my_width and
                  y >= my_y and y < my_y + my_height)

    def handle_click(self):
         if self.anim_frame_count == 0:
            self.anim_frame_count = 5
```

Қазір біздің шахмат тақтасында екі қосымша Duke данасы бар және кез келгенін басу сол дананы толқынды етеді.

![PyGame_8](https://user-images.githubusercontent.com/84173441/176387652-eecfc239-aa3d-4af2-bd66-a72112555a6b.JPG)

## 17.7. Шетелдіктер - жағдайды зерттеу

PyGame бумасы бар мысал ойындарды табыңыз, (Windows жүйесінде C:\Python3\Lib\site-packages\pygame\examples сияқты) және шетелдіктер ойынын ойнаңыз. Содан кейін жол нөмірлерін көрсететін редакторда немесе Python ортасында кодты оқыңыз.

Ол біз жасайтын бірнеше жетілдірілген нәрселерді жасайды және оның логикасы үшін PyGame құрылымына сүйенеді. Міне, назар аударатын кейбір тармақтар:

Кадр жиілігі ойын циклінің төменгі жағында 311-жолда әдейі шектелген. Егер бұл санды өзгертсек, ойынды өте баяу немесе ойнауға болмайтын жылдам ете аламыз!
Спрайттардың әртүрлі түрлері бар: жарылыстар, атулар, бомбалар, шетелдіктер және ойыншы. Олардың кейбіреулерінде бірнеше кескін бар — кескіндерді ауыстыру арқылы біз спрайттардың анимациясын аламыз, яғни Alien ғарыш кемесінің шамдары өзгереді және бұл 112-жолда орындалады.
Спрайттардың әртүрлі топтарында нысандардың әртүрлі түрлеріне сілтеме жасалады және PyGame оларды сақтауға көмектеседі. Бұл бағдарламаға, айталық, ойыншы түсірген оқтар тізімі мен шабуыл жасап жатқан ғарыш кемелерінің тізімі арасындағы қақтығыстарды тексеруге мүмкіндік береді. PyGame біз үшін көп жұмыс істейді.
Біздің ойыннан айырмашылығы, шетелдіктер ойынындағы нысандардың өмір сүру мерзімі шектеулі және өлтірілуі керек. Мысалы, егер біз түсірсек, Shot нысаны жасалады — егер ол ешнәрсеге қарсы шықпай экранның жоғарғы жағына жетсе, оны ойыннан алып тастау керек. 141-142 жолдар мұны жасайды. Сол сияқты, құлап жатқан бомба жерге жақындағанда (156-жол), ол жаңа Explosion спрайтын іске қосады және бомба өзін өлтіреді.
Көңілді қосатын кездейсоқ уақыт бар - келесі бөтен планетаны қашан шығару керек, шетелдік келесі бомбаны түсіргенде және т.б.
Ойын дыбыстарды да ойнайды: тыныштандырмайтын цикл дыбысы, сонымен қатар кадрлар мен жарылыстарға арналған дыбыстар.
17.8. Рефлексия 
Объектіге бағытталған бағдарламалау бағдарламалық қамтамасыз етуді ұйымдастырудың жақсы құралы болып табылады. Осы тараудағы мысалдарда біз бұл артықшылықтарды пайдалана бастадық (және оны бағалаймыз деп үміттенеміз). Мұнда бізде N патшайымдардың әрқайсысының өз күйі болды, олар өз қабат деңгейіне құлады, секіреді, тепті және т.б.. Біз нысандардың ұйымдастырушылық күшінсіз басқарар едік — мүмкін, біз әрбір ханшайым үшін жылдамдықтардың тізімдерін және тізімдерді сақтай алар едік. мақсатты позициялар және т.б. - біздің кодымыз әлдеқайда күрделі, ұсқынсыз және әлдеқайда нашар болар еді!

## 17.9. Глоссарий

анимация жылдамдығы
Қозғалыс иллюзиясын жасау үшін дәйекті патчтарды ойнату жылдамдығы. Осы тарауда қарастырған үлгіде біз бір секунд ішінде Дюктің 10 патчын ойнадық. Кадр жиілігімен бірдей емес.
пісірілген анимация
Алдын ала белгіленген бекітілген кадр жиілігінде жақсы көрінуге арналған анимация. Бұл ойын іске қосылған кезде жасалуы қажет есептеу көлемін азайтады. Жоғары деңгейлі коммерциялық ойындар әдетте анимацияларды дайындайды.
блит
Компьютерлік графикада қолданылатын етістік, бір кескіннің немесе беттің ішкі тіктөртбұрышынан басқа бетке немесе кескінге кескіннің немесе пиксельдің жылдам көшірмесін жасауды білдіреді.
кадр жиілігі
Ойын циклінің орындалу және дисплейді жаңарту жылдамдығы.
ойын циклі
Ойынның логикасын басқаратын цикл. Ол әдетте оқиғалар үшін сауалнама жүргізеді, содан кейін ойындағы әрбір нысанды жаңартады, содан кейін барлығын сызып алады, содан кейін жаңадан салынған кадрды дисплейге қояды.
пиксель
Суреттер жасалатын жалғыз сурет элементі немесе нүкте.
сауалнама
Пернені басу немесе тінтуірдің қозғалысы сияқты бірдеңе болғанын сұрау. Ойын циклдері әдетте қандай оқиғалар болғанын анықтау үшін сауалнама жүргізеді. Бұл «Оқиғалар» тарауында көрсетілгендей оқиғаларға негізделген бағдарламалардан ерекшеленеді. Мұндай жағдайларда түймені басу немесе пернені басу оқиғасы бағдарламаңыздағы өңдеуші функциясының шақыруын іске қосады, бірақ бұл сіздің артыңызда орын алады.
спрайт
Өз күйі, ұстанымы және мінез-құлқы бар ойынның белсенді агенті немесе элементі.
беті
Бұл тасбақа модулі кенеп деп атайтын PyGame термині . Бет – кескіндер мен кескіндерді көрсету үшін қолданылатын пиксельдердің тіктөртбұрышы.

## 17.10. Жаттығулар

Python және PyGame көмегімен көңілді болыңыз.
Біз Дюкті анимациялауға арналған кодта әдейі қате қалдырдық. Егер сіз Дюктің оң жағындағы шахмат тақтасының квадраттарының бірін бассаңыз, ол бәрібір қол бұлғайды. Неліктен? Қате үшін бір жолды түзетуді табыңыз.
«Спрайт парақ ойын карталары» үшін олардың кескіндер кітапханасын іздеу үшін қалаған іздеу жүйесін пайдаланыңыз. Палубадағы 52 картаның кодтауын көрсету үшін [0..51] тізімін жасаңыз. Карталарды араластырыңыз, покер мәмілесінде қолыңыздың бестігін кесіңіз. Сізге берілген қолды көрсетіңіз.
Сонымен, шетелдіктер ойыны ғарышта, гравитациясыз. Атыстар мәңгілікке ұшып кетеді, ал бомбалар құлаған кезде жылдамдамайды. Ойынға біраз ауырлық қосыңыз. Өзіңіздің атысыңыз сіздің басыңызға түсіп, сізді өлтіруге рұқсат беруді шешіңіз.
Бұл тітіркендіргіш шетелдіктер бір-бірінің арасынан өтетін сияқты! Ойынды олар соқтығысатындай етіп өзгертіп, бір-бірін күшті жарылыспен жойыңыз.
