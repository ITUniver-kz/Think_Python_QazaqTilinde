---
title: Дерек типтері. Тіркестер
isFree: true
---

---

# Дерек типтері

---

# 8.1 Тіркестер

## 8.1.1 Құрама деректер түрі

Осы уақытқа дейін біз ```int, float, bool, str``` сияқты кірістірілген типтерді көрдік және тізімдер (```lists```) мен жұптарға (```pairs```) шолу жасадық. Тіркестер, тізімдер және жұптар басқалардан сапалық жағынан ерекшеленеді, өйткені олар кішірек бөліктерден тұрады. Тіркестер жағдайында олар әрқайсысы бір **таңбадан** тұратын кішірек тіркестен тұрады. (**таңба / character**)

Кішірек бөліктерден тұратын типтер _құрама деректер типтері_ деп аталады. Не істеп жатқанымызға байланысты біз құрама деректер түрін бүтін зат ретінде қарастырғымыз келуі мүмкін немесе оның бөліктеріне қол жеткізгіміз келуі мүмкін. Бұл бізге қолданысқа пайдалы.

## 8.1.2 Тіркестерді бүтін, бір нәрсе сияқты қарастыру

Әрбір тасбақа данасының өз атрибуттары және данаға қолдануға болатын бірқатар әдістері бар екенін бұрын көрдік. Мысалы, біз тасбақаның түсін белгілей аламыз және біз ```tess.turn(90)``` деп жаздық.

Тасбақа сияқты, тіркестер де объект болып табылады. Сондықтан әрбір тіркес данасы өз атрибуттары мен әдістеріне ие.

Мысалға:

```python
>>> our_string = "Hello, World!"
>>> all_caps = our_string.upper()
>>> all_caps
'HELLO, WORLD!'
```

```upper``` - барлық таңбалар бас әріппен жазылған жаңа тіркесті жасау үшін кез келген тіркес объектісіне шақырылатын әдіс. (Бастапқы ```our_string``` тіркесі өзгеріссіз қалады.)

Сондай-ақ , басқа да қызықты нәрселерді жасайтын ```lower```, ```capitalize```, және ```swapcase``` сияқты әдістер бар.

Қандай әдістер қолжетімді екенін білу үшін Help құжаттамасын қараңыз, тіркес әдістерін іздеңіз және құжаттаманы оқи аласыз. Немесе басқа жерден қарауға болатын құрал, PyScripter немесе PyCharm editor-да келесіні теріңіз:

```python
our_string = "Hello, World!"
new_string = our_string.
```

```our_string``` әдістерінің бірін таңдау үшін нүктені терген кезде, PyCharm тіркестерде қолдануға болатын барлық әдістерді көрсететін таңдау терезесін ашады (әдістердің шамамен 70-і ашылады — уайымдамаңыз, біз олардың бірнешеуін ғана қолданамыз!).

![string_methods](https://user-images.githubusercontent.com/84173441/174943780-9dc8f7d6-8642-4203-b432-993425ac09d1.JPG)

Әдістің атын терген кезде оның параметрі мен қайтару түрі және құжат жолы (docstring) туралы қосымша анықтама көрсетіледі. Төменде осындай ақпараттарды оқып, сізге көрсетіп тұрған PyCharm бағдарламасының скриншоты берілген.

![swapcase_method](https://user-images.githubusercontent.com/84173441/174944122-7aa55b5a-803d-4fc6-8989-21d58f0e5f5c.JPG)


## 8.3. Тіркес бөліктерімен жұмыс

Индекстеу операторы (Python индексті қоршау үшін төртбұрышты жақшаларды ```[]``` пайдаланады) тіркестен бір таңбалық ішкі тіркесті таңдайды:

```python
>>> fruit = "banana"
>>> letter = fruit[1]
>>> print(letter)
```

```fruit[1]``` өрнегі ```fruit``` ішінен 1 индексінде орналасқан таңбаны таңдайды және тек осы бір таңбадан тұратын жаңа тіркесті жасайды. ```letter``` айнымалысы нәтижеге сілтеме жасайды. ```letter```-ді басып шығарғанда біз тосын нәтиже алуымыз мүмкін:

```python
a
```

Компьютер ғалымдары әрқашан санауды нөлден бастайды! «banana»-ның нөлдік позициясындағы әріп ```b```. Сонымен \[1] позициясында бізде ```a``` әрпі бар.

Егер тіркестің нөлдік әрпіне қол жеткізгіміз келсе, біз жай ғана 0 немесе 0-ге бағаланатын кез келген өрнекті жақшалардың арасына қоямыз:

```python
>>> letter = fruit[0]
>>> print(letter)
b
```

Жақшадағы өрнек индекс (**index**) деп аталады. Индекс реттелген жиынның мүшесін көрсетеді, бұл жағдайда тіркестегі таңбалар жиыны. Индекс құрама дерек типінің қайсы элементін алғыңыз келетінін көрсетеді. Индекс сөзі indicate ағылшын сөзінен шыққан _делінген_. Индекс кез келген бүтін өрнек болуы мүмкін.

Біз индекстерді визуализациялау үшін ```enumerate``` пайдалана аламыз:

```python
>>> fruit = "banana"
>>> list(enumerate(fruit))
[(0, 'b'), (1, 'a'), (2, 'n'), (3, 'a'), (4, 'n'), (5, 'a')]
```

Әзірше ```enumerate``` (санамалау) туралы алаңдамаңыз, біз бұл туралы көбірек Тізімдер (Lists) тарауында көреміз.
Бірақ ```enumerate``` тіркестерге қолданғанда, әр тіркес индексі және таңба жұбынан тұратын тізім жасайтынын көруге болады.

Индекстеу тіркес (_```str```_) қайтаратынын ескеріңіз — Python-да бір таңба үшін арнайы дерек түрі жоқ. Тіркестен кесіп алынған не индекстелген тіркес ұзындығы тек 1 болатын string.

Біз тізімдерді (lists) бұрын да көрдік. Осы қарастырған индекстеу белгісі тізімнен элементтерді шығару үшін жұмыс істейді:

```python
>>> prime_nums = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]
>>> prime_nums[4]
11
>>> friends = ["Joe", "Zoe", "Brad", "Angelina", "Zuki", "Thandi", "Paris"]
>>> friends[3]
'Angelina'
```

## 8.4. Length / Ұзындығы

```len``` функциясы тіркеске қолданылғанда, тіркестегі таңбалар санын қайтарады:

```python
>>> word = "banana"
>>> len(word)
6
```

Тіркестің соңғы әрпін алу үшін сіз келесідей код жазамын ау деп ойлап қалуыңыз мүмкін:

```python
size = len(word)
last = word[size]       # ERROR!
```

Бұл жұмыс істемейді. Бұл ```IndexError``` орындалу қатесін тудырады: ```IndexError: жол индексі ауқымнан тыс```. Себебі, «banana» индексінің 6-шы позициясында таңба жоқ. Біз нөлден санауды бастайтындықтан, алты индекс 0-ден 5-ке дейін нөмірленеді. Соңғы таңбаны алу үшін ```word``` ұзындығынан 1-ді алып тастау керек:

```python
word = "banana"
size = len(word)
print(size)
>>> 6

last_char = word[size - 1]
print(last_char)
>>> a
```

Немесе тіркестің соңынан кері қарай есептелетін **теріс индекстерді** (negative indices) пайдалана аламыз. ```word[-1]``` өрнегі соңғы әріпті, ```word[-2]``` соңынан санағанда екіншісін береді және т.б.

Сіз болжағандай, теріс индексі бар индекстеу тізімдер үшін де осылай жұмыс істейді.

Біз осы кітаптың қалған бөлігінде теріс индекстерді жиі пайдаланбаймыз — бұл идиоманы көптеген компьютер тілдері пайдаланбайды, сондықтан сіз одан аулақ болғаныңыз жөн болар. Бірақ Интернетте бұл трюкті қолданатын көптеген Python коды бар, сондықтан оның бар екенін білген дұрыс.

## 8.5 Traversal және for циклі

Тіркесте жасалатын есептеулердің көбі бір уақытта бір таңбаны өңдеуді қамтиды. Көбінесе олар басынан басталады, әр қадамда әрбір таңбаны кезекпен таңдап, оған бірдеңе жасайды және соңына дейін жалғасады. Бұл өңдеу үлгісі **траверсал** деп аталады. 

Айналуды (traversal-ды) кодтаудың бір жолы (және нашар жолы) - ```while``` операторы:

```python
ix = 0
while ix < len(fruit):
    letter = fruit[ix]
    print(letter)
    ix += 1
```

Бұл цикл тіркесті айналып өтіп, тіркестегі әрбір әріпті өз жаңа жолында көрсетеді. Цикл шарты ```ix < len(fruit)```, сондықтан ```ix``` жолдың ұзындығына тең болғанда шарт жалған болады және цикл денесі орындалмайды. Соңғы қол жеткізілген таңба ```len(fruit)-1``` индексі бар, ол теркестегі соңғы таңба болып табылады.
Дегенмен бұл код ұзақтау және жазылуы да барынша анық емес. ```ix``` айнымалысы ```index``` дегенді білдіреді, бірақ оның да көмегі аз.

Бірақ біз бұрын ```for``` циклінің тізімдегі элементтерді қалай оңай итерация жасай алатынын көрдік және ол тіркестер үшін де соны жасай алады:

```python
word = "Banana"
for letter in word:
    print(letter)
```

Әрбір цикл арқылы тіркестегі келесі таңба ```letter``` айнымалысына тағайындалады. Цикл таңбалар біткенше жалғасады. Мұнда тіркестерді айналып өту кезінде ```while``` циклімен салыстырғанда ```for``` циклі беретін жазу артықшылығын айқын көреміз.

Келесі мысал абецедарлық қатарды жасау үшін конкатенация және ```for``` циклін пайдалану жолын көрсетеді. Абецедарлық дегеніміз элементтері алфавиттік тәртіпте пайда болатын қатарға немесе тізімге сілтеме жасайды. Мысалы, Роберт МакКлоскидің "[Make Way for Ducklings](https://en.wikipedia.org/wiki/Make_Way_for_Ducklings)" кітабында үйректердің аттары Jack, Kack, Lack, Mack, Nack, Ouack, Pack, және Quack болып табылады. Бұл цикл осы атауларды ретімен шығарады:

```python
prefixes = "JKLMNOPQ"
suffix = "ack"

for p in prefixes:
    print(p + suffix)
```

Бұл бағдарламаның нәтижесі:

```python
Jack
Kack
Lack
Mack
Nack
Oack
Pack
Qack
```

Әрине, бұл жерде қателік жіберілген, өйткені Ouack және Quack қате жазылған. Сіз мұны төменде жаттығу ретінде түзетесіз.

## 8.6 Slices / тілімдер 

Тіркестің ішкі тіркесі кесінді (**slice**) арқылы алынады. Сол сияқты, тізімдегі элементтердің кейбір ішкі тізіміне сілтеме жасайтын кіші-тізімді кесуге болады:

```python
>>> phrase = "Pirates of the Caribbean"
>>> print(phrase[0:7])
Pirates
>>> print(phrase[11:14])
the
>>> print(phrase[15:24])
Caribbean
>>> friends = ["Joe", "Zoe", "Brad", "Angelina", "Zuki", "Thandi", "Paris"]
>>> print(friends[2:4])
['Brad', 'Angelina']
```

```[n:m]``` операторы жолдың n-ші таңбадан m-ші таңбаға дейінгі бөлігін қайтарады, бірінші таңба қосылады, бірақ соңғысы қосылмайды. Төмендегі диаграммада келтірілгендей, таңбалар арасында нұсқалған индекстерді елестетсеңіз, бұл әрекеттің мағынасы бар:

![between](https://user-images.githubusercontent.com/84173441/174978811-ea51ca93-eee1-4f68-9b19-48673175784c.JPG)

Егер сіз мұны қағаз парағы ретінде елестетсеңіз, кесу операторы [n:m] ```n``` және ```m``` позициялары арасындағы қағаз бөлігін көшіреді. Егер ```m``` және ```n``` екеуі де тіркестің ішінде болатынын ескерсек, сіздің алған нәтиже ұзындығы (m - n) болады.

Бұл жерде тағы үш трюк бар: бірінші индексті (қос нүктенің алдындағы ```[n: ```) жазбай өткізіп жіберсеңіз, кесінді тіркестің (немесе тізімнің) басынан басталады. Екінші индексті (``` :n]```) өткізіп жіберсеңіз, кесінді тіркестің (немесе тізімнің) соңына дейін созылады. Сол сияқты, тіркестің (немесе тізімнің) ұзындығынан үлкенірек n мәнін берсеңіз, кесінді соңына дейін барлық мәндерді қабылдайды. (Ол қалыпты индекстеу операциясы сияқты «ауқымнан тыс» қатесін бермейді.) Осылайша:

```python
>>> fruit = "banana"
>>> fruit[:3]
'ban'
>>> fruit[3:]
'ana'
>>> fruit[3:999]
'ana'
```

```phrase[:]``` нені білдіреді деп ойлайсыз? Ал ```friends[4:]``` ше? Және ```phrase[-5:-3]```?

## 8.7. Тіркестерді салыстыру

Салыстыру операторлары тіркестерде де жұмыс істейді. Екі тіркестің тең екенін көру үшін:

```python
fruit = "banana"

if fruit == "banana":
    print("Yes, we have banana")
elif fruit == "apple":
    print("Yes, we have an apple")
elif fruit == "apricot":
    print("Yes, we have an apricot")
```

Басқа салыстыру операциялары сөздерді [лексикографиялық](https://en-m-wikipedia-org.translate.goog/wiki/Lexicographic_order?_x_tr_sl=en&_x_tr_tl=kk&_x_tr_hl=en&_x_tr_pto=wapp) тәртіпте орналастыру үшін пайдалы:

```python
fruit = "apple"

if fruit < "banana":
    print("Your fruit, " + fruit + ", comes before banana.")
elif fruit > "banana":
    print("Your fruit, " + fruit + ", comes after banana.")
else:
    print("Yes, we have bananas!")
```

```python
>>> Your fruit, apple, comes before banana.
```

Бұл сөздікте қолданылатын алфавиттік тәртіпке ұқсас, тек барлық бас әріптер барлық кіші әріптерден бұрын келеді. Сондықтан:

```python
fruit = "Zebra"

if fruit < "banana":
    print("Your fruit, " + fruit + ", comes before banana.")
elif fruit > "banana":
    print("Your fruit, " + fruit + ", comes after banana.")
else:
    print("Yes, we have bananas!")
```

```python
>>> Your word, Zebra, comes before banana. # Сіздің сөзіңіз, Зебра, бананнан бұрын келеді.
```

Бұл мәселені шешудің жалпы жолы - салыстыруды орындамас бұрын тіркестерді барлық кіші әріптер сияқты стандартты пішімге түрлендіру. _Неғұрлым қиын мәселе - бағдарламаға зебралар жеміс емес екенін түсіну._ )

## 8.8. Тіркестер өзгермейді

Тіркестегі таңбаны өзгерту мақсатымен тағайындаудың сол жағында ```[ ]``` тік жақша операторын пайдалану ойға келуі мүмкін. Мысалға:

```python
greeting = "Hello, world!"
greeting[0] = 'J'            # ERROR!
print(greeting)
```

```Jello, world!``` нәтижесін шығарудың орнына, бұл код ```TypeError``` орындалу қатесін тудырады: ```TypeError: 'str' object does not support item assignment.```

Тіркестер өзгермейді (**immutable**), яғни бар тіркесті өзгерту мүмкін емес. Сіз жасай алатын ең жақсы нәрсе - түпнұсқаның өзгертілген көшірмесі болып табылатын жаңа тіркесті жасау:

```python
greeting = "Hello, world!"
new_greeting = "J" + greeting[1:]
print(new_greeting)
```

```python
Jello, world!
```

Мұндағы шешім ```greeting```-тің бір бөлігіне жаңа бірінші әріпті біріктіру (concatenate) болып табылады. Бұл әрекет түпнұсқа тіркеске әсер етпейді.

## 8.9. Операторлар: in және not in

```in``` операторы мүшелікке тексеру жасайды. ```in``` аргументтерінің екеуі де тіркестер болған кезде, ```in``` сол жақтағы аргумент оң жақтағы аргументтің ішкі тіркесі ме жоқ па соны тексереді.

```python
>>> "p" in "apple"
True
>>> "i" in "apple"
False
>>> "ap" in "apple"
True
>>> "pa" in "apple"
False
```

Тіркес өзінің ішкі тіркесі, ал бос тіркес кез келген басқа тіркестің ішкі тіркесі екенін ескеріңіз. (Сонымен қатар компьютер ғалымдары осы ерекше жағдайларды мұқият ойластырғанды ұнататынын ескеріңіз!)

```python
>>> "a" in "a"
True
>>> "apple" in "apple"
True
>>> "" in "a"
True
>>> "" in "apple"
True
```

```not in``` операторы ```in```-ге логикалық қарама-қарсы нәтижелерді қайтарады:

```python
>>> "x" not in "apple"
True
```

\+ арқылы тіркесті конкатенация жасау мен ```in``` операторын қосып, тіркестен барлық дауысты дыбыстарды алып тастайтын функция жаза аламыз:

```python
def remove_vowels(phrase):
    vowels = "aeuio"
    new_phrase = ""
    for letter in phrase:
        if letter.lower() not in vowels:
            new_phrase = new_phrase + letter
    return new_phrase

print(remove_vowels("Something wonderful about chess game. But, please, don't play it much"))
```

Айта кету керек бір нәрсе, 5-ші жолдағы ```letter.lower()``` функциясы, онсыз бас әріпте жазылған дауысты дыбыстар жойылмайды.

## 8.10. find функциясы

Келесі функция не істейді?

```python
def my_find(phrase, x):
    """
      phrase ішінен x индексін тауып қайтар.
      phrase ішінде x шықпаса -1 қайтарыңыз
    """
    for index, letter in enumerate(phrase):
        if letter == x:
            return index
    return -1
```

Жоғарыдағы кодтың шығысын Python-ның кірістірілген ```find``` әдісі жасайтын есептеумен салыстырыңыз:

```python
phrase = "Bananarama!"
print(phrase.find('a'))
print(my_find(phrase,'a'))
```

Python-ның кірістірілген ```find``` әдісі белгілі бір мағынада индекстеу операторына қарама-қарсы. Индексті алып, сәйкес таңбаны шығарудың орнына ол таңбаны алып, сол таңба пайда болған индексті табады. Таңба табылмаса, функция -1 қайтарады.

Бұл, цикл ішіндегі ```return``` амалын көретін тағы бір мысал бола алады. Егер, ```letter == x``` болса, функция циклден ерте, аяқсыз шығып, дереу қайтарылады.

Егер таңба тіркесте пайда болмаса, бағдарлама циклден қалыпты түрде шығып, -1 қайтарады.

Бұл есептеу үлгісін кейде **эврика траверсал** немесе **қысқа тұйықталу бағалауы** (short-circuit evaluation) деп атайды, өйткені біз іздеген нәрсені тапқан бойда «Эврика!» деп айқайлап, қысқа тұйықталуды алып, іздеуді тоқтата аламыз.

## 8.11. Цикл және санау

Келесі бағдарлама тіркесте ```а``` әрпінің пайда болу санын санайды және "Сандарды санау" бөлімінде қарастырылған санау үлгісінің тағы бір мысалы болып табылады:

```python
fc_club = "FC Liverpool"

def count_letter(phrase, x):
    counter = 0
    for letter in phrase:
        if letter == x:
            counter += 1
    return counter


print(count_letter(fc_club, "o"))
```

```python
fc_club = "FC Liverpool"


def count_letter(phrase, x):
    counter = 0
    for letter in phrase:
        if letter.lower() == x:
            counter += 1
    return counter


print(count_letter(fc_club, "l"))
```

## 8.12. Қосымша параметрлер

Тіркестегі таңбаның екінші немесе үшінші рет кездесетін орындарын табу үшін іздеу жолындағы бастапқы орынға үшінші параметрді қоса отырып, ```find``` функциясын өзгертуге болады:

```python
def find2(phrase, x, start):
    for index,letter in enumerate(phrase[start:]):
        if letter == x:
            return index + start
    return -1

print(find2("We are learning Python ", "e", 4))
```

```python
>>> 5
```

```find2("We are learning Python", "e", 4)``` шақыруы енді 5 мәнін қайтарады , "We are learning Python" тіркесінде index 4-тен бастап іздегенде "e"-нің бірінші рет кездесуі 5-ке тең. ```find2("We are learning Python", "r", 6)``` нені қайтарады? Егер сіз 10 деп айтсаңыз, ```find2```-нің қалай жұмыс істейтінін жақсы түсініп қалдыңыз деген сөз.

Одан да жақсырақ, қосымша параметрді пайдаланып ```find``` және ```find2``` біріктіре аламыз:

```python
def find(phrase, x, start=0):
    for index,letter in enumerate(phrase[start:]):
        if letter == x:
            return index + start
    return -1


print(find("We are learning Python ", "e", 4))1
```

Функцияның қосымша параметрі болған кезде, шақырушы сәйкес аргумент беруі мүмкін. ```find``` функциясына үшінші аргумент берілсе, ол ```start``` параметріне тағайындалады. Бірақ егер функцияны шақырушы аргументті қалдырса, онда ```start``` параметріне функция анықтамасындағы ```start=0``` тағайындауымен көрсетілген default (әдепкі) мән беріледі.

Сонымен ```find``` функциясының осы нұсқасына ```find("We are learning Python ", "e", 4)``` шақыруы дәл ```find2``` сияқты әрекет етеді, ал ```find("We are learning Python ", "e")``` шақыруыда ```start``` әдепкі 0 мәніне орнатылады. (**default value**)

```find``` үшін басқа қосымша параметрді қосу оны сондағы позициядан соңғы позицияға дейін іздеуге мүмкіндік береді (бірақ соңғы позиция қосылмайды):

```python
def find(phrase, x, start=0, end=-1):
    for index,letter in enumerate(phrase[start:end]):
        if letter == x:
            return index + start
    return -1


print(find("We are learning Python ", "e", 4))
```

Бұл функциядағы ```start``` пен ```end``` семантикасы ```range``` функциясындағымен бірдей.

## 8.13. Кірістірілген find әдісі

Көп мүмкіндік беретін ```find``` функциясын жазып көрдік, тексердік. Енді сіздерге, шын мәнінде тіркестің ```find``` деп аталатын әдісі бар екенін айта аламыз.  Ол біздің код жасай алатын барлық нәрсені жасай алады және одан да артық! Жоғарыдағы мысалдарды жасап көріңіз, және нәтижелерін тексеріңіз.

Кірістірілген ```find``` әдісі біздің нұсқаға қарағанда жалпы. Ол жалғыз таңбаларды емес, ішкі тіркестерді таба алады:

```python
>>> "banana".find("nan")
2
>>> "banana".find("na", 3)
4
```

Әдетте біз өз эквиваленттерімізді қайта ойлап тапқаннан гөрі Python ұсынатын әдістерді пайдаланғанды жөн көреміз. Бірақ көптеген кірістірілген функциялар мен әдістерді өзіміз жасау не ашып талдау жақсы оқыту жаттығуларының мысалы бола алады және бұл білім сіз жақсы бағдарламашы болу үшін пайдалы.

## 8.14. split - бөлу әдісі 

Тіркестегі ең пайдалы әдістердің бірі ```split``` - бөлу әдісі болып табылады: ол бір ұзын сөйлем тіркесті жеке сөздер тізіміне бөледі, олардың арасындағы барлық бос орындарды жояды. (Бос орын кез келген tab, жаңа жолдарды (newlines) немесе бос орындарды (space) білдіреді.) Бұл бізге енгізуді бір тіркес ретінде оқуға және оны сөздерге бөлуге мүмкіндік береді.

```python
>>> phrase = "Well I never did said Alice"
>>> words = phrase.split()
>>> words
['Well', 'I', 'never', 'did', 'said', 'Alice']
```

## 8.15. Тізбектерді тазалау

Біз көбінесе тыныс белгілерін немесе tab (қойынды) және жаңа жол таңбаларын қамтитын тізбектермен жұмыс істейміз, әсіресе, біз файлдан немесе Интернеттен мәтінді оқығанда, болашақ тарауда көретін боламыз. Алайда біз сөз жиілігін санау немесе әрбір сөздің емлесін тексеру үшін бағдарлама жазып жатсақ, бұл қажетсіз таңбаларды алып тастағанды жөн көреміз.

Біз тіркестен тыныс белгілерін алып тастаудың бір ғана мысалын көрсетеміз. Тіркестің өзгермейтінін есте сақтаңыз, сондықтан тыныс белгілері бар тіркестерді өзгерте алмаймыз — біз бастапқы тіркесті айналып өтіп, тыныс белгілерін алып тастап жаңа тіркес жасауымыз керек:

```python
punctuation = "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~"

def remove_punctuation(phrase):
    phrase_sans_punct = ""
    for letter in phrase:
        if letter not in punctuation:
            phrase_sans_punct += letter
    return phrase_sans_punct
```

Жоғарыдағы бірінші тағайындауды (```punctuation = "!..```) орнату қиын және қатеге бейім. Бақытымызға орай, Python ```string``` модулі мұны біз үшін жасайды. Сондықтан біз бұл бағдарламаны аздап жақсартамыз — ```string``` модулін импорттаймыз және оның анықтамасын қолданамыз:

```python
import string

def remove_punctuation(phrase):
    phrase_sans_punct = ""
    for letter in phrase:
        if letter not in string.punctuation:
            phrase_sans_punct += letter
    return phrase_sans_punct
```

Төмендегі мысалдарды байқап көріңіз: “Well, I never did!”, said Alice. “Are you very, very, sure?”

Осы функцияны және алдыңғы бөлімдегі ```split``` әдісін бірге құрастыру пайдалы комбинацияны жасайды — тыныс белгілерін тазалаймыз, ал ```split``` тіркесті сөздер тізіміне айналдыру кезінде жаңа жолдар мен қойындыларды тазартады:

```python
my_story = """
Pythons are constrictors, which means that they will 'squeeze' the life
out of their prey. They coil themselves around their prey and with
each breath the creature takes the snake will squeeze a little tighter
until they stop breathing completely. Once the heart stops the prey
is swallowed whole. The entire animal is digested in the snake's
stomach except for fur or feathers. What do you think happens to the fur,
feathers, beaks, and eggshells? The 'extra stuff' gets passed out as ---
you guessed it --- snake POOP! """

words = remove_punctuation(my_story).split()
print(words)
```

Шығару:

```python
['Pythons', 'are', 'constrictors', ... , 'it', 'snake', 'POOP']
```

Басқа пайдалы тіркес әдістері бар, бірақ бұл кітап анықтамалық нұсқаулық ретінде арналмаған. Екінші жағынан, [The Python Standard Library](https://docs.python.org/3/library/) керек барлық ақпаратты қамтиды, басқа да құжаттар Python [ресми веб-парақшасында](https://www.python.org/doc/) қол жетімді. Google-дан да керек ақпаратты оңай табуға болады. Болашақта қажетіңізге қарай тауып, қолданып үйренетін боласыз.

## 8.16. Тіркес пішімі әдісі / The string format method

Python 3-те тіркесті пішімдеудің ең оңай және ең тиімді әдісі ```format``` (пішімдеу) әдісін пайдалану болып табылады. Мұның қалай жұмыс істейтінін көру үшін бірнеше мысалдан бастайық:

```python
phrase = "His name is {0}!".format("Arthur")
print(phrase)

name = "Alice"
age = 10
phrase = "I am {1} and I am {0} years old.".format(age, name)
print(phrase)
phrase = "I am {0} and I am {1} years old.".format(age, name)
print(phrase)

x = 4
y = 5
phrase = "2**10 = {0} and {1} * {2} = {3:f}".format(2**10, x, y, x * y)
print(phrase)
```

Скриптті орындау мынандай нәтиже береді:

```
>>> His name is Arthur!
>>> I am Alice and I am 10 years old.
>>> I am 10 and I am Alice years old.
>>> 2**10 = 1024 and 4 * 5 = 20.000000
```

Үлгі тіркесі (template string) орын ұстаушыларды (_place holders_) қамтиды, үлгі тіркесі тырнақшаның ішіндігі "тіркестер" ал орын ұстаушылар мыналар ... {0} ... {1} ... {2} ... т.б. Ал ```format``` әдісі өз аргументтерін толтырғыштардың орнына қойып алмастырады. Орын ұстаушылардың сандары қай аргументтің ауыстырылатынын анықтайтын индекстер болып табылады — жоғарыдағы 6-шы және 8-ші жолдарды түсінгеніңізге көз жеткізіңіз!

🔤 place holders - орын ұстағыш, толтырғыш

Басқа да айтатын ақпаратымыз бар! Алмастыру толтырғыштардың әрқайсысында **format specification** (пішім спецификациясы) деп аталатын нәрсе болуы мүмкін — ол әрқашан **:** таңбасы арқылы енгізіледі (жоғарыдағы 13-ші жолда біреуі қолданылған, ```{3:f}```). Format specification үлгідегі ауыстырулардың жасалу жолын өзгертеді және келесідей нәрселерді басқара алады:

- жазу аймағы солға < , ортаға ^ немесе оңға > тураланған ба

- нәтиже тіркесінде толтырғышқа бөлінген ені (```10``` деген сияқты сан жазамыз)

- түрлендіру түрі (жоғарыдағы кодтың 13-ші жолындағыдай біз бастапқыда тек ```float``` түрлендіруді мәжбүрлейміз - ```f```, немесе ```x``` арқылы бүтін сандарды он алтылық санау жүйесіне түрлендіруді сұрауымыз мүмкін)

- егер түр түрлендіру ```float``` болса, сіз қанша ондық таңба қажет екенін де көрсете аласыз (әдетте, ```.2f``` екі ондық таңбаға дейінгі валюталармен жұмыс істеу үшін пайдалы).

Көптеген қажеттіліктер үшін жеткілікті болуы керек бірнеше қарапайым және жиі кездесетін мысалдар жасайық. Егер сізге [эзотерикалық](https://kk.wikipedia.org/wiki/%D0%AD%D0%B7%D0%BE%D1%82%D0%B5%D1%80%D0%B8%D0%BA%D0%B0%D0%BB%D1%8B%D2%9B_%D0%B6%D3%99%D0%BD%D0%B5_%D1%8D%D0%BA%D0%B7%D0%BE%D1%82%D0%B5%D1%80%D0%B8%D0%BA%D0%B0%D0%BB%D1%8B%D2%9B) нәрсені істеу керек болса, _анықтаманы (help)_ пайдаланыңыз және барлық ақпаратты толығырақ оқыңыз.

```python
n1 = "Paris"
n2 = "Whitney"
n3 = "Hilton"

print("Pi to three decimal places is {0:.3f}".format(3.1415926))
print("123456789 123456789 123456789 123456789 123456789 123456789")
print("|||{0:<15}|||{1:^15}|||{2:>15}|||Born in {3}|||"
        .format(n1,n2,n3,1981))
print("The decimal value {0} converts to hex value {0:x}"
        .format(123456))
```

Бұл скрипт мынадай нәтижені шығарады:

```
>>> Pi to three decimal places is 3.142
>>> 123456789 123456789 123456789 123456789 123456789 123456789
>>> |||Paris          |||    Whitney    |||         Hilton|||Born in 1981|||
>>> The decimal value 123456 converts to hex value 1e240
```

Сізде бірдей аргументті индекстейтін бірнеше толтырғыштар болуы мүмкін немесе мүлде сілтеме берілмеген қосымша аргументтер болуы мүмкін:

```python
letter = """
Dear {0} {2}.
 {0}, I have an interesting money-making proposition for you!
 If you deposit $10 million into my bank account, I can
 double your money ...
"""

print(letter.format("Paris", "Whitney", "Hilton"))
print(letter.format("Bill", "Henry", "Gates"))
```

Бұл келесідей нәтиже шығарады:

```
Dear Paris Hilton.
 Paris, I have an interesting money-making proposition for you!
 If you deposit $10 million into my bank account, I can
 double your money ...


Dear Bill Gates.
 Bill, I have an interesting money-making proposition for you!
 If you deposit $10 million into my bank account I can
 double your money ...
```

Сіз күткендей, толтырғыштар сіз бермеген аргументтерге сілтеме жасаса, индекс қатесін аласыз:

```python
>>> "hello {3}".format("Dave")
Traceback (most recent call last):
  File "<interactive input>", line 1, in <module>
IndexError: tuple index out of range
```

Келесі мысал тіркесті пішімдеудің (string formating) нақты утилитасын көрсетеді. Алдымен кестені тіркесті пішімдеуді қолданбай басып шығаруға тырысамыз:

```python
print("i\ti**2\ti**3\ti**5\ti**10\ti**20")
for i in range(1, 11):
    print(i, "\t", i**2, "\t", i**3, "\t", i**5, "\t",
                                            i**10, "\t", i**20)
```

Бұл бағдарлама 1-ден 10-ға дейінгі сандардың әртүрлі дәрежелерінің кестесін басып шығарады. (Бұл tab ені 8 деп болжайды. Егер tab-тың ені 4-ке орнатылған болса, бұдан да жаман нәтижені көруіңіз мүмкін.) Ағымдағы түрінде ол мәндердің бағандарын туралау үшін қойынды таңбасына (\\t) сүйенеді , бірақ бұл кестедегі мәндер tab енінен үлкенірек болғанда бұзылады:

```python
i       i**2    i**3    i**5    i**10   i**20
1       1       1       1       1       1
2       4       8       32      1024    1048576
3       9       27      243     59049   3486784401
4       16      64      1024    1048576         1099511627776
5       25      125     3125    9765625         95367431640625
6       36      216     7776    60466176        3656158440062976
7       49      343     16807   282475249       79792266297612001
8       64      512     32768   1073741824      1152921504606846976
9       81      729     59049   3486784401      12157665459056928801
10      100     1000    100000  10000000000     100000000000000000000
```

Бір шешім tab енін өзгерту болуы мүмкін, бірақ бірінші бағанда қажеттен көбірек орын бар. Ең жақсы шешім әр бағанның енін дербес орнату болады. Сіз ойлап қазір болжап отырғаныңыздай, тіркесті пішімдеу әлдеқайда жақсы шешімді қамтамасыз етеді. Біз сондай-ақ әрбір бағанда жазу аймағын оң-бағытта негіздей аламыз. Төмендегі код осыны жасайды. Жақсылап ойланып, қарап зерттеңіз:

```python
layout = "{0:>4}{1:>6}{2:>6}{3:>8}{4:>13}{5:>24}"

print(layout.format("i", "i**2", "i**3", "i**5", "i**10", "i**20"))
for i in range(1, 11):
    print(layout.format(i, i**2, i**3, i**5, i**10, i**20))
```

Бұл нұсқаны іске қосу келесі (қанағаттанарлық) нәтижені береді:

```python
 i  i**2  i**3    i**5        i**10                   i**20
 1     1     1       1            1                       1
 2     4     8      32         1024                 1048576
 3     9    27     243        59049              3486784401
 4    16    64    1024      1048576           1099511627776
 5    25   125    3125      9765625          95367431640625
 6    36   216    7776     60466176        3656158440062976
 7    49   343   16807    282475249       79792266297612001
 8    64   512   32768   1073741824     1152921504606846976
 9    81   729   59049   3486784401    12157665459056928801
10   100  1000  100000  10000000000   100000000000000000000
```

## 7.13 Тіркестермен жұмыс жасау

Тіркестермен жұмыс жасайтын _шынымен_ маңызды төрт қана амал бар, және біз оларды жақсылап қолданып үйренсек, бізге керектің барлығын жасай аламыз. Әрине, өзге де "бар болса жақсы болар еді" дейтін, бағдарламалауды жеңлідедетін басқа да әдістер (methods) бар, бірақ осы қарастыратын төрт амалды жақсылап үйреніп алсақ оның өзі жақсы бастама. 

- ```len(str)``` тіркестің ұзындығын табады
- ```str[i]``` тармақша (subscript) операциясы жаңа тіркес ретінде тіркестің i'-ші таңбасын шығарады.
- ```str[i:j]``` кесінді (slice) операциясы жолдан ішкі жолды шығарады.
- ```str.find(нысан-сөз)``` нысан-сөз тіркестің ішінде орын алатын индексті қайтарады немесе ол табылмаса -1.

Мысалы "snake" тіркесі ```s``` тіркесінде substring ретінде бар ма деген сұраққа жауап іздесек, біз былай жаза аламыз:

```python
if s.find("snake") >= 0: ...
if "snake" in s: ...
```

Тіркесте «snake» _сөзі_ бар ма деп сұрамайынша, жолды сөздерге бөлу дұрыс болмас еді.

Бізден кейбір ақпараттар жазбасын оқып, бір функция анықтамасын табу сұралды делік, мысалы, ```def some_function_name(x, y):```, және бізге оны одан әрі оқшаулауды және функцияның атымен жұмыс істеуді сұрайды (мысалы оны басып шығаруымыз керек): 

```python
s = "..."       # Get the next line from somewhere
def_pos = s.find("def ") # Look for "def " in the line
if def_pos == 0: # If it occurs at the left margin
    op_index = s.find("(") # Find the index of the open parenthesis
    fnname = s[4:op_index] # Slice out the function name
    print(fnname) # ... and work with it.        
```

Бұл идеяларды ары қарай кеңейтуге болады:
- Егер функция ```def```-і бос орын қалдырылып жазылса және 0-ші жолда басталмаса не болар еді? Код аздаған түзетулерді талап етеді, және біз ```def_pos``` позициясының алдындағы бос орынның барлығы space екеніне нақты сенімді болуымыз керек. Біз келесідей мәнге қате әрекеттер жасағымыз келмейді: ```# I def initely like Python!```
- Біз 3-ші жолда ашық жақшаны табамыз деп болжадық. Біз оны жасағанымызды тексеру қажет болуы мүмкін!
- Біз сондай-ақ ```def``` кілт сөзі мен функция атауының басы арасында дәл бір бос орын бар деп болжадық. Бұл ```def   f(x)``` үшін сәйкес келмейді

Жоғарыда айтқанымыздай, тіркестермен оңай жұмыс істеуге мүмкіндік беретін көптеген «қантпен қапталған» әдістер бар. 

Тіркесті соңынан артқа қарай іздейтін ```find``` сияқты ```rfind``` әдісі бар. Егер біз бір нәрсенің соңғы пайда болуын тапқымыз келсе, бұл пайдалы. 

```lower``` (төменгі) және ```upper``` (жоғарғы) әдістері регистрді түрлендіруді жасай алады. 

Ал ```split``` (бөлу) әдісі тіркесті сөздер тізіміне немесе жолдар тізіміне бөлу үшін тамаша. 

Біз бұл кітапта ```format``` (пішім) әдісін де кеңінен қолдандық. 

Шындығында, егер біз Python құжаттамасын оқуды және кейбір жаңа әдістерді өз бетінше үйренгіміз келсе, string әдістері тамаша ресурс болып табылады.

Жаттығулар:

- Кез келген мәтін жолында «http://» деп басталып, жолдағы келесі бос орынмен аяқталатын ең көп дегенде бір ғана URL болуы мүмкін делік. Бар болса, осы URL-дің толық мекенжайын шығарып алу және басып шығару үшін код фрагментін жазыңыз. (Кеңес: ```find``` үшін құжаттаманы оқыңыз. Ол қосымша аргументтер қабылдайды, сондықтан ол іздейтін бастапқы нүктені орнатуға болады.)

- Тіркесте ең көбі бір «< . . . >” ішкі-тіркес (substring) бар делік. Бұрыштық жақшалар арасындағы тіркестің бөлігін шығарып алу және басып шығару үшін код фрагментін жазыңыз.

## 8.18. Түйіндеме 

Бұл тарауда көптеген жаңа идеялар таныстырылды. Төмендегі түйіндеме сіз танысқан ақпаратты есте сақтауға көмектесуі мүмкін.

**индекстеу / indexing** (```[ ]```)
Тіркестегі бір таңбаға оның орнын пайдаланып қол жеткізу (санау 0-ден басталады). Мысал: "This"\[2] деп енгізсек, ол "i" деп бағалайды.

**ұзындық функциясы / length function** (**```len```**)
Тіркестегі таңбалар санын қайтарады. Мысал: ```len("happy")``` 5 деп нәтиже береді.

**for цикл траверсал / for loop traversal** (```for```)
Тіркесті _өту (traversing)_ тіркестегі әрбір таңбаға бір-бірден қол жеткізуді білдіреді. Мысалы, келесі ```for``` циклі:

```python
for ch in "Example":
    ...
```

... әр жолы ```ch```-тің мәні әртүрлі болып цикл денесін 7 рет айналады.

**кесу / slicing** (```[:]```)
Кесінді – тіркестің ішкі кіші бөлік тіркесі. Мысал: ```'bananas and cream'[3:6]``` мәні ```ana``` болады (сол сияқты ```'bananas and cream'[1:4]```-тің де мәні ```ana```).

**тіркесті салыстыру / string comparison** (**```>, <, >=, <=, ==, !=```**)
Алты жалпы салыстыру операторлары лексикографиялық тәртіпке сәйкес бағалай отырып, тіркестермен жұмыс істейді. Мысалдар: ```"apples" < "banana""``` ```True``` деп бағаланады. ```"Zeta" < "Appricot"``` ```False``` деп бағаланады. ```"Zebra" <= "aardvark"``` ```True``` деп бағаланады, себебі барлық бас әріптер кіші әріптердің алдында тұрады.

**in and not in operator (```in```, ```not in```)**
```in``` операторы мүшелікке сынақ жасайды. Тіркестер жағдайында ол бір тіркестің басқа тіркес ішінде болуын тексереді. Мысалдар: ```"heck" in "I'll be checking for you." True``` деп бағаланады. ```"cheese" in "I'll be checking for you."``` ```False``` деп бағаланады.

## 8.19. Глоссарий 

**құрама деректер түрі / compound data type**
Мәндері құрамдас бөліктерден немесе элементтерден тұратын деректер түрі. Құрамдас бөліктер мен элементтердің өзі мәндерден тұрады.

**әдепкі мән / default value**
Функция шақыруында оған аргумент берілмесе, қосымша параметрге берілген мән.

**docstring**
Функцияның немесе модуль анықтамасының бірінші жолындағы тұрақты жол (және кейінірек object пен әдіс анықтамаларында да көретін боламыз). Docstrings құжаттаманы кодпен байланыстырудың ыңғайлы жолын қамтамасыз етеді. Құжат жолдары интерактивті анықтаманы қамтамасыз ету үшін бағдарламалау құралдарымен де қолданылады.

**нүкте белгісі / dot notation**
Нүкте операторын қолдану, **.** , объектінің әдістері мен атрибуттарына қол жеткізу үшін.

**өзгермейтін деректер мәні / immutable data value**
Өзгертуге болмайтын деректер мәні. Элементтерге немесе өзгермейтін мәндердің кесінділеріне (ішкі бөліктерге) тағайындаулар орындалу қатесін тудырады.

**индекс / index**
Тіркестегі таңба немесе тізімдегі элемент сияқты реттелген жинақтың мүшесін таңдау үшін пайдаланылатын айнымалы немесе мән.

**өзгермелі деректер мәні / mutable data value**
Өзгертуге болатын деректер мәні. Барлық өзгермелі мәндердің түрлері құрама типтер болып табылады. Тізімдер мен сөздіктер өзгермелі; тіркестер мен кортеждер жоқ.

**қосымша параметр / optional parameter**
Default мәні тағайындалған функция басында жазылған параметр. Егер функция шақырылғанда параметрге сәйкес аргумент берілмеген болса осы default мән орнына беріледі

**қысқа тұйықталған бағалау / short-circuit evaluation**
Нәтиже сенімді түрде белгілі болғаннан кейін қосымша жұмысты қысқартатын бағдарламалау стилі. Бұл тарауда ```find``` функциямыз іздеген нәрсені тапқан бойда қайтарылды; ол тіркестегі барлық қалған элементтерді айналып өтпеді.

**slice / тілім**
Индекстер ауқымымен көрсетілген тіркестің бөлігі (substring). Жалпы алғанда, Python тіліндегі кез келген реттілік түрінің ішкі тізбегін кесу операторы арқылы алуға болады (```sequence[start:stop]```).

**traverse / өту**
Әрқайсысында ұқсас әрекетті орындай отырып жинақ элементтерін аралап өту.

**бос орын / whitespace**
Көрінетін таңбаларды басып шығармай, курсорды жылжытатын кез келген таңба. ```whitespace``` барлық бос орын таңбаларын қамтиды.

## 8.20. Жаттығулар

1. Төмендегілердің әрқайсысының нәтижесі қандай:

```python
>>> "Python"[1]
>>> "Strings are sequences of characters."[5]
>>> len("wonderful")
>>> "Mystery"[:4]
>>> "p" in "Pineapple"
>>> "apple" in "Pineapple"
>>> "pear" not in "Pineapple"
>>> "apple" > "pineapple"
>>> "pineapple" < "Peach"
```

2. Төмендегі кодты:

```python
prefixes = "JKLMNOPQ"
suffix = "ack"

for letter in prefixes:
    print(letter + suffix)
```

```Ouack``` және ```Quack``` дұрыс жазылатындай етіп өзгертіңіз.

3. Инкапсуляциялау

```python
word = "banana"
count = 0
for letter in word:
    if letter == "a":
        count += 1
print(count)
```

```count_letter``` деп аталатын функцияда инкапсуляция жаса және оны тіркес пен санау керек әріпті аргумент ретінде қабылдайтындай етіп жалпылаңыз. Жауапты басып шығарудың орнына функцияны таңбалар санын қайтаратындай етіп жасаңыз. Функцияны шақырушы басып шығаруды орындауы керек.

4. Енді ```count_letter``` функциясын өзгертіп жазыңыз, ол тіркесті айналып өтудің орнына қайта-қайта ```find``` әдісін шақыратын болсын, және санақ жасалатын әріптің жаңа кездесулерін табу үшін қосымша үшінші параметрі болсын.

5. Бағдарламаңыздағы айнымалыға сіз жақсы көретін мәтіннің абзацын қамтитын үш тырнақшалы тіркесті тағайындаңыз - мүмкін өлең, сөз, торт пісіру нұсқаулары, кейбір шабыттандыратын өлеңдер және т.б.

Тіркестегі тыныс белгілерінің барлығын алып тастайтын, тіркесті сөздер тізіміне бөлетін және мәтініңізде **«e» әрпі бар сөздердің санын** есептейтін функцияны жазыңыз. Сіздің бағдарламаңыз мәтіннің талдауын келесідей басып шығаруы керек:

```python
Your text contains 243 words, of which 109 (44.8%) contain an "e".
# Сіздің мәтініңізде 243 сөз бар, оның 109-ында (44,8%) «е» әрпі бар.
```

6. Мынадай ұқыпты көрінетін көбейту кестесін басып шығарыңыз:

```python
        1   2   3   4   5   6   7   8   9  10  11  12
  :--------------------------------------------------
 1:     1   2   3   4   5   6   7   8   9  10  11  12
 2:     2   4   6   8  10  12  14  16  18  20  22  24
 3:     3   6   9  12  15  18  21  24  27  30  33  36
 4:     4   8  12  16  20  24  28  32  36  40  44  48
 5:     5  10  15  20  25  30  35  40  45  50  55  60
 6:     6  12  18  24  30  36  42  48  54  60  66  72
 7:     7  14  21  28  35  42  49  56  63  70  77  84
 8:     8  16  24  32  40  48  56  64  72  80  88  96
 9:     9  18  27  36  45  54  63  72  81  90  99 108
10:    10  20  30  40  50  60  70  80  90 100 110 120
11:    11  22  33  44  55  66  77  88  99 110 121 132
12:    12  24  36  48  60  72  84  96 108 120 132 144
```

7. Тіркес аргументін керісінше жазатын және мына сынақтарды қанағаттандыратын функцияны жазыңыз:

```python
test(reverse("happy") == "yppah")
test(reverse("Python") == "nohtyP")
test(reverse("") == "")
test(reverse("a") == "a")
```

8. Берілген аргументтің "айна кескінін" шығаратын функцияны жазыңыз:

```python
test(mirror("good") == "gooddoog")
test(mirror("Python") == "PythonnohtyP")
test(mirror("") == "")
test(mirror("a") == "aa")
```

9. Тіркестен берілген әріптің барлық кездесулерін алып тастайтын функцияны жазыңыз:

```python
test(remove_letter("a", "apple") == "pple")
test(remove_letter("a", "banana") == "bnn")
test(remove_letter("z", "banana") == "banana")
test(remove_letter("i", "Mississippi") == "Msssspp")
test(remove_letter("b", "") = "")
test(remove_letter("b", "c") = "c")
```

10. [Палиндромды](https://en-m-wikipedia-org.translate.goog/wiki/Palindrome?_x_tr_sl=en&_x_tr_tl=kk&_x_tr_hl=en&_x_tr_pto=wapp) танитын функцияны жазыңыз. (Кеңес: мұны жеңілдету үшін өзіңіз жазған ```reverse``` функциясын пайдаланыңыз!):

```python
test(is_palindrome("abba"))
test(not is_palindrome("abab"))
test(is_palindrome("tenet"))
test(not is_palindrome("banana"))
test(is_palindrome("straw warts"))
test(is_palindrome("a"))
# test(is_palindrome(""))    # Бос тіркес палиндром болып табылады ма?
```

11. Substring (ішкі тіркестің) тіркесте қанша рет кездесетінін есептейтін функцияны жазыңыз:

```python
test(count("is", "Mississippi") == 2)
test(count("an", "banana") == 2)
test(count("ana", "banana") == 2)
test(count("nana", "banana") == 1)
test(count("nanan", "banana") == 0)
test(count("aaa", "aaaaaa") == 4)
```

12. Тіркестің бірінші кездесетін жағдайын басқа басқа алып тастайтын функцияны жазыңыз:

```python
test(remove("an", "banana") == "bana")
test(remove("cyc", "bicycle") == "bile")
test(remove("iss", "Mississippi") == "Missippi")
test(remove("eggs", "bicycle") == "bicycle")
```

13. Басқа тіркесте _осы_ тіркес кездессе алып тастайтын функцияны жазыңыз:

```python
test(remove_all("an", "banana") == "ba")
test(remove_all("cyc", "bicycle") == "bile")
test(remove_all("iss", "Mississippi") == "Mippi")
test(remove_all("eggs", "bicycle") == "bicycle")
```
