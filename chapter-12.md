---
title: Numpy
isFree: true
---

## Numpy 

Стандартты Python деректер түрлері математикалық операциялар үшін аса қолайлы емес. Мысалы, бізде a = \[2, 3, 8] тізімі бар делік. Бұл тізімді бүтін санға көбейтсек, мынаны аламыз:

```python
>>> a = [2, 3, 8]
>>> 2 * a
[2, 3, 8, 2, 3, 8]
```

Ал ```float``` тіпті рұқсат етілмейді:

```python
>>> a = [2, 3, 8]
>>> 2 * a
>>> 2.1 * a
TypeError: can't multiply sequence by non-int of type 'float'
```

Мұны Python тізімдері арқылы шешу үшін бізге келесідей нәрсені істеу керек:

```python
values = [2, 3, 8]
result = []
for x in values:
result.append(2.1 * x)
```

Бұл аса ыңғайлы емес. Себебі, Python ```list``` (тізімі) математикалық нысандар ретінде жасалмаған. Керісінше, олар тек заттардың жиынтығы. Математикалық массив (array) немесе матрица сияқты әрекет ететін тізім түрін алу үшін біз Numpy қолданамыз.

```python
>>> import numpy as np
>>> a = np.array([2, 3, 8])
>>> 2.1 * a
array([ 4.2, 6.3, 16.8])
```

Көріп отырғанымыздай, бұл біз күткендей жұмыс істеді. Біз бірнеше нәрсені атап өтеміз: - Біз numpy дегенді np деп қысқарттық, бұл шартты. 

- ```np.array``` аргумент ретінде Python тізімін алады. 
- \[2, 3, 8] тізімінде ```int``` бар, бірақ нәтижеде ```float``` болады. 
- Бұл numpy біз үшін деректер түрін автоматты түрде өзгертті дегенді білдіреді. 

Енді оны бір қадам алға жылжытайық және массивтерді бір-біріне   көбейткенде не болатынын көрейік.

```python
>>> import numpy as np
>>> a = np.array([2, 3, 8])
>>> a * a
array([ 4, 9, 64])
>>> a**2
array([ 4, 9, 64])
```

Бұл массив элементі бойынша жақсы квадратқа айналдырды.

---

**Ескерту**: Білетіндер бұған таң қалуы мүмкін. Өйткені, егер ```а``` вектор болса, a\*\*2 екі вектордың нүктелік көбейтіндісі болуы керек емес пе? Бұл жерде айтуымыз керек, ```numpy``` массивтері алгебралық мағынада векторлар емес. Массивтер арасындағы арифметикалық амалдар жалпы массивтерде емес, элементтер бойынша орындалады.

```numpy```-ге нүктелік өнім қажет екенін айту үшін біз жай ғана ```np.dot``` функциясын қолданамыз:

Оған қоса, ```np.dot``` файлына 2D массивтерін жіберсеңіз, ол матрицаны көбейту сияқты әрекет етеді. Бірнеше басқа ұқсас NumPy алгебралық функциялары бар (мысалы, ```np.cross```, ```np.outer```, т.б.) 

**Қорытындылай айтсақ**: ```numpy``` массив операцияларын векторлық немесе матрицалық операциялар ретінде қарастырғыңыз келсе, осы мақсат үшін арнайы функцияларды пайдаланыңыз.

---

## 12.1 Пішін / Shape

Массивтің ең маңызды қасиеттерінің бірі - оның пішіні. Біз 1 өлшемді (1D) массивтерді көрдік, бірақ массивтердің сіз қалайтын кез келген өлшемдері болуы мүмкін. Мысалы суреттер пикселдердің 2D массивінен тұрады. Бірақ түсті суреттерде әрбір пиксел RGB кортежі болып табылады: қызыл, жасыл және көк қоюлығы. Сондықтан әрбір пикселдің өзі де массив болып табылады. Жалпы айтқанда бұл түрлі-түсті сурет, кескін 3D деген сөз.

Массивтің пішінін алу үшін ```shape``` қолданамыз:

```python
>>> import numpy as np
>>> a = np.array([2, 3, 8])
>>> a.shape
(3,)
```

Біраз қызықтырақ:

```python
>>> b = np.array([
[2, 3, 8],
[4, 5, 6],
])
>>> b.shape
(2, 3)
```

## 12.2 Кесу / Slicing

Тізімдер сияқты, біз массивтен белгілі бір мәндерді таңдағымыз келуі мүмкін. 1D массивтері үшін ол қалыпты питон тізімдері сияқты жұмыс істейді:

```python
>>> a = np.array([2, 3, 8])
>>> a[2]
8
>>> a[1:]
np.array([3, 8])
```

Дегенмен, жоғары өлшемді массивтермен жұмыс істегенде басқа нәрсе орын алады:

```python
>>> b = np.array([
[2, 3, 8],
[4, 5, 6],
])
>>> b[1]
array([4, 5, 6])
>>> b[1][2]
6
```

```b[1]``` пайдалану бірінші өлшем бойынша 1-ші жолды қайтаратынын көреміз, ол әлі де массив болып табылады. Осыдан кейін біз жеке элементтерді таңдай аламыз. Бұл қысқартуға болады:

```python
>>> b[1, 2]
6
```

Бірақ бірінші жолдың орнына 1-ші бағанды алғым келсе ше? Бірінші өлшемдегі барлық элементтерді таңдау үшін **:** белгісін, содан кейін 1-ді пайдаланамыз:

```python
>>> b[:, 1]
array([3, 5])
```

```b``` анықтамасымен салыстыра отырып, бұл біз іздеген баған екенін көреміз.

---

**Ескерту**: Біріншінің орнына 0-ші элементтің бар екенін білдіру үшін 1-ші деп жазамын. Есіңізде болсын, Python тілінде, кез келген өзін-өзі құрметтейтін бағдарламалау тілінде, біз нөлден санауды бастаймыз.

---

Кеңейтілген кесу туралы қосымша ақпаратты Numpy индекстеу құжаттамасының бетінде біліңіз.

## 12.3 Маскалау / Masking

Бұл Numpy-дің жалғыз ең күшті мүмкіндігі. Бізде массив бар делік және біз белгілі бір кесіндіден жоғары барлық мәндерді алып тастағымыз келеді:

```python
>>> a = np.array([230, 10, 284, 39, 76])
>>> cutoff = 200
>>> a > cutoff
np.array([True, False, True, False, False])
```

Жалғыз ғана **>** (үлкен/greater than) операторды пайдалану қандай жағдайда сынақ ```True``` болғанын білуге мүмкіндік береді. Енді біз 200-ден жоғары барлық мәндерді нөлге орнатамыз:

```python
>>> a = np.array([230, 10, 284, 39, 76])
>>> cutoff = 200
>>> a[a > cutoff] = 0
>>> a
np.array([0, 10, 0, 39, 76])
```

Маңызды жол – ```a[a > cutoff] = 0```. Бұл сынақ ```True``` болған массивтің барлық нүктелерін таңдап, сол позицияға 0 мәнін тағайындайды. Бұл трюкті білмей-ақ, біз массивті циклмен айналуымыз керек еді:

```python
>>> a = np.array([230, 10, 284, 39, 76])
>>> cutoff = 200
>>> new_a = []
>>> for x in a:
>>>     if x > cutoff:
>>>         new_a.append(0)
>>>     else:
>>>         new_a.append(x)
>>> a = np.array(new_a)
```

Бұл дұрыс емес көрінеді, солай емес пе? Суреттермен жұмыс істегенде бұл одан да айқын болады, себебі ```if/else``` пәрменін пайдаланбас бұрын үш өлшемді айналдыруға тура келуі мүмкін. Сіз шимақталған кодты елестете аласыз ба?

## 12.4 Broadcasting

Numpy-дің тағы бір күшті мүмкіндігі - хабар тарату (broadcasting). Тарату әртүрлі пішіндегі массивтер арасында операцияларды орындаған кезде орын алады. Мысалы

```python
>>> a = np.array([
    [0, 1],
    [2, 3],
    [4, 5],
    ])
>>> b = np.array([10, 100])
>>> a * b
array([[ 0, 100],
      [ 20, 300],
      [ 40, 500]])
```

```a``` және ```b``` пішіндері сәйкес келмейді. Жалғастыру үшін Numpy ```b``` өлшемін екінші ```a``` өлшемге ұзартады, ол өзіне үш рет жиналған сияқты. Одан кейін операция элементтік негізде орындалады.

Broadcasting ережелерінің бірі тек 1 өлшемді өлшемдерді ғана созуға болады (егер массивте тек бір өлшем болса, барлық басқа өлшемдер broadcasting мақсаттары үшін 1 өлшемді болуы үшін қарастырылады). Жоғарыдағы мысалда ```b``` - 1D және (2,) пішіні бар. Екі өлшемі бар ```a``` арқылы тарату (braodcasting) үшін Numpy 1 өлшемді басқа өлшемді ```b``` өлшеміне қосады. ```b```-ның енді (1, 2) пішіні бар. Бұл жаңа өлшемді ```b``` пішіні ```a``` пішініне (3, 2) сәйкес келетіндей етіп  енді үш рет созуға болады.

Басқа ереже - өлшемдер соңғыдан біріншіге қарай салыстырылады. Сәйкес келмейтін кез келген өлшемдерді бірдей өлшемге келтіру үшін созу керек. Дегенмен, алдыңғы ережеге сәйкес, тек 1 өлшемді өлшемдер созылуы мүмкін.

Бұл кейбір фигуралар таратыла алмайтынын және Numpy сізге қате жіберетінін білдіреді:

```python
>>> c = np.array([
[0, 1, 2],
[3, 4, 5],
])
>>> b = np.array([10, 100])
>>> c * b
ValueError: operands could not be broadcast together with shapes (2,3) (2,)
```

Бұл жерде Numpy қайтадан ```b``` өлшеміне өлшем қосып, оны (1, 2) пішінге айналдырады. Содан кейін ```b``` және ```c``` соңғы өлшемдерінің өлшемдері (сәйкесінше 2 және 3) салыстырылады және әр түрлі болып табылады. Бұл өлшемдердің ешқайсысы 1 өлшемде болмағандықтан (сондықтан, созылмайды) Numpy бас тартады және қате шығарады.


Жоғарыдағы ```c``` және ```b```-ді көбейтудің шешімі Numpy-ге тағы бір қосымша өлшемді ```b```-дің екінші өлшемі ретінде қосу керектігін нақты айту болып табылады. Бұл екінші өлшемді индекстеу үшін ```None``` пайдалану арқылы орындалады. Содан кейін ```b``` пішімі (2, 1) болады, ол ```c``` арқылы тарату үшін үйлесімді:

```python
>>> c = np.array([
    [0, 1, 2],
    [3, 4, 5],
])
>>> b = np.array([10, 100])
>>> c * b[:, None]
array([[ 0, 10, 20],
        [300, 400, 500]])
```

Осы ережелердің жақсы көрнекі сипаттамасын кейбір кеңейтілген хабар тарату қолданбаларымен бірге [Numpy хабар тарату ережелерінің осы](http://scipy.github.io/old-wiki/pages/EricsBroadcastingDoc) оқулығында табуға болады.

## 12.5 dtype 

Numpy-мен жұмыс істеуде жиі қолданылатын термин ```dtype``` - деректер түрі үшін қысқартылған атау. Бұл әдетте ```int``` немесе ```float```, одан кейін кейбір сандар, мысалы, ```int8```. ```int8``` мәннің өлшемі 8 бит болатын бүтін сан екенін білдіреді. Мысал ретінде ```int8``` қасиеттерін талқылайық.

Әрбір бит 0 немесе 1. Олардың 8-і болған кезде бізде 2-нің 8 дәрежесі = 256 мүмкін мән бар. Біз нөлдің өзін де санауымыз керек болғандықтан, мүмкін болатын ең үлкен мән 255. Біз қазір сипаттаған деректер түрі ```uint8``` деп аталады, мұнда ```u``` unsigned (таңбасыз) дегенді білдіреді: демек тек оң мәндерге рұқсат етіледі. Теріс сандарға рұқсат бергіміз келсе, ```int8``` пайдаланамыз. Олай болса диапазон -128-ден +127-ге ауысады.

Үлкен сандар үшін де солай. Мысалы, ```int64``` - 9223372036854775808 мен 9223372036854775807 диапазоны бар 64 биттік таңбасыз бүтін сан. Бұл сонымен қатар 64 биттік машинадағы стандартты түрі. Сіз үлкенірек жақсырақ деп ойлайсыз. Сіз қателесесіз. Егер сіз массивіңіздің элементтері ешқашан 100-ден үлкен болмайтынын білсеңіз, неге барлық жад кеңістігін босқа жұмсау керек? Жадты сақтау үшін массивіңізді ```uint8``` мәніне орнатқаныңыз жақсы болуы мүмкін. Жалпы, әдепкі параметр жақсы. Жадқа қатысты мәселелер туындаған кезде ғана бұл түсініктемені есте сақтау керек.

dtype максималды мәніңізден үлкенірек сандарды орнатқанда не болады?

```python
>>> import numpy as np
>>> a = np.array([200], dtype='uint8')
>>> a + a
array([144], dtype=uint8)
```

Бұл дұрыс емес сияқты, солай ма? Екі ```uint8``` қоссаңыз, 200 + 200 нәтижесі 400 бола алмайды, себебі ол ```uint8```-ге сәйкес келмейді. Стандартты Python тілінде нәтиже сіз күткен 400 болатынына көз жеткізу үшін Python фондық режимде көп сиқыр жасайды. Бірақ numpy жасамайды және 144 қайтарады. Неліктен 144 жаттығу ретінде қалды. Мұны түзету үшін сандарыңыз ```uint8``` ретінде емес, үлкенірек нәрсе ретінде сақталатынына көз жеткізіңіз; мысалы, ```uint16```. Осылайша алынған 400 сәйкес келеді.

```python
>>> import numpy as np
>>> a = np.array([200], dtype='uint16')
>>> a + a
array([400], dtype=uint16)
```


Енді сіз ойлап отырған боларсыз: соңына келгенде үлкенірек жақсырақ! Әрқашан мүмкін болатын ең үлкен int пайдаланыңыз, сонда сіз жақсы боласыз! Ең үлкен ```int``` жоқтығынан басқа, үлкен мәселе бар. Суреттермен жұмыс жасасаңыз, сол кескіннің әрбір пикселі RGB кортежі ретінде сақталады: қызыл, жасыл және көк қоюлығы. Олардың әрқайсысы .jpg және .png сияқты стандартты пішімдердің көпшілігі үшін ```uint8``` мәні болып табылады. Мысалы, (0, 0, 0) қара болады, ал (255, 0, 0) қызыл болады.


Қатты дискіден суретті жүктеген кезде бұл dтипі сіз үшін таңдалады және сіз бұл туралы білмесеңіз, суретті өзіне қосқанда не болады? (Басқаша айтқанда, екі көшірмені бір-бірінің үстіне қойыңыз) Барлығы қоюырақ болады деп күтуіңіз мүмкін. Оның орнына, біз айтқан әсерге байланысты шу (noise) аласыз.


## 12.6 dтүрін өзгерту

Бар массивтің dтүрін өзгерту үшін ```astype``` әдісін қолдануға болады:

```python
>>> import numpy as np
>>> a = np.array([200], dtype='uint8')
>>> a.astype('uint64')
```

## 12.7 Advanced usage /  Қосымша қолданыс

Numpy кең мүмкіндіктері бар. Мұнда талқылауға болатын нұсқалар өте көп. Қосымша ақпаратты мына жерден табуға болады

1. [Quickstart Numpy](https://numpy.org/doc/stable/user/quickstart.html) оқулығы;

2. [Numpy индекстеу](https://numpy.org/doc/stable/reference/arrays.indexing.html) құжаттамасы (кеңейтілген кесу және индекстеу үшін);

3. және [Numpy хабар тарату ережелері](http://scipy.github.io/old-wiki/pages/EricsBroadcastingDoc) (әртүрлі пішіндер мен өлшемдердің массивтері арасындағы әрекеттерді орындау кезінде не болатыны үшін).

## 12.8 Жаттығулар

1. dtype = uint8 және өзің таңдаған элементтері бар массив жасаңыз. Элементтер 255-тен жоғары болғанша (біреуі) оған қосуды жалғастырыңыз. Не болады? Кеңес: массив жасаңыз және оған тұрақты мәнді қосыңыз. Тұрақты мән массивтің барлық элементтеріне элемент негізінде қосылады.

2. Келесі тізімдегі 100-ден төмен барлық мәндерді 2-ге көбейту үшін масканы пайдаланыңыз:

```python
>>> a = np.array([230, 10, 284, 39, 76])
```

Мұны барлық мәндер 100-ден жоғары болғанша қайталаңыз. (Қолмен емес, цикл арқылы)

Содан кейін 150 < a < 200 арасындағы барлық мәндерді таңдаңыз.
