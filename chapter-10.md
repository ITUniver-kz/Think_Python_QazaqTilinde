---
title: Тізімдер
isFree: True
---

# Тізімдер. Lists

Тізім (**list**) – мәндердің реттелген жиыны. Тізімді құрайтын мәндер оның элементтері (**elements**) немесе заттары (**items**) деп аталады. Element және items сөздері бір нәрсені білдіреді және ауыстрырылып қолданылады. Тізімдер таңбалардың реттелген жиыны болып табылатын тіркесерге (string) ұқсас, тек тізімнің элементтері кез келген типте болуы мүмкін (any data type). Тізімдер мен тіркестер — және элементтерінің ретін сақтайтын өзге де жинақтар — тізбектер (**sequences**) деп аталады.

---

## 10.1. Тізім мәндері

Жаңа тізім жасаудың бірнеше жолы бар; ең қарапайымы - элементтерді төртбұрышты жақшаға алу (\[ _және_ ]):

```python
numbers = [10, 20, 30, 40]
words = ["spam", "bungee", "swallow"]
```

Бірінші мысал - төрт бүтін санның тізімі. Екіншісі - үш тіркестің тізімі. Тізім элементтері бір типті болуы міндетті емес. Келесі тізімде string, float, бүтін сан және (о, ғажап) басқа тізім бар:

```python
arturli = ["hello", 2.0, 5, [10, 20]]
```

Басқа тізімдегі тізім кірістірілген (**nested**) деп аталады.

Және, элементтері жоқ тізім _бос тізім_ деп аталады және ```[]``` деп белгіленеді.

Тізім мәндерін айнымалыларға тағайындауға немесе тізімдерді функцияларға параметр ретінде беруге болады:

```python
>>> vocabulary = ["apple", "cheese", "dog"]
>>> numbers = [17, 123]
>>> an_empty_list = []
>>> print(vocabulary, numbers, an_empty_list)
["apple", "cheese", "dog"] [17, 123] []
```

## 10.2. Элементтерге қол жеткізу

Тізім элементтеріне қол жеткізу синтаксисі тіркестің символдарына қол жеткізу синтаксисі сияқты — индекс операторы: ```[]``` (бос тізіммен шатастырмау керек). Жақша ішіндегі өрнек индексті көрсетеді. Индекстердің 0-ден басталатынын есте сақтаңыз:

```python
>>> numbers[0]
17
```

Бүтін санға бағаланатын кез келген өрнек индекс ретінде пайдаланылуы мүмкін:

```python
>>> numbers[9-8]
5
>>> numbers[1.0]
Traceback (most recent call last):
  File "<interactive input>", line 1, in <module>
TypeError: list indices must be integers, not float
```

Егер жоқ элементті алуға немесе оған тағайындауға әрекеттенсеңіз, орындалу уақыты қатесін аласыз:

```python
>>> numbers[2]
Traceback (most recent call last):
  File "<interactive input>", line 1, in <module>
IndexError: list index out of range
```

Тізім индексі ретінде _циклдік айнымалыны_ пайдалану жиі кездеседі (бірақ бұл дұрыс емес!).

```python
fc_milan = ["Dida", "Maldini", "Nesta", "Kafu", "Oddo"]

for i in [0, 1, 2, 3]:
    print(fc_milan[i])
```

Цикл арқылы өткен сайын ```i``` айнымалысы ```i```-ші элементті басып шығару үшін тізімге индекс ретінде пайдаланылады. Бұл есептеу үлгісі тізімді өту (**list traversal**) деп аталады.

Жоғарыда келтірілген мысал ```i``` индексін тізімнен элементтерді алудан басқа ештеңе үшін қажет етпейді немесе пайдаланбайды, сондықтан төмендегі тікелей нұсқа - мұнда ```for``` циклі элементтерді алады - бұл нұсқа өте қарапайым және түсініктірек:

```python
fc_milan = ["Dida", "Maldini", "Nesta", "Kafu", "Oddo"]

for player in fc_milan:
    print(player)
```

## 10.3. Тізім ұзындығы

```len``` функциясы тізім ұзындығын қайтарады, ол оның элементтерінің санына тең. Тізімге қол жеткізу үшін бүтін сан индексті пайдаланғыңыз келсе, ```len``` мәнін тұрақты мәннің орнына циклдің жоғарғы шегі ретінде пайдаланған дұрыс. Осылайша, тізімнің өлшемі өзгерсе, бағдарламадағы барлық циклдарды өзгертетіп қайта жазудың қажеті жоқ; ```len``` мәні ұзындығы кез-келген тізім үшін дұрыс жұмыс істейді:

```python
fc_milan = ["Dida", "Maldini", "Nesta", "Kafu", "Oddo", "Gattuzo", "Van Bommel", "Pirlo", "Seedorf", "Shevchenko", "Inzaghi"]

for i in range(len(fc_milan)):
    print(fc_milan[i])
```

Соңғы рет цикл денесі орындаларда, ```i``` мынаған тең ```len(fc_milan) - 1``` , бұл соңғы элементтің индексі.

Тізімде басқа тізім болуы мүмкін болса да, кірістірілген тізім оның негізгі тізіміндегі жалғыз элемент ретінде саналады. Мысалы мына тізімнің ұзындығы 4-ке тең:

```python
>>> len(["car makers", 1, ["Ford", "Toyota", "BMW"], [1, 2, 3]])
4
```

## 10.4. Тізім мүшелігі

```in``` және ```not in``` тізбектегі мүшелікті тексеретін Boolean операторлары. Біз оларды бұрын тіркестермен пайдаландық, бірақ олар тізімдермен және басқа тізбектермен де жұмыс істейді:

```python
>>> fc_milan = ["Dida", "Maldini", "Nesta", "Kafu", "Oddo", "Gattuzo", "Van Bommel", "Pirlo", "Seedorf", "Shevchenko", "Inzaghi"]
>>> "Pirlo" in fc_milan
True
>>> "Buffon" in fc_milan
False
>>> "Trezeguet" not in fc_milan
True
```

```in``` және ```not in``` - ді пайдалану бізге жинақы, түсінікті код жазуға мүмкіндік береді. Мысалы төмендегі кодта Computer Science (CompSci) мамандығын оқитын студенттер санын анықтайтын программа қалай жазылғанын қарап, түсініп алыңыз:

```python
students = [
    ("John", ["CompSci", "Physics"]),
    ("Vusi", ["Maths", "CompSci", "Stats"]),
    ("Jess", ["CompSci", "Accounting", "Economics", "Management"]),
    ("Sarah", ["InfSys", "Accounting", "Economics", "CommLaw"]),
    ("Zuki", ["Sociology", "Economics", "Law", "Stats", "Music"])]

# Count how many students are taking CompSci
counter = 0
for (name, subjects) in students:
    if "CompSci" in subjects:
           counter += 1

print("The number of students taking CompSci is", counter)
```

## 10.5. Тізім операциялары

\+ операторы тізімдерді конкатенация жасайды (біріктіреді):

```python
>>> a = [1, 2, 3]
>>> b = [4, 5, 6]
>>> c = a + b
>>> c
[1, 2, 3, 4, 5, 6]
```

Сол сияқты * операторы тізімді берілген сан рет қайталайды:

```python
>>> [0] * 4
[0, 0, 0, 0]
>>> [1, 2, 3] * 3
[1, 2, 3, 1, 2, 3, 1, 2, 3]
```

Бірінші мысал \[0]-ді төрт рет қайталайды. Екінші мысал \[1, 2, 3] тізімін үш рет қайталайды.

## 10.6. Тізім кесінділері

Тіркестермен бұрын көрген кесу (```slice```) операциялары бізге ішкі тізімдермен жұмыс істеуге мүмкіндік береді:

```python
>>> a_list = ["a", "b", "c", "d", "e", "f"]
>>> a_list[1:3]
['b', 'c']
>>> a_list[:4]
['a', 'b', 'c', 'd']
>>> a_list[3:]
['d', 'e', 'f']
>>> a_list[:]
['a', 'b', 'c', 'd', 'e', 'f']
```

## 10.7. Тізімдер өзгермелі

Тіркестерден және кортеждерден айырмашылығы, тізімдер өзгермелі (**mutable**), яғни біз олардың элементтерін өзгерте аламыз. Тағайындаудың сол жағындағы индекс операторын пайдаланып, элементтердің бірін жаңарта аламыз:

```python
>>> fruit = ["banana", "apple", "quince"]
>>> fruit[0] = "pear"
>>> fruit[2] = "orange"
>>> fruit
['pear', 'apple', 'orange']
```

Тізімге қолданылатын жақша операторы өрнектің кез келген жағында болуы мүмкін. Тағайындаманың сол жағында қолданылған кезде, ол тізімдегі элементтердің бірін өзгертеді, сондықтан жемістің бірінші элементі «бананнан» « алмұртқа» , ал соңғысы «айвадан» « апельсинге» өзгертілді. Тізімге элемент тағайындау **item assignment** деп аталады:

```python
>>> my_list = ["T", "E", "S", "T"]
>>> my_list[2] = "X"
>>> my_list
['T', 'E', 'X', 'T']
```

\* және алдыңғы тараулардан білетініміздей тіркестер/_string_ үшін бұл жұмыс жасамайды:

```python
>>> my_string = "TEST"
>>> my_string[2] = "X"
Traceback (most recent call last):
  File "<interactive input>", line 1, in <module>
TypeError: 'str' object does not support item assignment
```

```slice``` (кесу) операторының көмегімен тізімнің ішкі бір бөлігін бірден жаңарта аламыз:

```python
>>> a_list = ["a", "b", "c", "d", "e", "f"]
>>> a_list[1:3] = ["x", "y"]
>>> a_list
['a', 'x', 'y', 'd', 'e', 'f']
```

Ал бос тізім тағайындау арқылы тізімнен элементтерді жоя аламыз:

```python
>>> a_list = ["a", "b", "c", "d", "e", "f"]
>>> a_list[1:3] = []
>>> a_list
['a', 'd', 'e', 'f']
```

Және біз тізімдерге жаңа элементтер қоса аламыз. Ол үшін бос орын кесіп алып, сол жерге енгіземіз:

```python
>>> a_list = ["a", "d", "f"]
>>> a_list[1:1] = ["b", "c"]
>>> a_list
['a', 'b', 'c', 'd', 'f']
>>> a_list[4:4] = ["e"]
>>> a_list
['a', 'b', 'c', 'd', 'e', 'f']
```

## 10.8. Тізімде жою

Тізім элементтерін жою үшін кесінділерді пайдалану қатеге бейім болуы мүмкін. Python оқуға болатын, оңай балама ұсынады. ```del``` операторы тізімнен элементті жояды:

```python
>>> num_list = ["one", "two", "three"]
>>> del num_list[1]
>>> num_list
['one', 'three']
```

Сіз күткендей, индекс ауқымнан тыс болса, ```del``` орындау уақыты қатесін тудырады.

Сондай-ақ ішкі тізімді (sublist) жою үшін ```del``` операторын ```slice```-пен бірге пайдалануға болады:

```python
>>> a_list = ["a", "b", "c", "d", "e", "f"]
>>> del a_list[1:5]
>>> a_list
['a', 'f']
```

Әдеттегідей, ```slice``` арқылы таңдалған ішкі тізім екінші индекске дейінгі барлық элементтерді қамтиды, бірақ екінші индекстің өзін қоспайды.

## 10.9. Объектілер мен сілтемелер

Мына тағайындау амалдарын орындағаннан кейін ...

```python
a = "banana"
b = "banana"
```

```a``` және ```b``` "banana" әріптері бар тіркес объектісіне сілтеме жасайтынын білеміз. Бірақ олар бір тіркес объектісіне нұсқайды ма, біз оны әлі білмейміз.

Python интерпретаторы жадыны реттеудің екі мүмкін жолы бар:

![banana](https://user-images.githubusercontent.com/84173441/175467365-c5ed287c-b12f-4141-a5be-c33833d716b6.JPG)

Бірінші жағдайда ```a``` және ```b``` бірдей мәнге ие екі түрлі объектіге сілтеме жасайды. Екінші жағдайда олар бір объектіге сілтеме жасайды.

```is``` операторының көмегімен екі атау бір объектіге сілтеме жасайды ма, тексере аламыз:

```python
>>> a is b
True
```

Бұл бізге ```a``` және ```b``` бірдей объектіге (object) сілтеме жасайтынын және бұл қатынасты дәл сипаттайтын екі күй суретінің екіншісі екенін көрсетеді.

Тіркестер өзгермейтін болғандықтан, Python бірдей тіркес мәніне сілтеме жасайтын екі атауды бір нысанға сілтеме жасау арқылы ресурстарды оңтайландырады (оптимизациялайды).

Ал тізімдерде жағдай ондай емес:

```python
>>> a = [1, 2, 3]
>>> b = [1, 2, 3]
>>> a == b
True
>>> a is b
False
```

Мұндағы күй суреті келесідей:

![list](https://user-images.githubusercontent.com/84173441/175469148-cb9031e6-c1a6-4e45-a898-ba24bb3cd3f0.JPG)

```a``` және ```b``` бірдей мәнге ие, бірақ бір нысанға сілтеме жасамайды.

## 10.10. Бүркеншік ат (Aliasing)

Айнымалылар объектілерге сілтеме жасайтын болғандықтан, егер бір айнымалыны екіншісіне тағайындасақ, екі айнымалы да бір нысанға сілтеме жасайды:

```python
>>> a = [1, 2, 3]
>>> b = a
>>> a is b
True
```

Бұл жағдайда күй суреті келесідей болады:

![same_reference](https://user-images.githubusercontent.com/84173441/175471623-6b71c7c4-4c5f-4471-93ff-0b0e63187459.JPG)

Бір тізімнің екі түрлі аты бар болғандықтан, ```a``` және ```b```, біз оны бүркеншік ат (**aliased**) деп айтамыз. Бір бүркеншік атпен жасалған өзгертулер екіншісіне әсер етеді:

```python
>>> b[0] = 5
>>> a
[5, 2, 3]
```

Бұл жұмыс приципі пайдалы болуы мүмкін болса да, ол кейде күтпеген немесе қалаусыз болады. Жалпы алғанда, өзгермелі нысандармен жұмыс істегенде бүркеншік ат қоюдан аулақ болған дұрыс (яғни, біздің оқулығымыздың осы сәтінде таныстырылған тізімдермен жұмыс істегенде, сондай-ақ біз алдағы бөлімдерде кластар мен объектілерді, сөздіктер мен жиындарды қамтитындықтан басқа да өзгеретін объектілерді кездестіреміз). Әрине, өзгермейтін объектілер (яғни, тіркестер, кортеждер) үшін ешқандай проблема жоқ — ол жерде өзгерістер жасап және бүркеншік атқа қол жеткізген кезде ешқандай түсініксіз нәтиже алу мүмкін емес. Сондықтан Python ресурсты үнемдеу мүмкіндігін көргенде өзгермейтін дерек типтері үшін бүркеншік атты еркін пайдалана алады.

## 10.11. Тізімдерді клондау

Егер біз тізімді өзгерткіміз келсе, сонымен қатар түпнұсқаның көшірмесін сақтағымыз келсе, біз сілтемені ғана емес, тізімнің де көшірмесін жасай алуымыз керек. Көшірме сөзі түсініксіздеу болып қалмас үшін бұл процесс кейде клондау (**cloning**) деп аталады.

Тізімді клондаудың ең оңай жолы - кесу (```slice```) операторын пайдалану:

```python
>>> a = [1, 2, 3]
>>> b = a[:]
>>> b
[1, 2, 3]
```

```a``` тізімінің кез келген бөлігін кесіп алу жаңа тізімді жасайды. Бұл жағдайда кесінді бүкіл тізімнен тұрады. Енді қарым-қатынас келесідей:

![cloning](https://user-images.githubusercontent.com/84173441/175474808-ce48b1ad-8b1c-4b83-a44c-a20b1af63d6c.JPG)

Енді біз байқаусызда ```a``` тізімін өзгертіп аламыз деп қорықпай ```b``` тізіміне өзгертулер енгізе аламыз:

```python
>>> b[0] = 5
>>> a
[1, 2, 3]
```

## 10.12. Тізімдер мен for циклі

```for``` циклі тізімдермен де жұмыс істейді.  ```for``` циклінің жалпы синтаксисі:

```python
for <VARIABLE> in <LIST>:
    <BODY>
```

Сонымен, біз көргендей

```python
friends = ["Joe", "Zoe", "Brad", "Angelina", "Zuki", "Thandi", "Paris"]
for friend in friends:
    print(friend)
```

Бұл Ағылшын тілін оқып отырған сияқты: 
**```For```** (every) **```friend in```** (the list of) **```friends, print```** (the name of the) **```friend```**.
Достар тізіміндегі (әрбір) дос үшін достың (атын) басып шығарыңыз.

Кез келген тізім өрнегі ```for``` циклінде қолданылуы мүмкін:

```python
for number in range(20):
    if number % 3 == 0:
        print(number)
```

Бұл мысал 0 мен 19 арасындағы 3-тің барлық еселіктерін басып шығарады.

```python
for fruit in ["banana", "apple", "quince"]:
    print("I like to eat " + fruit + "s!")
```

Ал бұл мысал әртүрлі жемістерге деген "махаббатты" білдіреді.

Тізімдер өзгермелі болғандықтан, біз оның әрбір элементін өзгерте отырып, жиі тізімді айналып өткіміз келеді. Келесі мысалдағы код ```xs``` тізіміндегі барлық сандарды квадраттайды:

```python
xs = [1, 2, 3, 4, 5]

for i in range(len(xs)):
    xs[i] = xs[i]**2
```

```range(len(xs))``` қалай жұмыс істейтінін түсінгенше біраз ойлануға уақыт бөліңіз.

Бұл мысалда бізді элементтің _мәні_ де (біз сол мәнді квадратқа алғымыз келеді) және оның _индексі_ де (сол позицияға жаңа мән тағайындау үшін) қызықтырады. Бұл үлгі қолданысы кең тарағандықтан, Python оны жүзеге асырудың жақсы-жеңіл әдісін ұсынады:

```python
xs = [1, 2, 3, 4, 5]

for (i, val) in enumerate(xs):
    xs[i] = val**2
```

```enumerate``` тізімді айналу кезінде екеуінің де (индекс, мән) жұптарын жасайды. ```enumerate``` (санау) қалай жұмыс істейтінін нақтырақ көру үшін келесі мысалды қолданып көріңіз:

```python
for (i, v) in enumerate(["banana", "apple", "pear", "lemon"]):
     print(i, v)
```

```python
0 banana
1 apple
2 pear
3 lemon
```

қосымша мына мысалды да түсіну үшін зерттеп қараңыз:

```python
some_list = ["banana", "apple", "pea", "blueberry", "strawberry"]

enumerated_list = enumerate(some_list)

print(list(enumerated_list))
```

```
>>> [(0, 'banana'), (1, 'apple'), (2, 'pea'), (3, 'blueberry'), (4, 'strawberry')]
```

## 10.13. Тізім параметр

Тізімді аргумент ретінде беру тізімнің көшірмесін немесе клонын емес, тізімге сілтемені береді. Сонымен, параметрді беру сіз үшін бүркеншік ат жасайды: шақырушыда тізімге сілтеме жасайтын бір айнымалы бар, ал шақырылған функция бүркеншік атты қамтиды, бірақ бұл жерде бір ғана тізім объектісі бар. Мысалы, төмендегі функция тізімді аргумент ретінде қабылдайды және тізімдегі әрбір элементті 2-ге көбейтеді:

```python
def double_stuff(a_list):
    """ Overwrite each element in a_list with double its value. """
    for (index, val) in enumerate(a_list):
        a_list[index] = val * 2
```

Егер біз скриптіге келесіні қоссақ:

```python
things = [2, 5, 9]
double_stuff(things)
print(things)
```

Оны іске қосқан кезде біз мынаны аламыз:

```python
[4, 10, 18]
```

Жоғарыдағы функцияда ```a_list``` параметрі және айнымалы ```things``` бір объект үшін бүркеншік аттар болып табылады. Сонымен, тізімдегі элементтерге кез келген өзгертулер енгізбес бұрын, күй суреті келесідей болады:

![aliases](https://user-images.githubusercontent.com/84173441/175482492-da0bb127-f392-4705-b394-892ddad5bdcd.JPG)

Тізім объектісі екі бүркеншік аттарға ортақ болғандықтан, біз оны олардың арасына сыздық.

Егер функция тізім параметрінің элементтерін өзгертсе, функцияны шақырушы өзгерісті көреді.

## 10.14. Тізім әдістері

Нүкте операторын тізім объектісінің кірістірілген әдістеріне қол жеткізу үшін пайдалануға болады. Біз, сол сәтте жасалып қойған, бар тізімнің соңына бір нәрсе қосуға қолданылатын ең пайдалы әдістен бастаймыз:

```python
>>> mylist = []
>>> mylist.append(5)
>>> mylist.append(27)
>>> mylist.append(3)
>>> mylist.append(12)
>>> mylist
[5, 27, 3, 12]
```

```append``` — берілген аргументті тізімнің соңына қосатын тізім әдісі. Біз оны жаңа тізімдер жасағанда көп пайдаланамыз. Осы мысалды жалғастыра отырып, біз бірнеше басқа тізім әдістерін көрсетеміз:

```python
>>> mylist = [5, 27, 3, 12]
>>> mylist.insert(1, 12)  # 12 санын 1-ші позицияға енгіз, қалған мәндерді бір орынға жылжыт/сырғыт
>>> mylist
[5, 12, 27, 3, 12]
>>> mylist.count(12)       # mylist-те 12 саны неше рет бар
2
>>> mylist.extend([5, 9, 5, 11])   # мына жаңа тізімді mylist тізімінің соңына тірке
>>> mylist
[5, 12, 27, 3, 12, 5, 9, 5, 11])
>>> mylist.index(9)                # mylist-тегі бірінші кездесетін 9 санының индексін көрсет
6
>>> mylist.reverse()
>>> mylist
[11, 5, 9, 5, 12, 3, 27, 12, 5]
>>> mylist.sort()
>>> mylist
[3, 5, 5, 5, 9, 11, 12, 12, 27]
>>> mylist.remove(12)             # Тізімдегі бірінші кездесетін 12 санын жойып таста
>>> mylist
[3, 5, 5, 5, 9, 11, 12, 27]
```

Мұнда көрсетілген тізім әдістерімен тәжірибе жасап, ойнаңыз және олардың қалай жұмыс істейтінін түсінгеніңізге сенімді болғанша олардың құжаттамасын оқыңыз.

## 10.15. Таза функциялар мен модификаторлар

Бұрын көргендей, таза функция мен жанама әсерлері бар функцияның арасында айырмашылық бар. Айырмашылық төменде көрсетілген, өйткені тізімдерде назар аударатын кейбір ерекшеліктер бар.

Тізімдерді аргументтер ретінде қабылдайтын және оларды орындау кезінде өзгертетін функциялар модификаторлар (**modifiers**), ал олар жасайтын өзгерістер жанама әсерлер (**side effects**) деп аталады.

Таза функция (**pure function**) жанама әсерлер тудырмайды. Таза функциялар оны шақыратын бағдарламамен параметрлер және қайтаратын мән арқылы ғана байланысады. Және таза функция параметрлерін өзгертпейді. 

Мұнда ```double_stuff``` таза функция ретінде жазылған:

```python
def double_stuff(a_list):
    """ Return a new list which contains
        doubles of the elements in a_list.
    """
    new_list = []
    for value in a_list:
        new_elem = 2 * value
        new_list.append(new_elem)

    return new_list
```

```double_stuff```-тың бұл нұсқасы өзінің аргументтерін өзгертпейді:

```python
>>> things = [2, 5, 9]
>>> more_things = double_stuff(things)
>>> things
[2, 5, 9]
>>> more_things
[4, 10, 18]
```

Тағайындау үшін біз көрген ертерек ережеде «алдымен оң жағын бағалаңыз, содан кейін нәтиже мәнін айнымалыға тағайындаңыз» делінген. Сондықтан функция нәтижесін функцияға берілген айнымалыға тағайындауға әбден болады:

```python
>>> things = [2, 5, 9]
>>> things = double_stuff(things)
>>> things
[4, 10, 18]
```

Қай стиль жақсы?

Модификаторлармен жасауға болатын кез келген нәрсені таза функциялармен де жасауға болады. Шындығында, кейбір бағдарламалау тілдері тек таза функцияларға мүмкіндік береді. Таза функцияларды пайдаланатын бағдарламалар модификаторларды пайдаланатын бағдарламаларға қарағанда тезірек орындалатынын және қателіктің аз болатынын көрсететін кейбір дәлелдер бар. Соған қарамастан, модификаторлар кейде ыңғайлы, ал кейбір жағдайларда функционалдық бағдарламалардың тиімділігі төмен.

Тұтастай алғанда, мүмкін болған барлық кезде таза функцияларды жазуды және мәжбүрлі артықшылық болған жағдайда ғана модификаторларға жүгінуді ұсынамыз. Бұл тәсілді функционалдық бағдарламалау стилі деп атауға болады.

## 10.16. Тізімдер жасайтын функциялар

Жоғарыдағы ```double_stuff``` таза нұсқасы сізге болашақта қажет болатын үлгіні (**pattern**) қолданды. Тізімді жасайтын және қайтаратын функцияны жазу қажет болған кезде әдетте үлгі мынандай:

```python
initialize a result variable to be an empty list
loop
   create a new element
   append it to result
return the result

# result (нәтиже) болатын айнымалыны бос тізім етіп инициялизациялау
# цикл
#    жаңа элемент жасау
#    оны result-қа тіркестіру
# нәтижені қайтару
```

Осы үлгінің тағы бір қолданылуын көрсетейік. Сізде ```x``` [жай сан](https://kk.wikipedia.org/wiki/%D0%96%D0%B0%D0%B9_%D1%81%D0%B0%D0%BD) екенін тексере алатын ```is_prime(x)``` функциясы бар делік. ```n```-нен кіші барлық жай сандар тізімін қайтаратын функцияны жазыңыз:

(\* _Төмендегі кодты бір танысқан соң, жаттығулар бөліміне келгенде өз бетіңізбен жазып көріңіз. ```is_prime```-нан бастап_)

```python
def primes_lessthan(n):
    """ Return a list of all prime numbers less than n. """
    result = []
    for i in range(2, n):
        if is_prime(i):
           result.append(i)
    return result
```

```python
def is_prime(n):
  for i in range(2,n):
    if (n % i) == 0:
      return False
  return True 


def primes_less_than(thisNum):
    numsList = []
    for i in range(thisNum):
        if is_prime(i):
            numsList.append(i)
    return numsList


print(primes_less_than(1000), end=", ")
```

## 11.17. Тіркестер мен тізімдер

Тіркестерге байланысты ең пайдалы әдістердің екеуі substring-тер тізіміне кесу және керісінше. Бөлу (```split```) әдісі (біз оны бұрын көрдік) тіркесті сөздер тізіміне бөледі. Әдепкі бойынша бос орын таңбаларының кез келген саны сөз шекарасы болып саналады:

```python
>>> song = "The rain in Spain..."
>>> words = song.split()
>>> words
['The', 'rain', 'in', 'Spain...']
```

Бөлгіш (**delimiter**) деп аталатын қосымша аргумент ішкі тіркестер арасындағы шекара маркері ретінде қолданылатын тіркесті (не таңбаны) көрсету үшін пайдаланылуы мүмкін. Келесі мысал бөлгіш ретінде ```ai``` жолын пайдаланады:

```python
>>> song.split("ai")
['The r', 'n in Sp', 'n...']
```

Нәтижеде бөлгіштің көрсетілмейтініне назар аударыңыз.

Бөлу әдісінің кері әдісі біріктіру (```join```) болып табылады. Сіз қажетті бөлгіш (**separator**) тіркесті таңдайсыз (көбінесе _glue/желім_ деп аталады ) және тізімді элементтердің әрқайсысының арасындағы желіммен біріктіресіз:

```python
>>> glue = ";"
>>> phrase = glue.join(words)
>>> phrase
'The;rain;in;Spain...'
```

Сіз біріктіретін тізім (бұл мысалдағы ```words```) өзгертілмеген. Сондай-ақ, келесі мысалдар көрсеткендей, желім ретінде бос желім немесе көп таңбалы тіркестерді пайдалануға болады:

```python
>>> " --- ".join(words)
'The --- rain --- in --- Spain...'
>>> "".join(words)
'TheraininSpain...'
```

## 10.18. list және range

Python-да ```list``` деп аталатын кірістірілген түрлендіру функциясы бар, ол сіз берген кез-келген нәрсені тізімге айналдыруға тырысады.

```python
>>> letters = list("Crunchy Frog")
>>> letters
["C", "r", "u", "n", "c", "h", "y", " ", "F", "r", "o", "g"]
>>> "".join(letters)
'Crunchy Frog'
```

```range```-дің өте бір ерекшелігі, ол өзінің барлық мәндерін бірден есептемейді: ол есептеуді «кейінге қалдырады» және оны сұраныс бойынша - «жалқаулықпен» жасайды. Біз мұны ```range``` мәндерді қажет кезде шығаруға уәде (**promise**) береді деп айтамыз. Бұл өте ыңғайлы, егер сіздің есептеулеріңіз іздеуді қысқартып, ертерек қайтарылса, мысалы:

```python
def div21(n):
    """ Find the first positive integer between 101 and less than n that is divisible by 21
        101 саны мен n-ның арасындағы 21-ге бөлінетін бірінші санды табатын функция
    """
    for i in range(101, n):
       if (i % 21 == 0):
           return i


print(div21(110))
print(div21(1000000000))
```

Екінші ```print```-те, егер ```range``` (диапазон) барлық осы элементтерден тұратын тізімді құруға ынтамен кіріссе, сіз көп ұзамай компьютеріңіздің қол жетімді жадын таусып, бағдарламаны бұзасыз. Бірақ бұл одан да ақылды! Бұл есептеу өте жақсы жұмыс істейді, өйткені ```range``` объектісі элементтерді қажет болған жағдайда және қашан керек болғанда шығаруға уәде береді. ```if``` ішіндегі шарт ```True``` болғаннан кейін, басқа элементтер жасалмайды және функция қайтарылады. (Ескерту: Python 3-ке дейін диапазон "lazy /жалқау" емес еді. Python-ның бұрынғы нұсқаларын пайдалансаңыз, YMMV!)

---

YMMV: Сіздің жүгірісіңіз әртүрлі болуы мүмкін
**Y**our **M**ileage **M**ay **V**ary

YMMV аббревиатурасы әр түрлі болуы мүмкін жүгірісіңізді білдіреді. Американдық автомобиль жарнамаларында автомобильдер үшін жанармай тұтыну көрсеткіштері жиі келтірілді, мысалы, олар бір галлонға 28 миль жүресіз. Бірақ бұл әрқашан оқырманға олар бірдей болмауы мүмкін екенін ескертетін заңды шағын баспамен бірге жүруі керек еді. YMMV термині енді идиоматикалық түрде «нәтижелеріңіз әртүрлі болуы мүмкін» дегенді білдіреді, мысалы, ```"Бұл телефондағы батареяның қызмет ету мерзімі 3 күн, бірақ YMMV"```.

---

Бірінші жағдайда ```range``` ештеме жасамай күтіп тұрады. 
Бірақ сіз кейде "жалқау" диапазонды (```range```) шақыруыңыз мүмкін. Бұл Python-ды "жалқау" уәдені нақты тізімге айналдыруға мәжбүр етеді:

```python
>>> range(10)                     # Create a lazy promise
range(0, 10)
>>> list(range(10))               # Call in the promise, to produce a list.
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

## 10.19. Цикл және тізімдер

Компьютерлер пайдалы, өйткені олар есептеулерді дәл және жылдам қайталай алады. Осылайша, циклдар сіз кезіккен барлық дерлік бағдарламалардың негізгі, орталық мүмкіндігі болады.

---

**Кеңес**: қажетсіз тізімдерді жасамаңыз
Деректерді кейінірек есептеу үшін сақтау қажет болса, тізімдер пайдалы. Бірақ егер сізге тізімдер қажет болмаса, оларды жасамағаныңыз жөн.

---

Мұнда он миллион диапазонында кездейсоқ сандарды жасайтын және сандардың қосындысын қайтаратын екі функция бар. Екеуі де жұмыс істейді.

⚠️ _Ескерту: 10 миллионды 10 мыңға азайтып жасап көріңіз. 10 миллиондық кодты түсініп, ойлап қарасаңыз жеткілікті_

```python
import random
joe = random.Random()

def sum1():
    """ Build a list of random numbers, then sum them """
    xs = []
    for i in range(10000000):
        num = joe.randrange(1000) # Generate one random number
        xs.append(num) # Save it in our list
        
    tot = sum(xs)
    return tot
    
def sum2():
    """ Sum the random numbers as we generate them """
    tot = 0
    for i in range(10000000):
        num = joe.randrange(1000)
        tot += num
    return tot
    
print(sum1())
print(sum2())    
```

Мұнда екінші нұсқаны таңдаудың қандай себептері бар? (Кеңес: компьютерде өнімділік мониторы Performance Monitor сияқты құралды ашып, жадты пайдалануды қадағалаңыз. ```sum1```-де жадта бұзатын қате пайда болғанға дейін тізімді қаншалықты үлкен етіп жасауға болады?)


Сол сияқты, файлдармен жұмыс істегенде, бізде көбінесе файлдың бүкіл мазмұнын бір жолға оқу мүмкіндігі бар немесе біз бір жолды бір уақытта оқып, әр жолды оқу барысында өңдей аламыз. Бір уақыттағы қатар - бұл әрекеттерді орындаудың дәстүрлі және мүмкін қауіпсіз әдісі - файл қаншалықты үлкен болса да, ыңғайлы жұмыс істей аласыз. (Және, әрине, файлдарды өңдеудің бұл режимі ескі күндерде компьютер жадылары әлдеқайда аз болған кезде өте маңызды болды.) Бірақ сіз бір уақытта бүкіл файлды кейде ыңғайлырақ деп таба аласыз!


## 10.20. Кірістірілген тізімдер 

Кірістірілген тізім - бұл басқа тізімге элемент болып келетін тізім. Мына төмендегі тізімде 3-ші индексте орналасқан элемент кірістірілген тізім болып табылады:

```python
>>> nested = ["hello", 2.0, 5, [10, 20]]
```

Егер біз 3-ші индекстегі элементті шығарсақ, мынаны аламыз:

```python
>>> print(nested[3])
[10, 20]
```

Кірістірілген тізімнен элементті шығаруды екі қадамда орындай аламыз:

```python
>>> elem = nested[3]
>>> elem[0]
10
```

Немесе біз оларды біріктіре аламыз:

```python
>>> nested[3][1]
20
```

Жақша операторлары солдан оңға қарай бағалайды, сондықтан бұл өрнек кірістірілген элементтің 3-ші элементін алады және одан 1-ші элементті шығарады.

## 10.20. Матрицалар 

Кірістірілген тізімдер жиі матрицаларды көрсету үшін пайдаланылады. Мысалы, матрица:

![matrices](https://user-images.githubusercontent.com/84173441/175509417-fa4f48b9-6c0c-4838-a0b0-d4a9709afb5d.JPG)

тізімде былай ұсынылуы мүмкін:

```python
>>> mx = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
```

```mx``` – үш элементтен тұратын тізім, мұнда әрбір элемент матрица қатары болып табылады. 

Біз матрицадан бүкіл қатарды әдеттегідей таңдай аламыз:

```python
>>> mx[1]
[4, 5, 6]
```

Немесе қос индексті форманы пайдаланып матрицадан бір элементті шығарып аламыз:

```python
>>> mx[1][2]
6
```

Бірінші индекс қатарды, ал екінші индекс бағанды таңдайды. Матрицаларды көрсетудің бұл жолы кең таралған болса да, бұл жалғыз мүмкіндік емес. Кішкентай вариация - қатар тізімінің орнына бағандар тізімін пайдалану. Кейінірек сөздікті пайдалана отырып, түбегейлі баламасын (басқа / алтернативасын) көреміз.

## 10.21. Глоссарий

**бүркеншік аттар** / **aliases**
Бір нысанға сілтемелерді қамтитын бірнеше айнымалылар.

**клондау** / **clone**
Бар нысанмен бірдей мәнге ие жаңа нысан жасау үшін. Нысанға сілтемені көшіру бүркеншік ат жасайды, бірақ нысанды клондамайды.

**бөлгіш** / **delimiter**
Тіркесті қай жерде бөлу керектігін көрсету үшін пайдаланылатын таңба немесе тіркес.

**элемент** / **element**
Тізімдегі мәндердің бірі (немесе кез-келген басқа реттілікте / sequence). Жақша операторы тізімнің элементтерін таңдайды. Элемент _item_ деп те аталады .

**өзгермейтін деректер мәні** / **immutable data value**
Өзгертуге болмайтын деректер мәні. Элементтерге немесе өзгермейтін мәндердің кесінділеріне (ішкі бөліктерге) тағайындаулар жасау орындалу қатесін тудырады.

**индекс** / **index**
Тізімдегі элементтің орнын көрсететін бүтін мән. Индекстер 0-ден басталады.

**item** / **item**
_элементті_ қараңыз.

**тізім** / **list**
Мәндер жинағы, олар тізімде тұрақты позицияда болады. Басқа ```str```, ```int```, ```float``` және т.б. түрлері сияқты, сіз берген кез келген аргументті тізімге айналдыруға тырысатын ```list``` тип түрлендіргіш функциясы да бар.

**тізімді өту** / **list traversal**
Тізімдегі әрбір элементке рет-ретімен қатынасу.

**модификатор** / **modifier**
Функция денесінің ішіндегі аргументтерін өзгертетін функция. Модификаторлар арқылы өзгеретін түрлерді ғана өзгертуге болады.

**өзгермелі деректер мәні** / **mutable data value**
Өзгертуге болатын деректер мәні. Барлық өзгермелі мәндердің түрлері құрама типтер болып табылады. Тізімдер мен сөздіктер өзгермелі; жолдар мен кортеждер жоқ.

**кірістірілген тізім** / **nested list**
Басқа тізімнің элементі болып табылатын тізім.

**объект** / **object**
Айнымалы сілтеме жасай алатын "нәрсе".

**үлгі** / **pattern**
Амалдардың тізбегі немесе әртүрлі жағдайда қолдануға болатын жалпыланған код және оны жазу стилі. Жетілген информатика маманы (Computer Science) болудың бір бөлігі - құралдар жинағыңызды құрайтын үлгілер мен алгоритмдерді үйрену және қолдану. Үлгілер көбінесе сіздің «ойша бөлулеріңізге» сәйкес келеді.

**уәде** / **promise**
Егер ақыр соңында қажет болса, кейбір жұмыстарды орындауға немесе кейбір мәндерді жеткізуге уәде беретін объект, бірақ ол жұмысты дереу орындауды жалқаулықпен кейінге қалдырады. ```range```-ді шақыру уәде береді.

**таза функция** / **pure function**
Жанама әсерлері жоқ функция. Таза функциялар тек қайтаратын мәндер арқылы шақырушы бағдарламаға өзгертулер енгізеді.

**жүйелік, реттілік** / **sequence**
Әрбір элемент индекс арқылы анықталған элементтердің реттелген жиынынан тұратын деректер түрлерінің кез келгені.

**жанама әсер** / **side effect**
Функцияны шақырудың әсерінен программа күйінің өзгеруі. Жанама әсерлерді модификаторлар ғана жасай алады.

**қадам өлшемі** / **step size**
Сызықтық тізбектің бірізді элементтері арасындағы интервал. ```range``` функциясының үшінші (және қосымша аргументі) қадам өлшемі деп аталады. Көрсетілмеген болса, ол әдепкі бойынша 1 болады.

## 10.22. Жаттығулар 

1. Төмендегіге Python интерпретаторының жауабы қандай?

```python
>>> list(range(10, 0, -2))
```

```range``` (ауқым) функциясының үш аргументі сәйкесінше ```start``` (бастау), ```stop``` (тоқтату) және ```size``` (қадам) болып табылады. Бұл мысалда ```start``` ```stop```-тан үлкенірек. ```start``` < ```stop``` және ```size``` < 0 болса не болады? Бастау , тоқтату және қадам (```stop, start, size```) арасындағы қатынастардың ережесін жазыңыз.

2. Бұл код фрагментін қарастырыңыз:

```python
import turtle

tess = turtle.Turtle()
alex = tess
alex.color("hotpink")
```

Бұл фрагмент бір әлде екі тасбақа инстанциясын (instance) жасайды ма? ```alex```-тің түсін орнату ```tess```-тің түсін де өзгерте ме? Егжей-тегжейлі түсіндіріңіз.

3. Келесі Python кодының үшінші жолы орындалғанға дейін және кейін ```a``` және ```b``` күйінің суретін салыңыз:

```python
a = [1, 2, 3]
b = a[:]
b[0] = 5
```

4. Келесі бағдарламаның нәтижесі қандай болады?

```python
this = ["I", "am", "not", "a", "crook"]
that = ["I", "am", "not", "a", "crook"]
print("Test 1: {0}".format(this is that))
that = this
print("Test 2: {0}".format(this is that))
```

Нәтижелерге егжей-тегжейлі түсініктеме беріңіз.

5. Тізімдерді математикалық _векторларды_ көрсету үшін пайдалануға болады. Осы және одан кейінгі бірнеше жаттығуларда векторлармен стандартты операцияларды орындау үшін функцияларды жазасыз. ```vectors.py``` деп аталатын script жасаңыз және әр жағдайда сынақтардан өту үшін Python кодын жазыңыз.

Сандардан тұратын, ұзындығы бірдей екі тізімді алатын және әрқайсысының сәйкес элементтерінің қосындыларын қамтитын жаңа тізімді қайтаратын ```add_vectors(vector1,vector2)``` функциясын жазыңыз:

```python
test(add_vectors([1, 1], [1, 1]) == [2, 2])
test(add_vectors([1, 2], [1, 4]) == [2, 6])
test(add_vectors([1, 2, 1], [1, 4, 3]) == [2, 6, 4])
```

6. Санды ```scalar``` және тізімді ```vector``` аргумент ретінде қабылдайтын ```scalar_mult(scalar, vector)``` функциясын жазыңыз, ол [Скалярлық көбейту](https://en-m-wikipedia-org.translate.goog/wiki/Scalar_multiplication?_x_tr_sl=en&_x_tr_tl=kk&_x_tr_hl=en&_x_tr_pto=wapp) вектордың скалярлық еселігін қайтаруы керек. [Wikipedia_en](https://en.wikipedia.org/wiki/Scalar_multiplication)

\* Қарапайым тілмен айтқанда, берілген вектор мәндерін ```scalar``` деп берілген санға көбейтетін функция жазу керек. Төмендегі өту керек сынақтарды қараңыз

```python
test(scalar_mult(5, [1, 2]) == [5, 10])
test(scalar_mult(3, [1, 0, -1]) == [3, 0, -3])
test(scalar_mult(7, [3, 0, 5, 11, 2]) == [21, 0, 35, 77, 14])
```

7. Мәндері сан болатын ұзындығы бірдей екі тізімді аргумент ретінде алатын және әрқайсысының сәйкес элементтерінің көбейтінділерінің қосындысын қайтаратын ```dot_product(vec1,vec2)``` функциясын жазыңыз. \* қосымша: ([dot_product](https://en.wikipedia.org/wiki/Dot_product))

```python
test(dot_product([1, 1], [1, 1]) ==  2)
test(dot_product([1, 2], [1, 4]) ==  9)
test(dot_product([1, 2, 1], [1, 4, 3]) == 12)
```

8. _Математикаға бейім адамдар үшін қосымша сынақ_: Ұзындығы 3 сандардың екі тізімін алатын және олардың айқас көбейтіндісін ([cross product](https://en.wikipedia.org/wiki/Cross_product)) қайтаратын ```cross_product(vec1, vec2)``` функциясын жазыңыз . Сіз өзіңіздің тесттеріңізді жазуыңыз керек.

9. Төмендегі код фрагментіндегі ```song``` пен " ".```join(song.split())``` мен арасындағы байланысты сипаттаңыз. Олар ```song```-қа тағайындалған барлық тіркестер үшін бірдей ме? Олар қашан басқаша болады?

```python
song = "The rain in Spain..."
```

10. ```s``` тіркесіндегі ```old```-тың барлық кездесулерін ```new```-мен ауыстыратын ```replace(s, old, new)``` функциясын жазыңыз:

```python
test(replace("Mississippi", "i", "I") == "MIssIssIppI")

s = "I love spom! Spom is my favorite food. Spom, spom, yum!"
test(replace(s, "om", "am") ==
    "I love spam! Spam is my favorite food. Spam, spam, yum!")

test(replace(s, "o", "a") ==
    "I lave spam! Spam is my favarite faad. Spam, spam, yum!")
```

Кеңес: бөлу ```split``` және біріктіру ```join``` әдістерін пайдаланыңыз.

